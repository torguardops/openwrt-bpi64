From 17fe04157b17184c23f06d29f3b916dcc281a5b0 Mon Sep 17 00:00:00 2001
From: TorGuard Ops <ops@torguard.net>
Date: Mon, 19 Sep 2022 00:24:26 +0000
Subject: [PATCH] R64 SD Compile

---
 include/image-commands.mk                     |   37 +-
 include/image.mk                              |    8 +-
 package/base-files/files/lib/upgrade/nand.sh  |  102 +-
 .../arm-trusted-firmware-mediatek/Makefile    |  103 +-
 .../patches/100-increase-nor-bl3-size.patch   |   11 +
 package/boot/uboot-mediatek/Makefile          |  113 +-
 ...-clk-Add-debugging-for-return-values.patch |   69 +
 ...atek-add-more-network-configurations.patch |   44 +
 ...d-increase-the-minimum-bus-frequency.patch |   28 +
 ...support-for-MediaTek-SPI-NAND-flash-.patch | 3698 +++++++
 ...15-mtd-mtk-snand-add-support-for-SPL.patch |  174 +
 ...v-add-support-for-generic-MTD-device.patch |  409 +
 ...dd-support-for-booting-from-SPI-NAND.patch |  266 +
 ...board-mt7622-use-new-spi-nand-driver.patch |   76 +
 ...emove-unused-options-and-add-dm-comm.patch |   31 +
 ...22-enable-environment-for-mt7622_rfb.patch |   33 +
 .../002-nand-add-spi-nand-driver.patch        | 8659 -----------------
 ...boot-add-dts-and-config-for-spi-nand.patch |   64 -
 ...le-mtd-and-mtk_spi_nand-in-defconfig.patch |   39 -
 .../patches/005-update-bpir2-defconfig.patch  |   17 -
 .../patches/010-no-binman.patch               |   23 -
 .../patches/050-mt7622-enable-pstore.patch    |   33 +
 ...00-scripts-remove-dependency-on-swig.patch |   24 +
 .../patches/110-no-kwbimage.patch             |   10 +
 .../patches/120-use-xz-instead-of-lzma.patch  |   11 +
 .../patches/200-cmd-add-imsz-and-imszb.patch  |  132 +
 ...d-ability-to-select-item-by-shortkey.patch |  192 +
 .../211-cmd-bootmenu-custom-title.patch       |   32 +
 .../patches/220-cmd-env-readmem.patch         |  116 +
 .../patches/230-cmd-add-pstore-check.patch    |   78 +
 .../patches/260-add-missing-type-u64.patch    |   10 +
 ...7622-generic-reset-button-ignore-env.patch |   52 +
 ...50-add-support-for-Winbond-W25Q512JV.patch |   11 +
 .../patches/400-update-bpir2-defconfig.patch  |  302 +
 ...patch => 401-update-u7623-defconfig.patch} |    4 +-
 ...-update-bananapi-bpi-r64-device-tree.patch |   71 +
 .../403-add-bananapi_bpi-r64-snand.patch      |   33 +
 .../404-add-bananapi_bpi-r64_defconfigs.patch |  655 ++
 .../405-dts-mt7623n-bpi-r2-fix-leds.patch     |   25 +
 .../patches/410-add-linksys-e8450.patch       |  406 +
 .../patches/412-add-ubnt-unifi-6-lr.patch     |  453 +
 scripts/mkits.sh                              |  136 +-
 scripts/target-metadata.pl                    |    1 +
 target/Config.in                              |    3 +
 target/linux/generic/config-5.4               |    1 +
 .../generic/files/block/partitions/fit.c      |  254 +
 .../400-block-fit-partition-parser.patch      |  200 +
 ...to-create-ubiblock-device-for-rootfs.patch |    7 +-
 target/linux/mediatek/Makefile                |    2 +-
 .../mt7622-bananapi-bpi-r64-rootdisk.dts      |  591 --
 .../mediatek/mt7622-elecom-wrc-2533gent.dts   |  608 --
 .../boot/dts/mediatek/mt7622-rfb1-ubi.dts     |  644 --
 .../dts/mediatek/mt7622-ubnt-unifi-6-lr.dts   |  327 -
 target/linux/mediatek/image/Makefile          |    2 +-
 target/linux/mediatek/image/mt7622.mk         |   83 +-
 .../base-files-old/etc/board.d/02_network     |   65 +
 .../lib/preinit/79_move_config                |    0
 .../base-files-old/lib/upgrade/platform.sh    |  107 +
 .../mt7622/base-files/etc/board.d/01_leds     |   17 +
 .../mt7622/base-files/etc/board.d/02_network  |   21 +-
 .../mt7622/base-files/etc/init.d/bootcount    |   11 +
 .../base-files/etc/uci-defaults/09_fix_crc    |   10 +
 .../mt7622/base-files/lib/upgrade/buffalo.sh  |  126 +
 .../mt7622/base-files/lib/upgrade/platform.sh |   70 +-
 target/linux/mediatek/mt7622/config-5.4       |    1 +
 target/linux/mediatek/mt7622/target.mk        |    2 +-
 ...mt7622-bpi-r64-aliases-for-dtoverlay.patch |   80 +
 tools/firmware-utils/Makefile                 |   87 +-
 tools/firmware-utils/src/add_header.c         |    2 +-
 tools/firmware-utils/src/asustrx.c            |    5 +-
 tools/firmware-utils/src/bcmalgo.c            |    3 +-
 tools/firmware-utils/src/cyg_crc.h            |   12 +-
 tools/firmware-utils/src/cyg_crc16.c          |    3 +-
 tools/firmware-utils/src/cyg_crc32.c          |   10 +-
 tools/firmware-utils/src/dgn3500sum.c         |    2 +-
 tools/firmware-utils/src/dns313-header.c      |   19 +-
 tools/firmware-utils/src/fw.h                 |    8 +-
 tools/firmware-utils/src/imagetag.c           |    9 +-
 tools/firmware-utils/src/mkbrnimg.c           |    7 +-
 tools/firmware-utils/src/mkcasfw.c            |   31 +-
 tools/firmware-utils/src/mkcsysimg.c          |   21 +-
 tools/firmware-utils/src/mkdapimg.c           |    3 +-
 tools/firmware-utils/src/mkdapimg2.c          |    3 +-
 tools/firmware-utils/src/mkdniimg.c           |    2 -
 tools/firmware-utils/src/mkfwimage2.c         |    1 -
 tools/firmware-utils/src/mkmylofw.c           |   18 +-
 tools/firmware-utils/src/mkplanexfw.c         |    2 -
 tools/firmware-utils/src/mkrtn56uimg.c        |   14 +-
 tools/firmware-utils/src/mktitanimg.c         |    8 +-
 tools/firmware-utils/src/mktplinkfw2.c        |    1 -
 tools/firmware-utils/src/mkwrggimg.c          |    2 +-
 tools/firmware-utils/src/mkwrgimg.c           |    2 +-
 tools/firmware-utils/src/mkzcfw.c             |    8 -
 tools/firmware-utils/src/mkzynfw.c            |   19 +-
 tools/firmware-utils/src/osbridge-crc.c       |    2 -
 tools/firmware-utils/src/otrx.c               |   15 +-
 tools/firmware-utils/src/pc1crypt.c           |    2 -
 tools/firmware-utils/src/ptgen.c              |  141 +-
 tools/firmware-utils/src/sha1.c               |    3 +-
 tools/firmware-utils/src/sha1.h               |    2 +-
 tools/firmware-utils/src/spw303v.c            |    7 +-
 tools/firmware-utils/src/srec2bin.c           |    3 +-
 tools/firmware-utils/src/tplink-safeloader.c  |  243 +-
 tools/firmware-utils/src/trx2edips.c          |    4 +
 tools/firmware-utils/src/xorimage.c           |   15 +-
 tools/firmware-utils/src/zyimage.c            |    2 -
 tools/firmware-utils/src/zytrx.c              |  228 -
 ...add-support-for-booting-ARM64-images.patch |  134 +
 ...n-option-to-set-device-header-offset.patch |  226 +
 109 files changed, 9653 insertions(+), 11699 deletions(-)
 create mode 100644 package/boot/arm-trusted-firmware-mediatek/patches/100-increase-nor-bl3-size.patch
 create mode 100644 package/boot/uboot-mediatek/patches/000-mtk-01-Revert-clk-Add-debugging-for-return-values.patch
 create mode 100644 package/boot/uboot-mediatek/patches/000-mtk-09-board-mediatek-add-more-network-configurations.patch
 create mode 100644 package/boot/uboot-mediatek/patches/000-mtk-10-mmc-mtk-sd-increase-the-minimum-bus-frequency.patch
 create mode 100644 package/boot/uboot-mediatek/patches/000-mtk-14-drivers-mtd-add-support-for-MediaTek-SPI-NAND-flash-.patch
 create mode 100644 package/boot/uboot-mediatek/patches/000-mtk-15-mtd-mtk-snand-add-support-for-SPL.patch
 create mode 100644 package/boot/uboot-mediatek/patches/000-mtk-16-env-add-support-for-generic-MTD-device.patch
 create mode 100644 package/boot/uboot-mediatek/patches/000-mtk-17-board-mt7629-add-support-for-booting-from-SPI-NAND.patch
 create mode 100644 package/boot/uboot-mediatek/patches/000-mtk-18-board-mt7622-use-new-spi-nand-driver.patch
 create mode 100644 package/boot/uboot-mediatek/patches/000-mtk-19-configs-mt7629-remove-unused-options-and-add-dm-comm.patch
 create mode 100644 package/boot/uboot-mediatek/patches/000-mtk-20-configs-mt7622-enable-environment-for-mt7622_rfb.patch
 delete mode 100644 package/boot/uboot-mediatek/patches/002-nand-add-spi-nand-driver.patch
 delete mode 100644 package/boot/uboot-mediatek/patches/003-mt7622-uboot-add-dts-and-config-for-spi-nand.patch
 delete mode 100644 package/boot/uboot-mediatek/patches/004-configs-enable-mtd-and-mtk_spi_nand-in-defconfig.patch
 delete mode 100644 package/boot/uboot-mediatek/patches/005-update-bpir2-defconfig.patch
 delete mode 100644 package/boot/uboot-mediatek/patches/010-no-binman.patch
 create mode 100644 package/boot/uboot-mediatek/patches/050-mt7622-enable-pstore.patch
 create mode 100644 package/boot/uboot-mediatek/patches/100-scripts-remove-dependency-on-swig.patch
 create mode 100644 package/boot/uboot-mediatek/patches/110-no-kwbimage.patch
 create mode 100644 package/boot/uboot-mediatek/patches/120-use-xz-instead-of-lzma.patch
 create mode 100644 package/boot/uboot-mediatek/patches/200-cmd-add-imsz-and-imszb.patch
 create mode 100644 package/boot/uboot-mediatek/patches/210-cmd-bootmenu-add-ability-to-select-item-by-shortkey.patch
 create mode 100644 package/boot/uboot-mediatek/patches/211-cmd-bootmenu-custom-title.patch
 create mode 100644 package/boot/uboot-mediatek/patches/220-cmd-env-readmem.patch
 create mode 100644 package/boot/uboot-mediatek/patches/230-cmd-add-pstore-check.patch
 create mode 100644 package/boot/uboot-mediatek/patches/260-add-missing-type-u64.patch
 create mode 100644 package/boot/uboot-mediatek/patches/300-mt7622-generic-reset-button-ignore-env.patch
 create mode 100644 package/boot/uboot-mediatek/patches/350-add-support-for-Winbond-W25Q512JV.patch
 create mode 100644 package/boot/uboot-mediatek/patches/400-update-bpir2-defconfig.patch
 rename package/boot/uboot-mediatek/patches/{010-update-u7623-defconfig.patch => 401-update-u7623-defconfig.patch} (72%)
 create mode 100644 package/boot/uboot-mediatek/patches/402-update-bananapi-bpi-r64-device-tree.patch
 create mode 100644 package/boot/uboot-mediatek/patches/403-add-bananapi_bpi-r64-snand.patch
 create mode 100644 package/boot/uboot-mediatek/patches/404-add-bananapi_bpi-r64_defconfigs.patch
 create mode 100644 package/boot/uboot-mediatek/patches/405-dts-mt7623n-bpi-r2-fix-leds.patch
 create mode 100644 package/boot/uboot-mediatek/patches/410-add-linksys-e8450.patch
 create mode 100644 package/boot/uboot-mediatek/patches/412-add-ubnt-unifi-6-lr.patch
 create mode 100644 target/linux/generic/files/block/partitions/fit.c
 create mode 100644 target/linux/generic/hack-5.4/400-block-fit-partition-parser.patch
 delete mode 100644 target/linux/mediatek/files-5.4/arch/arm64/boot/dts/mediatek/mt7622-bananapi-bpi-r64-rootdisk.dts
 delete mode 100644 target/linux/mediatek/files-5.4/arch/arm64/boot/dts/mediatek/mt7622-elecom-wrc-2533gent.dts
 delete mode 100644 target/linux/mediatek/files-5.4/arch/arm64/boot/dts/mediatek/mt7622-rfb1-ubi.dts
 delete mode 100644 target/linux/mediatek/files-5.4/arch/arm64/boot/dts/mediatek/mt7622-ubnt-unifi-6-lr.dts
 create mode 100755 target/linux/mediatek/mt7622/base-files-old/etc/board.d/02_network
 rename target/linux/mediatek/mt7622/{base-files => base-files-old}/lib/preinit/79_move_config (100%)
 create mode 100755 target/linux/mediatek/mt7622/base-files-old/lib/upgrade/platform.sh
 create mode 100644 target/linux/mediatek/mt7622/base-files/etc/board.d/01_leds
 mode change 100755 => 100644 target/linux/mediatek/mt7622/base-files/etc/board.d/02_network
 create mode 100755 target/linux/mediatek/mt7622/base-files/etc/init.d/bootcount
 create mode 100644 target/linux/mediatek/mt7622/base-files/etc/uci-defaults/09_fix_crc
 create mode 100644 target/linux/mediatek/mt7622/base-files/lib/upgrade/buffalo.sh
 create mode 100644 target/linux/mediatek/patches-5.4/900-dts-mt7622-bpi-r64-aliases-for-dtoverlay.patch
 delete mode 100644 tools/firmware-utils/src/zytrx.c
 create mode 100644 tools/mkimage/patches/080-mtk_image-add-support-for-booting-ARM64-images.patch
 create mode 100644 tools/mkimage/patches/081-mtk_image-add-an-option-to-set-device-header-offset.patch

diff --git a/include/image-commands.mk b/include/image-commands.mk
index 4d54a14ba4..3b9de035bd 100644
--- a/include/image-commands.mk
+++ b/include/image-commands.mk
@@ -27,6 +27,21 @@ define Build/append-kernel
 	dd if=$(IMAGE_KERNEL) >> $@
 endef
 
+define Build/append-image
+	dd if=$(BIN_DIR)/$(IMAGE_PREFIX)-$(1) >> $@
+endef
+
+ifdef IB
+define Build/append-image-stage
+	dd if=$(STAGING_DIR_IMAGE)/$(BOARD)$(if $(SUBTARGET),-$(SUBTARGET))-$(DEVICE_NAME)-$(1) >> $@
+endef
+else
+define Build/append-image-stage
+	dd if=$(BIN_DIR)/$(IMAGE_PREFIX)-$(1) of=$(STAGING_DIR_IMAGE)/$(BOARD)$(if $(SUBTARGET),-$(SUBTARGET))-$(DEVICE_NAME)-$(1)
+	dd if=$(BIN_DIR)/$(IMAGE_PREFIX)-$(1) >> $@
+endef
+endif
+
 compat_version=$(if $(DEVICE_COMPAT_VERSION),$(DEVICE_COMPAT_VERSION),1.0)
 json_quote=$(subst ','\'',$(subst ",\",$(1)))
 #")')
@@ -196,15 +211,31 @@ define Build/eva-image
 	mv $@.new $@
 endef
 
+define Build/initrd_compression
+	$(if $(CONFIG_TARGET_INITRAMFS_COMPRESSION_BZIP2),.bzip2) \
+	$(if $(CONFIG_TARGET_INITRAMFS_COMPRESSION_GZIP),.gzip) \
+	$(if $(CONFIG_TARGET_INITRAMFS_COMPRESSION_LZMA),.lzma) \
+	$(if $(CONFIG_TARGET_INITRAMFS_COMPRESSION_XZ),.xz) \
+	$(if $(CONFIG_TARGET_INITRAMFS_COMPRESSION_ZSTD),.zstd)
+endef
+
 define Build/fit
 	$(TOPDIR)/scripts/mkits.sh \
 		-D $(DEVICE_NAME) -o $@.its -k $@ \
-		$(if $(word 2,$(1)),-d $(word 2,$(1))) -C $(word 1,$(1)) \
+		-C $(word 1,$(1)) $(if $(word 2,$(1)),\
+		$(if $(DEVICE_DTS_OVERLAY),-d $(KERNEL_BUILD_DIR)/image-$$(basename $(word 2,$(1))),\
+			-d $(word 2,$(1)))) \
+		$(if $(findstring with-rootfs,$(word 3,$(1))),-r $(IMAGE_ROOTFS)) \
+		$(if $(findstring with-initrd,$(word 3,$(1))), \
+			$(if $(CONFIG_TARGET_ROOTFS_INITRAMFS_SEPARATE), \
+				-i $(KERNEL_BUILD_DIR)/initrd.cpio$(strip $(call Build/initrd_compression)))) \
 		-a $(KERNEL_LOADADDR) -e $(if $(KERNEL_ENTRY),$(KERNEL_ENTRY),$(KERNEL_LOADADDR)) \
 		$(if $(DEVICE_FDT_NUM),-n $(DEVICE_FDT_NUM)) \
-		-c $(if $(DEVICE_DTS_CONFIG),$(DEVICE_DTS_CONFIG),"config@1") \
+		$(if $(DEVICE_DTS_OVERLAY),$(foreach dtso,$(DEVICE_DTS_OVERLAY), -O $(dtso):$(KERNEL_BUILD_DIR)/image-$(dtso).dtb)) \
+		-c $(if $(DEVICE_DTS_CONFIG),$(DEVICE_DTS_CONFIG),"config-1") \
 		-A $(LINUX_KARCH) -v $(LINUX_VERSION)
-	PATH=$(LINUX_DIR)/scripts/dtc:$(PATH) mkimage -f $@.its $@.new
+	PATH=$(LINUX_DIR)/scripts/dtc:$(PATH) mkimage $(if $(findstring external,$(word 3,$(1))),\
+		-E -B 0x1000 $(if $(findstring static,$(word 3,$(1))),-p 0x1000)) -f $@.its $@.new
 	@mv $@.new $@
 endef
 
diff --git a/include/image.mk b/include/image.mk
index b6e8ab3c84..985b20bc4b 100644
--- a/include/image.mk
+++ b/include/image.mk
@@ -190,6 +190,7 @@ define Image/BuildDTB
 		-o $(2).tmp $(1)
 	$(LINUX_DIR)/scripts/dtc/dtc -O dtb \
 		-i$(dir $(1)) $(DTC_FLAGS) $(4) \
+    $(if $(CONFIG_HAS_DT_OVERLAY_SUPPORT),-@) \
 		-o $(2) $(2).tmp
 	$(RM) $(2).tmp
 endef
@@ -393,6 +394,7 @@ define Device/Init
   DEVICE_DTS :=
   DEVICE_DTS_CONFIG :=
   DEVICE_DTS_DIR :=
+  DEVICE_DTS_OVERLAY :=
   DEVICE_FDT_NUM :=
   SOC :=
 
@@ -416,8 +418,8 @@ DEFAULT_DEVICE_VARS := \
   DEVICE_NAME KERNEL KERNEL_INITRAMFS KERNEL_INITRAMFS_IMAGE KERNEL_SIZE \
   CMDLINE UBOOTENV_IN_UBI KERNEL_IN_UBI BLOCKSIZE PAGESIZE SUBPAGESIZE \
   VID_HDR_OFFSET UBINIZE_OPTS UBINIZE_PARTS MKUBIFS_OPTS DEVICE_DTS \
-  DEVICE_DTS_CONFIG DEVICE_DTS_DIR DEVICE_FDT_NUM SOC BOARD_NAME \
-  UIMAGE_MAGIC UIMAGE_NAME \
+  DEVICE_DTS_CONFIG DEVICE_DTS_DIR DEVICE_DTS_OVERLAY DEVICE_FDT_NUM \
+  SOC BOARD_NAME UIMAGE_MAGIC UIMAGE_NAME \
   SUPPORTED_DEVICES IMAGE_METADATA KERNEL_ENTRY KERNEL_LOADADDR \
   IMAGE_PREFIX DEVICE_PACKAGES UBOOT_PATH IMAGE_SIZE \
   DEVICE_COMPAT_VERSION DEVICE_COMPAT_MESSAGE \
@@ -539,7 +541,7 @@ endef
 endif
 
 define Device/Build/kernel
-  $$(eval $$(foreach dts,$$(DEVICE_DTS), \
+  $$(eval $$(foreach dts,$$(DEVICE_DTS) $$(DEVICE_DTS_OVERLAY), \
 	$$(call Device/Build/dtb,$$(notdir $$(dts)), \
 		$$(if $$(DEVICE_DTS_DIR),$$(DEVICE_DTS_DIR),$$(DTS_DIR)), \
 		$$(dts) \
diff --git a/package/base-files/files/lib/upgrade/nand.sh b/package/base-files/files/lib/upgrade/nand.sh
index e6f58df4f5..f52d1e76fd 100644
--- a/package/base-files/files/lib/upgrade/nand.sh
+++ b/package/base-files/files/lib/upgrade/nand.sh
@@ -3,13 +3,13 @@
 
 . /lib/functions.sh
 
-# 'kernel' partition on NAND contains the kernel
+# 'kernel' partition or UBI volume on NAND contains the kernel
 CI_KERNPART="${CI_KERNPART:-kernel}"
 
 # 'ubi' partition on NAND contains UBI
 CI_UBIPART="${CI_UBIPART:-ubi}"
 
-# 'rootfs' partition on NAND contains the rootfs
+# 'rootfs' UBI volume on NAND contains the rootfs
 CI_ROOTPART="${CI_ROOTPART:-rootfs}"
 
 ubi_mknod() {
@@ -117,9 +117,11 @@ nand_restore_config() {
 nand_upgrade_prepare_ubi() {
 	local rootfs_length="$1"
 	local rootfs_type="$2"
-	local has_kernel="${3:-0}"
+	local kernel_length="$3"
 	local has_env="${4:-0}"
 
+	[ -n "$rootfs_length" -o -n "$kernel_length" ] || return 1
+
 	local mtdnum="$( find_mtd_index "$CI_UBIPART" )"
 	if [ ! "$mtdnum" ]; then
 		echo "cannot find ubi mtd partition $CI_UBIPART"
@@ -148,23 +150,24 @@ nand_upgrade_prepare_ubi() {
 	local root_ubivol="$( nand_find_volume $ubidev $CI_ROOTPART )"
 	local data_ubivol="$( nand_find_volume $ubidev rootfs_data )"
 
-	# remove ubiblock device of rootfs
-	local root_ubiblk="ubiblock${root_ubivol:3}"
-	if [ "$root_ubivol" -a -e "/dev/$root_ubiblk" ]; then
-		echo "removing $root_ubiblk"
-		if ! ubiblock -r /dev/$root_ubivol; then
-			echo "cannot remove $root_ubiblk"
-			return 1;
+	local ubiblk ubiblkvol
+	for ubiblk in /dev/ubiblock*_? ; do
+		[ -e "$ubiblk" ] || continue
+		echo "removing ubiblock${ubiblk:13}"
+		ubiblkvol=ubi${ubiblk:13}
+		if ! ubiblock -r /dev/$ubiblkvol; then
+			echo "cannot remove $ubiblk"
+			return 1
 		fi
-	fi
+	done
 
 	# kill volumes
 	[ "$kern_ubivol" ] && ubirmvol /dev/$ubidev -N $CI_KERNPART || true
-	[ "$root_ubivol" ] && ubirmvol /dev/$ubidev -N $CI_ROOTPART || true
+	[ "$root_ubivol" -a "$root_ubivol" != "$kern_ubivol" ] && ubirmvol /dev/$ubidev -N $CI_ROOTPART || true
 	[ "$data_ubivol" ] && ubirmvol /dev/$ubidev -N rootfs_data || true
 
 	# update kernel
-	if [ "$has_kernel" = "1" ]; then
+	if [ -n "$kernel_length" ]; then
 		if ! ubimkvol /dev/$ubidev -N $CI_KERNPART -s $kernel_length; then
 			echo "cannot create kernel volume"
 			return 1;
@@ -172,15 +175,17 @@ nand_upgrade_prepare_ubi() {
 	fi
 
 	# update rootfs
-	local root_size_param
-	if [ "$rootfs_type" = "ubifs" ]; then
-		root_size_param="-m"
-	else
-		root_size_param="-s $rootfs_length"
-	fi
-	if ! ubimkvol /dev/$ubidev -N $CI_ROOTPART $root_size_param; then
-		echo "cannot create rootfs volume"
-		return 1;
+	if [ -n "$rootfs_length" ]; then
+		local root_size_param
+		if [ "$rootfs_type" = "ubifs" ]; then
+			root_size_param="-m"
+		else
+			root_size_param="-s $rootfs_length"
+		fi
+		if ! ubimkvol /dev/$ubidev -N $CI_ROOTPART $rootfs_size_param; then
+			echo "cannot create rootfs volume"
+			return 1;
+		fi
 	fi
 
 	# create rootfs_data for non-ubifs rootfs
@@ -232,7 +237,7 @@ nand_upgrade_ubinized() {
 nand_upgrade_ubifs() {
 	local rootfs_length=$( (cat $1 | wc -c) 2> /dev/null)
 
-	nand_upgrade_prepare_ubi "$rootfs_length" "ubifs" "0" "0"
+	nand_upgrade_prepare_ubi "$rootfs_length" "ubifs" "" ""
 
 	local ubidev="$( nand_find_ubi "$CI_UBIPART" )"
 	local root_ubivol="$(nand_find_volume $ubidev $CI_ROOTPART)"
@@ -241,39 +246,59 @@ nand_upgrade_ubifs() {
 	nand_do_upgrade_success
 }
 
+nand_upgrade_fit() {
+	local fit_file="$1"
+	local fit_length="$(wc -c < "$fit_file")"
+
+	nand_upgrade_prepare_ubi "" "" "$fit_length" "1"
+
+	local fit_ubidev="$(nand_find_ubi "$CI_UBIPART")"
+	local fit_ubivol="$(nand_find_volume $fit_ubidev "$CI_KERNPART")"
+	ubiupdatevol /dev/$fit_ubivol -s $fit_length $fit_file
+
+	nand_do_upgrade_success
+}
+
 nand_upgrade_tar() {
 	local tar_file="$1"
 	local kernel_mtd="$(find_mtd_index $CI_KERNPART)"
 
-	local board_dir=$(tar tf $tar_file | grep -m 1 '^sysupgrade-.*/$')
+	local board_dir=$(tar tf "$tar_file" | grep -m 1 '^sysupgrade-.*/$')
 	board_dir=${board_dir%/}
 
-	local kernel_length=$( (tar xf $tar_file ${board_dir}/kernel -O | wc -c) 2> /dev/null)
-	local rootfs_length=$( (tar xf $tar_file ${board_dir}/root -O | wc -c) 2> /dev/null)
+	kernel_length=$( (tar xf "$tar_file" ${board_dir}/kernel -O | wc -c) 2> /dev/null)
+	local has_rootfs=0
+	local rootfs_length
+	local rootfs_type
 
-	local rootfs_type="$(identify_tar "$tar_file" ${board_dir}/root)"
+	tar tf "$tar_file" ${board_dir}/root 1>/dev/null 2>/dev/null && has_rootfs=1
+	[ "$has_rootfs" = "1" ] && {
+		rootfs_length=$( (tar xf "$tar_file" ${board_dir}/root -O | wc -c) 2> /dev/null)
+		rootfs_type="$(identify_tar "$tar_file" ${board_dir}/root)"
+	}
 
 	local has_kernel=1
 	local has_env=0
 
 	[ "$kernel_length" != 0 -a -n "$kernel_mtd" ] && {
-		tar xf $tar_file ${board_dir}/kernel -O | mtd write - $CI_KERNPART
+		tar xf "$tar_file" ${board_dir}/kernel -O | mtd write - $CI_KERNPART
 	}
-	[ "$kernel_length" = 0 -o ! -z "$kernel_mtd" ] && has_kernel=0
+	[ "$kernel_length" = 0 -o ! -z "$kernel_mtd" ] && has_kernel=
 
-	nand_upgrade_prepare_ubi "$rootfs_length" "$rootfs_type" "$has_kernel" "$has_env"
+	nand_upgrade_prepare_ubi "$rootfs_length" "$rootfs_type" "${has_kernel:+$kernel_length}" "$has_env"
 
 	local ubidev="$( nand_find_ubi "$CI_UBIPART" )"
 	[ "$has_kernel" = "1" ] && {
-		local kern_ubivol="$(nand_find_volume $ubidev $CI_KERNPART)"
-		tar xf $tar_file ${board_dir}/kernel -O | \
+		local kern_ubivol="$( nand_find_volume $ubidev $CI_KERNPART )"
+		tar xf "$tar_file" ${board_dir}/kernel -O | \
 			ubiupdatevol /dev/$kern_ubivol -s $kernel_length -
 	}
 
-	local root_ubivol="$(nand_find_volume $ubidev $CI_ROOTPART)"
-	tar xf $tar_file ${board_dir}/root -O | \
-		ubiupdatevol /dev/$root_ubivol -s $rootfs_length -
-
+	[ "$has_rootfs" = "1" ] && {
+		local root_ubivol="$( nand_find_volume $ubidev $CI_ROOTPART )"
+		tar xf "$tar_file" ${board_dir}/root -O | \
+			ubiupdatevol /dev/$root_ubivol -s $rootfs_length -
+	}
 	nand_do_upgrade_success
 }
 
@@ -284,6 +309,7 @@ nand_do_upgrade() {
 	[ ! "$(find_mtd_index "$CI_UBIPART")" ] && CI_UBIPART="rootfs"
 
 	case "$file_type" in
+		"fit")		nand_upgrade_fit $1;;
 		"ubi")		nand_upgrade_ubinized $1;;
 		"ubifs")	nand_upgrade_ubifs $1;;
 		*)		nand_upgrade_tar $1;;
@@ -309,10 +335,10 @@ nand_do_platform_check() {
 	local control_length=$( (tar xf $tar_file sysupgrade-$board_name/CONTROL -O | wc -c) 2> /dev/null)
 	local file_type="$(identify $2)"
 
-	[ "$control_length" = 0 -a "$file_type" != "ubi" -a "$file_type" != "ubifs" ] && {
+	[ "$control_length" = 0 -a "$file_type" != "ubi" -a "$file_type" != "ubifs" -a "$file_type" != "fit" ] && {
 		echo "Invalid sysupgrade file."
 		return 1
 	}
 
 	return 0
-}
+}
\ No newline at end of file
diff --git a/package/boot/arm-trusted-firmware-mediatek/Makefile b/package/boot/arm-trusted-firmware-mediatek/Makefile
index 98d421ed87..4cf9bec7e9 100644
--- a/package/boot/arm-trusted-firmware-mediatek/Makefile
+++ b/package/boot/arm-trusted-firmware-mediatek/Makefile
@@ -13,149 +13,92 @@ PKG_RELEASE:=$(AUTORELEASE)
 
 PKG_SOURCE_PROTO:=git
 PKG_SOURCE_URL=https://github.com/mtk-openwrt/arm-trusted-firmware.git
-PKG_SOURCE_DATE:=2020-11-09
-PKG_SOURCE_VERSION:=03017334ccd8c0fac12e7db36749b95b9a7d745f
-PKG_MIRROR_HASH:=b211b2f9143d4debc7ad8dc959cb606888af20af790855dd66c87e451b6a1bc7
+PKG_SOURCE_DATE:=2021-05-08
+PKG_SOURCE_VERSION:=d2c75b2139be003887af9cc5a94da5e9bdc59de7
+PKG_MIRROR_HASH:=4af9ce8e11511afee7f588cc982946c06339edbfa47afef6a7f3e2231ac9f34d
 
 PKG_MAINTAINER:=Daniel Golle <daniel@makrotopia.org>
 
-PKG_LICENSE_FILES:=LICENCE.mediatek
-
-BLOBS_TARBALL:=tfa-mtk-files-for-2020-11-09.tgz
-BROMIMAGE_EXEC:=bromimage-x64
-
 include $(INCLUDE_DIR)/trusted-firmware-a.mk
 include $(INCLUDE_DIR)/package.mk
 
-PKG_LICENSE+=proprietary
-
-define Download/tfa-files
-  URL:=@OPENWRT
-  URL_FILE:=$(BLOBS_TARBALL)
-  FILE:=$(BLOBS_TARBALL)
-  HASH:=689b097e4531d3eeca0c477675ab3dc3cace6ba4ed8a339116a9ede6537839d7
-endef
-
-define Download/mt7622-header-emmc
-  URL:=https://raw.githubusercontent.com/frank-w/BPI-R64-ATF/a36efa5f7435b8079479d13b562fedc0aa0d42f0
-  URL_FILE:=header_emmc.bin
-  FILE:=mt7622-header_emmc.bin
-  HASH:=0a09c55d90c5fc375c59468a4331555f77cbc3e1dd107ca83b5b8c9625f38d8c
-endef
-
-define Download/mt7622-header-sdmmc
-  URL:=https://raw.githubusercontent.com/frank-w/BPI-R64-ATF/a36efa5f7435b8079479d13b562fedc0aa0d42f0
-  URL_FILE:=header_sdmmc.bin
-  FILE:=mt7622-header_sdmmc.bin
-  HASH:=242908c04e25289d25ba9fab61a1930425af173051c43d275d1ac9877d6accb1
-endef
-
 define Trusted-Firmware-A/Default
   BUILD_TARGET:=mediatek
   BUILD_SUBTARGET:=mt7622
   PLAT:=mt7622
   TFA_IMAGE:=bl2.img bl31.bin
   BOOT_DEVICE:=
-  DDR_BLOB:=
+  DDR3_FLYBY:=
 endef
 
 define Trusted-Firmware-A/mt7622-nor-1ddr
   NAME:=MediaTek MT7622 (SPI-NOR, 1x DDR3)
   BOOT_DEVICE:=nor
-  DDR_BLOB:=1
 endef
 
 define Trusted-Firmware-A/mt7622-nor-2ddr
   NAME:=MediaTek MT7622 (SPI-NOR, 2x DDR3)
   BOOT_DEVICE:=nor
-  DDR_BLOB:=2
+  DDR3_FLYBY:=1
 endef
 
 define Trusted-Firmware-A/mt7622-snand-1ddr
   NAME:=MediaTek MT7622 (SPI-NAND, 1x DDR3)
   BOOT_DEVICE:=snand
-  DDR_BLOB:=1
 endef
 
 define Trusted-Firmware-A/mt7622-snand-2ddr
-  NAME:=MediaTek MT7622 (SPI-SNAND, 2x DDR3)
+  NAME:=MediaTek MT7622 (SPI-NAND, 2x DDR3)
   BOOT_DEVICE:=snand
-  DDR_BLOB:=2
+  DDR3_FLYBY:=1
 endef
 
 define Trusted-Firmware-A/mt7622-emmc-1ddr
   NAME:=MediaTek MT7622 (eMMC, 1x DDR3)
   BOOT_DEVICE:=emmc
-  DDR_BLOB:=1
 endef
 
 define Trusted-Firmware-A/mt7622-emmc-2ddr
   NAME:=MediaTek MT7622 (eMMC, 2x DDR3)
   BOOT_DEVICE:=emmc
-  DDR_BLOB:=2
+  DDR3_FLYBY:=1
 endef
 
 define Trusted-Firmware-A/mt7622-sdmmc-1ddr
   NAME:=MediaTek MT7622 (SDcard, 1x DDR3)
   BOOT_DEVICE:=sdmmc
-  DDR_BLOB:=1
 endef
 
 define Trusted-Firmware-A/mt7622-sdmmc-2ddr
   NAME:=MediaTek MT7622 (SDcard, 2x DDR3)
   BOOT_DEVICE:=sdmmc
-  DDR_BLOB:=2
+  DDR3_FLYBY:=1
 endef
 
 TFA_TARGETS:= \
-        mt7622-nor-1ddr \
-        mt7622-nor-2ddr \
-        mt7622-snand-1ddr \
-        mt7622-snand-2ddr \
-        mt7622-emmc-1ddr \
-        mt7622-emmc-2ddr \
-        mt7622-sdmmc-1ddr \
-        mt7622-sdmmc-2ddr
-
-TFA_MAKE_FLAGS += BOOT_DEVICE=$(BOOT_DEVICE) all
-
-define Build/Prepare
-	$(call Build/Prepare/Default)
-ifeq ($(BOOT_DEVICE),emmc)
-	$(eval $(call Download,mt7622-header-emmc))
-endif
-ifeq ($(BOOT_DEVICE),sdmmc)
-	$(eval $(call Download,mt7622-header-sdmmc))
-endif
-	$(eval $(call Download,tfa-files))
-# replace 'bromimage' tool by static version
-	$(TAR) -vxzf $(DL_DIR)/$(BLOBS_TARBALL) --wildcards \
-		-O "*/$(BROMIMAGE_EXEC)" > $(PKG_BUILD_DIR)/tools/mediatek/bromimage/bromimage
-	$(TAR) -vxzf $(DL_DIR)/$(BLOBS_TARBALL) --wildcards \
-		-C $(PKG_BUILD_DIR) \
-		--strip-components=1 */LICENCE.mediatek
-endef
+	mt7622-nor-1ddr \
+	mt7622-nor-2ddr \
+	mt7622-snand-1ddr \
+	mt7622-snand-2ddr \
+	mt7622-emmc-1ddr \
+	mt7622-emmc-2ddr \
+	mt7622-sdmmc-1ddr \
+	mt7622-sdmmc-2ddr
+
+TFA_MAKE_FLAGS += \
+	BOOT_DEVICE=$(BOOT_DEVICE) \
+	USE_MKIMAGE=1 MKIMAGE=$(STAGING_DIR_HOST)/bin/mkimage \
+	$(if $(DDR3_FLYBY),DDR3_FLYBY=1) \
+	all
 
 define Build/Configure
 	$(call Build/Configure/Default)
-# replace DRAM calib blobs if needed (variant '2' is shipped upstream)
-ifeq ($(DDR_BLOB),1)
-	$(TAR) -vxzf $(DL_DIR)/$(BLOBS_TARBALL) --wildcards \
-		-C $(PKG_BUILD_DIR)/plat/mediatek/mt7622/drivers/dram/release \
-		--strip-components=1 */*.o
-endif
 endef
 
 define Package/trusted-firmware-a/install
 	$(INSTALL_DIR) $(STAGING_DIR_IMAGE)
 	$(INSTALL_DATA) $(PKG_BUILD_DIR)/build/mt7622/release/bl2.img $(STAGING_DIR_IMAGE)/$(BUILD_VARIANT)-bl2.img
 	$(INSTALL_DATA) $(PKG_BUILD_DIR)/build/mt7622/release/bl31.bin $(STAGING_DIR_IMAGE)/$(BUILD_VARIANT)-bl31.bin
-ifeq ($(BOOT_DEVICE),emmc)
-	$(INSTALL_DATA) $(DL_DIR)/mt7622-header_emmc.bin $(STAGING_DIR_IMAGE)/
-endif
-ifeq ($(BOOT_DEVICE),sdmmc)
-	$(INSTALL_DATA) $(DL_DIR)/mt7622-header_sdmmc.bin $(STAGING_DIR_IMAGE)/
-endif
 endef
 
 $(eval $(call BuildPackage/Trusted-Firmware-A))
diff --git a/package/boot/arm-trusted-firmware-mediatek/patches/100-increase-nor-bl3-size.patch b/package/boot/arm-trusted-firmware-mediatek/patches/100-increase-nor-bl3-size.patch
new file mode 100644
index 0000000000..8de3cd77f6
--- /dev/null
+++ b/package/boot/arm-trusted-firmware-mediatek/patches/100-increase-nor-bl3-size.patch
@@ -0,0 +1,11 @@
+--- a/plat/mediatek/mt7622/bl2_boot_nor.c
++++ b/plat/mediatek/mt7622/bl2_boot_nor.c
+@@ -12,7 +12,7 @@
+ #define MT7622_NOR_MAP_BASE		0x30000000
+ 
+ #define FIP_BASE			0x20000
+-#define FIP_SIZE			0x80000
++#define FIP_SIZE			0xa0000
+ 
+ const io_block_spec_t mtk_boot_dev_fip_spec = {
+ 	.offset	= MT7622_NOR_MAP_BASE + FIP_BASE,
diff --git a/package/boot/uboot-mediatek/Makefile b/package/boot/uboot-mediatek/Makefile
index c46b906cb5..5d9459d461 100644
--- a/package/boot/uboot-mediatek/Makefile
+++ b/package/boot/uboot-mediatek/Makefile
@@ -1,8 +1,9 @@
 include $(TOPDIR)/rules.mk
 include $(INCLUDE_DIR)/kernel.mk
 
-PKG_VERSION:=2020.10
-PKG_HASH:=0d481bbdc05c0ee74908ec2f56a6daa53166cc6a78a0e4fac2ac5d025770a622
+PKG_VERSION:=2021.10
+PKG_HASH:=cde723e19262e646f2670d25e5ec4b1b368490de950d4e26275a988c36df0bd4
+PKG_BUILD_DEPENDS:=arm-trusted-firmware-tools/host
 
 include $(INCLUDE_DIR)/u-boot.mk
 include $(INCLUDE_DIR)/package.mk
@@ -11,43 +12,131 @@ include $(INCLUDE_DIR)/host-build.mk
 define U-Boot/Default
   BUILD_TARGET:=mediatek
   UBOOT_IMAGE:=u-boot-mtk.bin
-  DEFAULT:=y
 endef
 
-define U-Boot/mt7622
-  NAME:=MT7622
-  BUILD_SUBTARGET:=mt7622
+define U-Boot/mt7622_rfb1
+  NAME:=MT7622 Reference Board 1
   UBOOT_CONFIG:=mt7622_rfb
+  BUILD_DEVICES:=mediatek_mt7622-rfb1 mediatek_mt7622-rfb1-ubi
+  BUILD_SUBTARGET:=mt7622
+endef
+
+define U-Boot/mt7622_linksys_e8450
+  NAME:=Linksys E8450
+  UBOOT_CONFIG:=mt7622_linksys_e8450
+  BUILD_DEVICES:=linksys_e8450-ubi
+  BUILD_SUBTARGET:=mt7622
+  UBOOT_IMAGE:=u-boot.fip
+  BL2_BOOTDEV:=snand
+  BL2_DDRBLOB:=1
+  DEPENDS:=+trusted-firmware-a-mt7622-snand-1ddr
+endef
+
+define U-Boot/mt7622_bananapi_bpi-r64-emmc
+  NAME:=BananaPi R64 (eMMC)
+  UBOOT_CONFIG:=mt7622_bananapi_bpi-r64-emmc
+  BUILD_DEVICES:=bananapi_bpi-r64
+  BUILD_SUBTARGET:=mt7622
+  UBOOT_IMAGE:=u-boot.fip
+  BL2_BOOTDEV:=emmc
+  BL2_DDRBLOB:=2
+  DEPENDS:=+trusted-firmware-a-mt7622-emmc-2ddr
+endef
+
+define U-Boot/mt7622_bananapi_bpi-r64-sdmmc
+  NAME:=BananaPi R64 (SDMMC)
+  UBOOT_CONFIG:=mt7622_bananapi_bpi-r64-sdmmc
+  BUILD_DEVICES:=bananapi_bpi-r64
+  BUILD_SUBTARGET:=mt7622
+  UBOOT_IMAGE:=u-boot.fip
+  BL2_BOOTDEV:=sdmmc
+  BL2_DDRBLOB:=2
+  DEPENDS:=+trusted-firmware-a-mt7622-sdmmc-2ddr
+endef
+
+define U-Boot/mt7622_bananapi_bpi-r64-snand
+  NAME:=BananaPi R64 (SNAND)
+  UBOOT_CONFIG:=mt7622_bananapi_bpi-r64-snand
+  BUILD_DEVICES:=bananapi_bpi-r64
+  BUILD_SUBTARGET:=mt7622
+  UBOOT_IMAGE:=u-boot.fip
+  BL2_BOOTDEV:=snand
+  BL2_DDRBLOB:=2
+  DEPENDS:=+trusted-firmware-a-mt7622-snand-2ddr
+endef
+
+define U-Boot/mt7622_ubnt_unifi-6-lr
+  NAME:=Ubiquiti UniFi 6 LR
+  UBOOT_CONFIG:=mt7622_ubnt_unifi-6-lr
+  BUILD_DEVICES:=ubnt_unifi-6-lr-ubootmod
+  BUILD_SUBTARGET:=mt7622
+  UBOOT_IMAGE:=u-boot.fip
+  BL2_BOOTDEV:=nor
+  BL2_DDRBLOB:=2
+  DEPENDS:=+trusted-firmware-a-mt7622-nor-2ddr
 endef
 
 define U-Boot/mt7623a_unielec_u7623
   NAME:=UniElec U7623 (mt7623)
+  BUILD_DEVICES:=unielec_u7623-emmc unielec_u7623-02-emmc-512m-legacy
   BUILD_SUBTARGET:=mt7623
   UBOOT_CONFIG:=mt7623a_unielec_u7623_02
 endef
 
 define U-Boot/mt7623n_bpir2
   NAME:=Banana Pi R2 (mt7623)
+  BUILD_DEVICES:=bananapi_bpi-r2
   BUILD_SUBTARGET:=mt7623
   UBOOT_IMAGE:=u-boot.bin
   UBOOT_CONFIG:=mt7623n_bpir2
 endef
 
-define U-Boot/mt7629
-  NAME:=MT7629
+define U-Boot/mt7629_rfb
+  NAME:=MT7629 Reference Board
   BUILD_SUBTARGET:=mt7629
+  BUILD_DEVICES:=mediatek_mt7629-rfb
   UBOOT_CONFIG:=mt7629_rfb
 endef
 
-UBOOT_TARGETS := mt7629 mt7622 mt7623n_bpir2 mt7623a_unielec_u7623
+UBOOT_TARGETS := \
+	mt7622_bananapi_bpi-r64-emmc \
+	mt7622_bananapi_bpi-r64-sdmmc \
+	mt7622_bananapi_bpi-r64-snand \
+	mt7622_linksys_e8450 \
+	mt7622_rfb1 \
+	mt7622_ubnt_unifi-6-lr \
+	mt7623n_bpir2 \
+	mt7623a_unielec_u7623 \
+	mt7629_rfb
+
+UBOOT_MAKE_FLAGS += $(UBOOT_IMAGE:.fip=.bin)
+
+define Build/fip-image
+	$(STAGING_DIR_HOST)/bin/fiptool create \
+		--soc-fw $(STAGING_DIR_IMAGE)/$(BUILD_SUBTARGET)-$(BL2_BOOTDEV)-$(BL2_DDRBLOB)ddr-bl31.bin \
+		--nt-fw $(PKG_BUILD_DIR)/u-boot.bin \
+		$(PKG_BUILD_DIR)/u-boot.fip
+endef
+
+define Build/Configure
+	$(call Build/Configure/U-Boot)
+	sed -i 's/CONFIG_TOOLS_LIBCRYPTO=y/# CONFIG_TOOLS_LIBCRYPTO is not set/' $(PKG_BUILD_DIR)/.config
+endef
 
-UBOOT_MAKE_FLAGS += $(UBOOT_IMAGE)
+define Build/Compile
+	$(call Build/Compile/U-Boot)
+ifeq ($(UBOOT_IMAGE),u-boot.fip))
+	$(call Build/fip-image)
+endif
+endef
 
-Build/Exports:=$(Host/Exports)
+# don't stage files to bindir, let target/linux/mediatek/image/*.mk do that
+define Package/u-boot/install
+endef
 
 define Build/InstallDev
 	$(INSTALL_DIR) $(STAGING_DIR_IMAGE)
-	$(INSTALL_BIN) $(PKG_BUILD_DIR)/$(UBOOT_IMAGE) $(STAGING_DIR_IMAGE)/$(BUILD_VARIANT)-$(UBOOT_IMAGE)
+	$(INSTALL_DATA) $(PKG_BUILD_DIR)/$(UBOOT_IMAGE) $(STAGING_DIR_IMAGE)/$(BUILD_VARIANT)-$(UBOOT_IMAGE)
 endef
 
 $(eval $(call BuildPackage/U-Boot))
diff --git a/package/boot/uboot-mediatek/patches/000-mtk-01-Revert-clk-Add-debugging-for-return-values.patch b/package/boot/uboot-mediatek/patches/000-mtk-01-Revert-clk-Add-debugging-for-return-values.patch
new file mode 100644
index 0000000000..30558611c8
--- /dev/null
+++ b/package/boot/uboot-mediatek/patches/000-mtk-01-Revert-clk-Add-debugging-for-return-values.patch
@@ -0,0 +1,69 @@
+From 34ed9f6d3018d32c7c015e57c9985d3c4c07b706 Mon Sep 17 00:00:00 2001
+From: Daniel Golle <daniel@makrotopia.org>
+Date: Thu, 11 Mar 2021 10:28:53 +0000
+Subject: [PATCH 01/12] Revert "clk: Add debugging for return values"
+
+This reverts commit 5c5992cb90cf9ca4d51e38d9a95a13c293904df5.
+---
+ drivers/clk/clk-uclass.c | 16 +++++-----------
+ 1 file changed, 5 insertions(+), 11 deletions(-)
+
+--- a/drivers/clk/clk-uclass.c
++++ b/drivers/clk/clk-uclass.c
+@@ -87,7 +87,7 @@ static int clk_get_by_index_tail(int ret
+ 	if (ret) {
+ 		debug("%s: uclass_get_device_by_of_offset failed: err=%d\n",
+ 		      __func__, ret);
+-		return log_msg_ret("get", ret);
++		return ret;
+ 	}
+ 
+ 	clk->dev = dev_clk;
+@@ -100,15 +100,14 @@ static int clk_get_by_index_tail(int ret
+ 		ret = clk_of_xlate_default(clk, args);
+ 	if (ret) {
+ 		debug("of_xlate() failed: %d\n", ret);
+-		return log_msg_ret("xlate", ret);
++		return ret;
+ 	}
+ 
+ 	return clk_request(dev_clk, clk);
+ err:
+ 	debug("%s: Node '%s', property '%s', failed to request CLK index %d: %d\n",
+ 	      __func__, ofnode_get_name(node), list_name, index, ret);
+-
+-	return log_msg_ret("prop", ret);
++	return ret;
+ }
+ 
+ static int clk_get_by_indexed_prop(struct udevice *dev, const char *prop_name,
+@@ -127,7 +126,7 @@ static int clk_get_by_indexed_prop(struc
+ 	if (ret) {
+ 		debug("%s: fdtdec_parse_phandle_with_args failed: err=%d\n",
+ 		      __func__, ret);
+-		return log_ret(ret);
++		return ret;
+ 	}
+ 
+ 
+@@ -502,7 +501,6 @@ int clk_free(struct clk *clk)
+ ulong clk_get_rate(struct clk *clk)
+ {
+ 	const struct clk_ops *ops;
+-	int ret;
+ 
+ 	debug("%s(clk=%p)\n", __func__, clk);
+ 	if (!clk_valid(clk))
+@@ -512,11 +510,7 @@ ulong clk_get_rate(struct clk *clk)
+ 	if (!ops->get_rate)
+ 		return -ENOSYS;
+ 
+-	ret = ops->get_rate(clk);
+-	if (ret)
+-		return log_ret(ret);
+-
+-	return 0;
++	return ops->get_rate(clk);
+ }
+ 
+ struct clk *clk_get_parent(struct clk *clk)
diff --git a/package/boot/uboot-mediatek/patches/000-mtk-09-board-mediatek-add-more-network-configurations.patch b/package/boot/uboot-mediatek/patches/000-mtk-09-board-mediatek-add-more-network-configurations.patch
new file mode 100644
index 0000000000..d189735754
--- /dev/null
+++ b/package/boot/uboot-mediatek/patches/000-mtk-09-board-mediatek-add-more-network-configurations.patch
@@ -0,0 +1,44 @@
+From 938ba7ed996a86c9cc7af08b69df57b8b4c09510 Mon Sep 17 00:00:00 2001
+From: Weijie Gao <weijie.gao@mediatek.com>
+Date: Tue, 2 Mar 2021 15:47:45 +0800
+Subject: [PATCH 02/12] board: mediatek: add more network configurations
+
+Make the network configurations uniform for mediatek boards
+
+Signed-off-by: Weijie Gao <weijie.gao@mediatek.com>
+---
+ include/configs/mt7622.h | 3 ++-
+ include/configs/mt7623.h | 1 +
+ include/configs/mt7629.h | 1 +
+ 3 files changed, 4 insertions(+), 1 deletion(-)
+
+--- a/include/configs/mt7622.h
++++ b/include/configs/mt7622.h
+@@ -36,6 +36,7 @@
+ 
+ /* Ethernet */
+ #define CONFIG_IPADDR			192.168.1.1
+-#define CONFIG_SERVERIP			192.168.1.3
++#define CONFIG_SERVERIP			192.168.1.2
++#define CONFIG_NETMASK			255.255.255.0
+ 
+ #endif
+--- a/include/configs/mt7623.h
++++ b/include/configs/mt7623.h
+@@ -54,6 +54,7 @@
+ /* Ethernet */
+ #define CONFIG_IPADDR			192.168.1.1
+ #define CONFIG_SERVERIP			192.168.1.2
++#define CONFIG_NETMASK			255.255.255.0
+ 
+ #ifdef CONFIG_DISTRO_DEFAULTS
+ 
+--- a/include/configs/mt7629.h
++++ b/include/configs/mt7629.h
+@@ -52,5 +52,6 @@
+ /* Ethernet */
+ #define CONFIG_IPADDR			192.168.1.1
+ #define CONFIG_SERVERIP			192.168.1.2
++#define CONFIG_NETMASK			255.255.255.0
+ 
+ #endif
diff --git a/package/boot/uboot-mediatek/patches/000-mtk-10-mmc-mtk-sd-increase-the-minimum-bus-frequency.patch b/package/boot/uboot-mediatek/patches/000-mtk-10-mmc-mtk-sd-increase-the-minimum-bus-frequency.patch
new file mode 100644
index 0000000000..8f14a98ff1
--- /dev/null
+++ b/package/boot/uboot-mediatek/patches/000-mtk-10-mmc-mtk-sd-increase-the-minimum-bus-frequency.patch
@@ -0,0 +1,28 @@
+From 1d4fcea788e579934a1ad0a90cecd6e1761127d1 Mon Sep 17 00:00:00 2001
+From: Weijie Gao <weijie.gao@mediatek.com>
+Date: Tue, 2 Mar 2021 15:56:17 +0800
+Subject: [PATCH 03/12] mmc: mtk-sd: increase the minimum bus frequency
+
+With a 48MHz input clock, the lowest bus frequency can be as low as
+48000000 / (4 * 4095) = 2930Hz. Such an extremely low frequency will cause
+the mmc framework take seconds to finish the initialization.
+
+Limiting the minimum bus frequency to a slightly higher value can solve the
+issue without any side effects.
+
+Signed-off-by: Weijie Gao <weijie.gao@mediatek.com>
+---
+ drivers/mmc/mtk-sd.c | 2 +-
+ 1 file changed, 1 insertion(+), 1 deletion(-)
+
+--- a/drivers/mmc/mtk-sd.c
++++ b/drivers/mmc/mtk-sd.c
+@@ -232,7 +232,7 @@
+ 
+ #define SCLK_CYCLES_SHIFT		20
+ 
+-#define MIN_BUS_CLK			200000
++#define MIN_BUS_CLK			260000
+ 
+ #define CMD_INTS_MASK	\
+ 	(MSDC_INT_CMDRDY | MSDC_INT_RSPCRCERR | MSDC_INT_CMDTMO)
diff --git a/package/boot/uboot-mediatek/patches/000-mtk-14-drivers-mtd-add-support-for-MediaTek-SPI-NAND-flash-.patch b/package/boot/uboot-mediatek/patches/000-mtk-14-drivers-mtd-add-support-for-MediaTek-SPI-NAND-flash-.patch
new file mode 100644
index 0000000000..d743035813
--- /dev/null
+++ b/package/boot/uboot-mediatek/patches/000-mtk-14-drivers-mtd-add-support-for-MediaTek-SPI-NAND-flash-.patch
@@ -0,0 +1,3698 @@
+From d6c5309185aae3d9ecf80eae8b248522d11a6136 Mon Sep 17 00:00:00 2001
+From: Weijie Gao <weijie.gao@mediatek.com>
+Date: Tue, 2 Mar 2021 16:58:01 +0800
+Subject: [PATCH 04/12] drivers: mtd: add support for MediaTek SPI-NAND flash
+ controller
+
+Add mtd driver for MediaTek SPI-NAND flash controller
+
+This driver is written from scratch, and uses standard mtd framework, not
+the nand framework which only applies for raw parallel nand flashes so that
+this driver can have a smaller size in binary.
+
+Signed-off-by: Weijie Gao <weijie.gao@mediatek.com>
+---
+ drivers/mtd/Kconfig                   |    2 +
+ drivers/mtd/Makefile                  |    2 +
+ drivers/mtd/mtk-snand/Kconfig         |   21 +
+ drivers/mtd/mtk-snand/Makefile        |   11 +
+ drivers/mtd/mtk-snand/mtk-snand-def.h |  266 ++++
+ drivers/mtd/mtk-snand/mtk-snand-ecc.c |  264 ++++
+ drivers/mtd/mtk-snand/mtk-snand-ids.c |  511 +++++++
+ drivers/mtd/mtk-snand/mtk-snand-mtd.c |  526 ++++++++
+ drivers/mtd/mtk-snand/mtk-snand-os.c  |   39 +
+ drivers/mtd/mtk-snand/mtk-snand-os.h  |  120 ++
+ drivers/mtd/mtk-snand/mtk-snand.c     | 1776 +++++++++++++++++++++++++
+ drivers/mtd/mtk-snand/mtk-snand.h     |   77 ++
+ 12 files changed, 3615 insertions(+)
+ create mode 100644 drivers/mtd/mtk-snand/Kconfig
+ create mode 100644 drivers/mtd/mtk-snand/Makefile
+ create mode 100644 drivers/mtd/mtk-snand/mtk-snand-def.h
+ create mode 100644 drivers/mtd/mtk-snand/mtk-snand-ecc.c
+ create mode 100644 drivers/mtd/mtk-snand/mtk-snand-ids.c
+ create mode 100644 drivers/mtd/mtk-snand/mtk-snand-mtd.c
+ create mode 100644 drivers/mtd/mtk-snand/mtk-snand-os.c
+ create mode 100644 drivers/mtd/mtk-snand/mtk-snand-os.h
+ create mode 100644 drivers/mtd/mtk-snand/mtk-snand.c
+ create mode 100644 drivers/mtd/mtk-snand/mtk-snand.h
+
+--- a/drivers/mtd/Kconfig
++++ b/drivers/mtd/Kconfig
+@@ -109,6 +109,8 @@ config HBMC_AM654
+ 	 This is the driver for HyperBus controller on TI's AM65x and
+ 	 other SoCs
+ 
++source "drivers/mtd/mtk-snand/Kconfig"
++
+ source "drivers/mtd/nand/Kconfig"
+ 
+ source "drivers/mtd/spi/Kconfig"
+--- a/drivers/mtd/Makefile
++++ b/drivers/mtd/Makefile
+@@ -39,3 +39,5 @@ obj-$(CONFIG_$(SPL_TPL_)SPI_FLASH_SUPPOR
+ obj-$(CONFIG_SPL_UBI) += ubispl/
+ 
+ endif
++
++obj-$(CONFIG_MTK_SPI_NAND) += mtk-snand/
+--- /dev/null
++++ b/drivers/mtd/mtk-snand/Kconfig
+@@ -0,0 +1,21 @@
++#
++# Copyright (C) 2020 MediaTek Inc. All rights reserved.
++# Author: Weijie Gao <weijie.gao@mediatek.com>
++#
++# SPDX-License-Identifier: GPL-2.0
++#
++
++config MTK_SPI_NAND
++	tristate "MediaTek SPI NAND flash controller driver"
++	depends on !MTD_SPI_NAND
++	help
++	  This option enables access to SPI-NAND flashes through the
++	  MediaTek SPI NAND Flash Controller
++
++config MTK_SPI_NAND_MTD
++	tristate "MTD support for MediaTek SPI NAND flash controller"
++	depends on DM_MTD
++	depends on MTK_SPI_NAND
++	help
++	  This option enables access to SPI-NAND flashes through the
++	  MTD interface of MediaTek SPI NAND Flash Controller
+--- /dev/null
++++ b/drivers/mtd/mtk-snand/Makefile
+@@ -0,0 +1,11 @@
++#
++# Copyright (C) 2020 MediaTek Inc. All rights reserved.
++# Author: Weijie Gao <weijie.gao@mediatek.com>
++#
++# SPDX-License-Identifier: GPL-2.0
++#
++
++obj-y += mtk-snand.o mtk-snand-ecc.o mtk-snand-ids.o mtk-snand-os.o
++obj-$(CONFIG_MTK_SPI_NAND_MTD) += mtk-snand-mtd.o
++
++ccflags-y += -DPRIVATE_MTK_SNAND_HEADER
+--- /dev/null
++++ b/drivers/mtd/mtk-snand/mtk-snand-def.h
+@@ -0,0 +1,266 @@
++/* SPDX-License-Identifier: GPL-2.0 OR BSD-3-Clause */
++/*
++ * Copyright (C) 2020 MediaTek Inc. All Rights Reserved.
++ *
++ * Author: Weijie Gao <weijie.gao@mediatek.com>
++ */
++
++#ifndef _MTK_SNAND_DEF_H_
++#define _MTK_SNAND_DEF_H_
++
++#include "mtk-snand-os.h"
++
++#ifdef PRIVATE_MTK_SNAND_HEADER
++#include "mtk-snand.h"
++#else
++#include <mtk-snand.h>
++#endif
++
++struct mtk_snand_plat_dev;
++
++enum snand_flash_io {
++	SNAND_IO_1_1_1,
++	SNAND_IO_1_1_2,
++	SNAND_IO_1_2_2,
++	SNAND_IO_1_1_4,
++	SNAND_IO_1_4_4,
++
++	__SNAND_IO_MAX
++};
++
++#define SPI_IO_1_1_1			BIT(SNAND_IO_1_1_1)
++#define SPI_IO_1_1_2			BIT(SNAND_IO_1_1_2)
++#define SPI_IO_1_2_2			BIT(SNAND_IO_1_2_2)
++#define SPI_IO_1_1_4			BIT(SNAND_IO_1_1_4)
++#define SPI_IO_1_4_4			BIT(SNAND_IO_1_4_4)
++
++struct snand_opcode {
++	uint8_t opcode;
++	uint8_t dummy;
++};
++
++struct snand_io_cap {
++	uint8_t caps;
++	struct snand_opcode opcodes[__SNAND_IO_MAX];
++};
++
++#define SNAND_OP(_io, _opcode, _dummy) [_io] = { .opcode = (_opcode), \
++						 .dummy = (_dummy) }
++
++#define SNAND_IO_CAP(_name, _caps, ...) \
++	struct snand_io_cap _name = { .caps = (_caps), \
++				      .opcodes = { __VA_ARGS__ } }
++
++#define SNAND_MAX_ID_LEN		4
++
++enum snand_id_type {
++	SNAND_ID_DYMMY,
++	SNAND_ID_ADDR = SNAND_ID_DYMMY,
++	SNAND_ID_DIRECT,
++
++	__SNAND_ID_TYPE_MAX
++};
++
++struct snand_id {
++	uint8_t type;	/* enum snand_id_type */
++	uint8_t len;
++	uint8_t id[SNAND_MAX_ID_LEN];
++};
++
++#define SNAND_ID(_type, ...) \
++	{ .type = (_type), .id = { __VA_ARGS__ }, \
++	  .len = sizeof((uint8_t[]) { __VA_ARGS__ }) }
++
++struct snand_mem_org {
++	uint16_t pagesize;
++	uint16_t sparesize;
++	uint16_t pages_per_block;
++	uint16_t blocks_per_die;
++	uint16_t planes_per_die;
++	uint16_t ndies;
++};
++
++#define SNAND_MEMORG(_ps, _ss, _ppb, _bpd, _ppd, _nd) \
++	{ .pagesize = (_ps), .sparesize = (_ss), .pages_per_block = (_ppb), \
++	  .blocks_per_die = (_bpd), .planes_per_die = (_ppd), .ndies = (_nd) }
++
++typedef int (*snand_select_die_t)(struct mtk_snand *snf, uint32_t dieidx);
++
++struct snand_flash_info {
++	const char *model;
++	struct snand_id id;
++	const struct snand_mem_org memorg;
++	const struct snand_io_cap *cap_rd;
++	const struct snand_io_cap *cap_pl;
++	snand_select_die_t select_die;
++};
++
++#define SNAND_INFO(_model, _id, _memorg, _cap_rd, _cap_pl, ...) \
++	{ .model = (_model), .id = _id, .memorg = _memorg, \
++	  .cap_rd = (_cap_rd), .cap_pl = (_cap_pl), __VA_ARGS__ }
++
++const struct snand_flash_info *snand_flash_id_lookup(enum snand_id_type type,
++						     const uint8_t *id);
++
++struct mtk_snand_soc_data {
++	uint16_t sector_size;
++	uint16_t max_sectors;
++	uint16_t fdm_size;
++	uint16_t fdm_ecc_size;
++	uint16_t fifo_size;
++
++	bool bbm_swap;
++	bool empty_page_check;
++	uint32_t mastersta_mask;
++
++	const uint8_t *spare_sizes;
++	uint32_t num_spare_size;
++};
++
++enum mtk_ecc_regs {
++	ECC_DECDONE,
++};
++
++struct mtk_ecc_soc_data {
++	const uint8_t *ecc_caps;
++	uint32_t num_ecc_cap;
++	const uint32_t *regs;
++	uint16_t mode_shift;
++	uint8_t errnum_bits;
++	uint8_t errnum_shift;
++};
++
++struct mtk_snand {
++	struct mtk_snand_plat_dev *pdev;
++
++	void __iomem *nfi_base;
++	void __iomem *ecc_base;
++
++	enum mtk_snand_soc soc;
++	const struct mtk_snand_soc_data *nfi_soc;
++	const struct mtk_ecc_soc_data *ecc_soc;
++	bool snfi_quad_spi;
++	bool quad_spi_op;
++
++	const char *model;
++	uint64_t size;
++	uint64_t die_size;
++	uint32_t erasesize;
++	uint32_t writesize;
++	uint32_t oobsize;
++
++	uint32_t num_dies;
++	snand_select_die_t select_die;
++
++	uint8_t opcode_rfc;
++	uint8_t opcode_pl;
++	uint8_t dummy_rfc;
++	uint8_t mode_rfc;
++	uint8_t mode_pl;
++
++	uint32_t writesize_mask;
++	uint32_t writesize_shift;
++	uint32_t erasesize_mask;
++	uint32_t erasesize_shift;
++	uint64_t die_mask;
++	uint32_t die_shift;
++
++	uint32_t spare_per_sector;
++	uint32_t raw_sector_size;
++	uint32_t ecc_strength;
++	uint32_t ecc_steps;
++	uint32_t ecc_bytes;
++	uint32_t ecc_parity_bits;
++
++	uint8_t *page_cache;	/* Used by read/write page */
++	uint8_t *buf_cache;	/* Used by block bad/markbad & auto_oob */
++};
++
++enum mtk_snand_log_category {
++	SNAND_LOG_NFI,
++	SNAND_LOG_SNFI,
++	SNAND_LOG_ECC,
++	SNAND_LOG_CHIP,
++
++	__SNAND_LOG_CAT_MAX
++};
++
++int mtk_ecc_setup(struct mtk_snand *snf, void *fmdaddr, uint32_t max_ecc_bytes,
++		  uint32_t msg_size);
++int mtk_snand_ecc_encoder_start(struct mtk_snand *snf);
++void mtk_snand_ecc_encoder_stop(struct mtk_snand *snf);
++int mtk_snand_ecc_decoder_start(struct mtk_snand *snf);
++void mtk_snand_ecc_decoder_stop(struct mtk_snand *snf);
++int mtk_ecc_wait_decoder_done(struct mtk_snand *snf);
++int mtk_ecc_check_decode_error(struct mtk_snand *snf, uint32_t page);
++
++int mtk_snand_mac_io(struct mtk_snand *snf, const uint8_t *out, uint32_t outlen,
++		     uint8_t *in, uint32_t inlen);
++int mtk_snand_set_feature(struct mtk_snand *snf, uint32_t addr, uint32_t val);
++
++int mtk_snand_log(struct mtk_snand_plat_dev *pdev,
++		  enum mtk_snand_log_category cat, const char *fmt, ...);
++
++#define snand_log_nfi(pdev, fmt, ...) \
++	mtk_snand_log(pdev, SNAND_LOG_NFI, fmt, ##__VA_ARGS__)
++
++#define snand_log_snfi(pdev, fmt, ...) \
++	mtk_snand_log(pdev, SNAND_LOG_SNFI, fmt, ##__VA_ARGS__)
++
++#define snand_log_ecc(pdev, fmt, ...) \
++	mtk_snand_log(pdev, SNAND_LOG_ECC, fmt, ##__VA_ARGS__)
++
++#define snand_log_chip(pdev, fmt, ...) \
++	mtk_snand_log(pdev, SNAND_LOG_CHIP, fmt, ##__VA_ARGS__)
++
++/* ffs64 */
++static inline int mtk_snand_ffs64(uint64_t x)
++{
++	if (!x)
++		return 0;
++
++	if (!(x & 0xffffffff))
++		return ffs((uint32_t)(x >> 32)) + 32;
++
++	return ffs((uint32_t)(x & 0xffffffff));
++}
++
++/* NFI dummy commands */
++#define NFI_CMD_DUMMY_READ		0x00
++#define NFI_CMD_DUMMY_WRITE		0x80
++
++/* SPI-NAND opcodes */
++#define SNAND_CMD_RESET			0xff
++#define SNAND_CMD_BLOCK_ERASE		0xd8
++#define SNAND_CMD_READ_FROM_CACHE_QUAD	0xeb
++#define SNAND_CMD_WINBOND_SELECT_DIE	0xc2
++#define SNAND_CMD_READ_FROM_CACHE_DUAL	0xbb
++#define SNAND_CMD_READID		0x9f
++#define SNAND_CMD_READ_FROM_CACHE_X4	0x6b
++#define SNAND_CMD_READ_FROM_CACHE_X2	0x3b
++#define SNAND_CMD_PROGRAM_LOAD_X4	0x32
++#define SNAND_CMD_SET_FEATURE		0x1f
++#define SNAND_CMD_READ_TO_CACHE		0x13
++#define SNAND_CMD_PROGRAM_EXECUTE	0x10
++#define SNAND_CMD_GET_FEATURE		0x0f
++#define SNAND_CMD_READ_FROM_CACHE	0x0b
++#define SNAND_CMD_WRITE_ENABLE		0x06
++#define SNAND_CMD_PROGRAM_LOAD		0x02
++
++/* SPI-NAND feature addresses */
++#define SNAND_FEATURE_MICRON_DIE_ADDR	0xd0
++#define SNAND_MICRON_DIE_SEL_1		BIT(6)
++
++#define SNAND_FEATURE_STATUS_ADDR	0xc0
++#define SNAND_STATUS_OIP		BIT(0)
++#define SNAND_STATUS_WEL		BIT(1)
++#define SNAND_STATUS_ERASE_FAIL		BIT(2)
++#define SNAND_STATUS_PROGRAM_FAIL	BIT(3)
++
++#define SNAND_FEATURE_CONFIG_ADDR	0xb0
++#define SNAND_FEATURE_QUAD_ENABLE	BIT(0)
++#define SNAND_FEATURE_ECC_EN		BIT(4)
++
++#define SNAND_FEATURE_PROTECT_ADDR	0xa0
++
++#endif /* _MTK_SNAND_DEF_H_ */
+--- /dev/null
++++ b/drivers/mtd/mtk-snand/mtk-snand-ecc.c
+@@ -0,0 +1,264 @@
++// SPDX-License-Identifier: GPL-2.0 OR BSD-3-Clause
++/*
++ * Copyright (C) 2020 MediaTek Inc. All Rights Reserved.
++ *
++ * Author: Weijie Gao <weijie.gao@mediatek.com>
++ */
++
++#include "mtk-snand-def.h"
++
++/* ECC registers */
++#define ECC_ENCCON			0x000
++#define ENC_EN				BIT(0)
++
++#define ECC_ENCCNFG			0x004
++#define ENC_MS_S			16
++#define ENC_BURST_EN			BIT(8)
++#define ENC_TNUM_S			0
++
++#define ECC_ENCIDLE			0x00c
++#define ENC_IDLE			BIT(0)
++
++#define ECC_DECCON			0x100
++#define DEC_EN				BIT(0)
++
++#define ECC_DECCNFG			0x104
++#define DEC_EMPTY_EN			BIT(31)
++#define DEC_CS_S			16
++#define DEC_CON_S			12
++#define   DEC_CON_CORRECT		3
++#define DEC_BURST_EN			BIT(8)
++#define DEC_TNUM_S			0
++
++#define ECC_DECIDLE			0x10c
++#define DEC_IDLE			BIT(0)
++
++#define ECC_DECENUM0			0x114
++#define ECC_DECENUM(n)			(ECC_DECENUM0 + (n) * 4)
++
++/* ECC_ENCIDLE & ECC_DECIDLE */
++#define ECC_IDLE			BIT(0)
++
++/* ENC_MODE & DEC_MODE */
++#define ECC_MODE_NFI			1
++
++#define ECC_TIMEOUT			500000
++
++static const uint8_t mt7622_ecc_caps[] = { 4, 6, 8, 10, 12 };
++
++static const uint8_t mt7986_ecc_caps[] = {
++	4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24
++};
++
++static const uint32_t mt7622_ecc_regs[] = {
++	[ECC_DECDONE] = 0x11c,
++};
++
++static const uint32_t mt7986_ecc_regs[] = {
++	[ECC_DECDONE] = 0x124,
++};
++
++static const struct mtk_ecc_soc_data mtk_ecc_socs[__SNAND_SOC_MAX] = {
++	[SNAND_SOC_MT7622] = {
++		.ecc_caps = mt7622_ecc_caps,
++		.num_ecc_cap = ARRAY_SIZE(mt7622_ecc_caps),
++		.regs = mt7622_ecc_regs,
++		.mode_shift = 4,
++		.errnum_bits = 5,
++		.errnum_shift = 5,
++	},
++	[SNAND_SOC_MT7629] = {
++		.ecc_caps = mt7622_ecc_caps,
++		.num_ecc_cap = ARRAY_SIZE(mt7622_ecc_caps),
++		.regs = mt7622_ecc_regs,
++		.mode_shift = 4,
++		.errnum_bits = 5,
++		.errnum_shift = 5,
++	},
++	[SNAND_SOC_MT7986] = {
++		.ecc_caps = mt7986_ecc_caps,
++		.num_ecc_cap = ARRAY_SIZE(mt7986_ecc_caps),
++		.regs = mt7986_ecc_regs,
++		.mode_shift = 5,
++		.errnum_bits = 5,
++		.errnum_shift = 8,
++	},
++};
++
++static inline uint32_t ecc_read32(struct mtk_snand *snf, uint32_t reg)
++{
++	return readl(snf->ecc_base + reg);
++}
++
++static inline void ecc_write32(struct mtk_snand *snf, uint32_t reg,
++			       uint32_t val)
++{
++	writel(val, snf->ecc_base + reg);
++}
++
++static inline void ecc_write16(struct mtk_snand *snf, uint32_t reg,
++			       uint16_t val)
++{
++	writew(val, snf->ecc_base + reg);
++}
++
++static int mtk_ecc_poll(struct mtk_snand *snf, uint32_t reg, uint32_t bits)
++{
++	uint32_t val;
++
++	return read16_poll_timeout(snf->ecc_base + reg, val, (val & bits), 0,
++				   ECC_TIMEOUT);
++}
++
++static int mtk_ecc_wait_idle(struct mtk_snand *snf, uint32_t reg)
++{
++	int ret;
++
++	ret = mtk_ecc_poll(snf, reg, ECC_IDLE);
++	if (ret) {
++		snand_log_ecc(snf->pdev, "ECC engine is busy\n");
++		return -EBUSY;
++	}
++
++	return 0;
++}
++
++int mtk_ecc_setup(struct mtk_snand *snf, void *fmdaddr, uint32_t max_ecc_bytes,
++		  uint32_t msg_size)
++{
++	uint32_t i, val, ecc_msg_bits, ecc_strength;
++	int ret;
++
++	snf->ecc_soc = &mtk_ecc_socs[snf->soc];
++
++	snf->ecc_parity_bits = fls(1 + 8 * msg_size);
++	ecc_strength = max_ecc_bytes * 8 / snf->ecc_parity_bits;
++
++	for (i = snf->ecc_soc->num_ecc_cap - 1; i >= 0; i--) {
++		if (snf->ecc_soc->ecc_caps[i] <= ecc_strength)
++			break;
++	}
++
++	if (unlikely(i < 0)) {
++		snand_log_ecc(snf->pdev, "Page size %u+%u is not supported\n",
++			      snf->writesize, snf->oobsize);
++		return -ENOTSUPP;
++	}
++
++	snf->ecc_strength = snf->ecc_soc->ecc_caps[i];
++	snf->ecc_bytes = DIV_ROUND_UP(snf->ecc_strength * snf->ecc_parity_bits,
++				      8);
++
++	/* Encoder config */
++	ecc_write16(snf, ECC_ENCCON, 0);
++	ret = mtk_ecc_wait_idle(snf, ECC_ENCIDLE);
++	if (ret)
++		return ret;
++
++	ecc_msg_bits = msg_size * 8;
++	val = (ecc_msg_bits << ENC_MS_S) |
++	      (ECC_MODE_NFI << snf->ecc_soc->mode_shift) | i;
++	ecc_write32(snf, ECC_ENCCNFG, val);
++
++	/* Decoder config */
++	ecc_write16(snf, ECC_DECCON, 0);
++	ret = mtk_ecc_wait_idle(snf, ECC_DECIDLE);
++	if (ret)
++		return ret;
++
++	ecc_msg_bits += snf->ecc_strength * snf->ecc_parity_bits;
++	val = DEC_EMPTY_EN | (ecc_msg_bits << DEC_CS_S) |
++	      (DEC_CON_CORRECT << DEC_CON_S) |
++	      (ECC_MODE_NFI << snf->ecc_soc->mode_shift) | i;
++	ecc_write32(snf, ECC_DECCNFG, val);
++
++	return 0;
++}
++
++int mtk_snand_ecc_encoder_start(struct mtk_snand *snf)
++{
++	int ret;
++
++	ret = mtk_ecc_wait_idle(snf, ECC_ENCIDLE);
++	if (ret) {
++		ecc_write16(snf, ECC_ENCCON, 0);
++		mtk_ecc_wait_idle(snf, ECC_ENCIDLE);
++	}
++
++	ecc_write16(snf, ECC_ENCCON, ENC_EN);
++
++	return 0;
++}
++
++void mtk_snand_ecc_encoder_stop(struct mtk_snand *snf)
++{
++	mtk_ecc_wait_idle(snf, ECC_ENCIDLE);
++	ecc_write16(snf, ECC_ENCCON, 0);
++}
++
++int mtk_snand_ecc_decoder_start(struct mtk_snand *snf)
++{
++	int ret;
++
++	ret = mtk_ecc_wait_idle(snf, ECC_DECIDLE);
++	if (ret) {
++		ecc_write16(snf, ECC_DECCON, 0);
++		mtk_ecc_wait_idle(snf, ECC_DECIDLE);
++	}
++
++	ecc_write16(snf, ECC_DECCON, DEC_EN);
++
++	return 0;
++}
++
++void mtk_snand_ecc_decoder_stop(struct mtk_snand *snf)
++{
++	mtk_ecc_wait_idle(snf, ECC_DECIDLE);
++	ecc_write16(snf, ECC_DECCON, 0);
++}
++
++int mtk_ecc_wait_decoder_done(struct mtk_snand *snf)
++{
++	uint16_t val, step_mask = (1 << snf->ecc_steps) - 1;
++	uint32_t reg = snf->ecc_soc->regs[ECC_DECDONE];
++	int ret;
++
++	ret = read16_poll_timeout(snf->ecc_base + reg, val,
++				  (val & step_mask) == step_mask, 0,
++				  ECC_TIMEOUT);
++	if (ret)
++		snand_log_ecc(snf->pdev, "ECC decoder is busy\n");
++
++	return ret;
++}
++
++int mtk_ecc_check_decode_error(struct mtk_snand *snf, uint32_t page)
++{
++	uint32_t i, regi, fi, errnum;
++	uint32_t errnum_shift = snf->ecc_soc->errnum_shift;
++	uint32_t errnum_mask = (1 << snf->ecc_soc->errnum_bits) - 1;
++	int ret = 0;
++
++	for (i = 0; i < snf->ecc_steps; i++) {
++		regi = i / 4;
++		fi = i % 4;
++
++		errnum = ecc_read32(snf, ECC_DECENUM(regi));
++		errnum = (errnum >> (fi * errnum_shift)) & errnum_mask;
++		if (!errnum)
++			continue;
++
++		if (errnum <= snf->ecc_strength) {
++			if (ret >= 0)
++				ret += errnum;
++			continue;
++		}
++
++		snand_log_ecc(snf->pdev,
++			      "Uncorrectable bitflips in page %u sect %u\n",
++			      page, i);
++		ret = -EBADMSG;
++	}
++
++	return ret;
++}
+--- /dev/null
++++ b/drivers/mtd/mtk-snand/mtk-snand-ids.c
+@@ -0,0 +1,511 @@
++// SPDX-License-Identifier: GPL-2.0 OR BSD-3-Clause
++/*
++ * Copyright (C) 2020 MediaTek Inc. All Rights Reserved.
++ *
++ * Author: Weijie Gao <weijie.gao@mediatek.com>
++ */
++
++#include "mtk-snand-def.h"
++
++static int mtk_snand_winbond_select_die(struct mtk_snand *snf, uint32_t dieidx);
++static int mtk_snand_micron_select_die(struct mtk_snand *snf, uint32_t dieidx);
++
++#define SNAND_MEMORG_512M_2K_64		SNAND_MEMORG(2048, 64, 64, 512, 1, 1)
++#define SNAND_MEMORG_1G_2K_64		SNAND_MEMORG(2048, 64, 64, 1024, 1, 1)
++#define SNAND_MEMORG_2G_2K_64		SNAND_MEMORG(2048, 64, 64, 2048, 1, 1)
++#define SNAND_MEMORG_2G_2K_120		SNAND_MEMORG(2048, 120, 64, 2048, 1, 1)
++#define SNAND_MEMORG_4G_2K_64		SNAND_MEMORG(2048, 64, 64, 4096, 1, 1)
++#define SNAND_MEMORG_1G_2K_120		SNAND_MEMORG(2048, 120, 64, 1024, 1, 1)
++#define SNAND_MEMORG_1G_2K_128		SNAND_MEMORG(2048, 128, 64, 1024, 1, 1)
++#define SNAND_MEMORG_2G_2K_128		SNAND_MEMORG(2048, 128, 64, 2048, 1, 1)
++#define SNAND_MEMORG_4G_2K_128		SNAND_MEMORG(2048, 128, 64, 4096, 1, 1)
++#define SNAND_MEMORG_4G_4K_240		SNAND_MEMORG(4096, 240, 64, 2048, 1, 1)
++#define SNAND_MEMORG_4G_4K_256		SNAND_MEMORG(4096, 256, 64, 2048, 1, 1)
++#define SNAND_MEMORG_8G_4K_256		SNAND_MEMORG(4096, 256, 64, 4096, 1, 1)
++#define SNAND_MEMORG_2G_2K_64_2P	SNAND_MEMORG(2048, 64, 64, 2048, 2, 1)
++#define SNAND_MEMORG_2G_2K_64_2D	SNAND_MEMORG(2048, 64, 64, 1024, 1, 2)
++#define SNAND_MEMORG_2G_2K_128_2P	SNAND_MEMORG(2048, 128, 64, 2048, 2, 1)
++#define SNAND_MEMORG_4G_2K_64_2P	SNAND_MEMORG(2048, 64, 64, 4096, 2, 1)
++#define SNAND_MEMORG_4G_2K_128_2P_2D	SNAND_MEMORG(2048, 128, 64, 2048, 2, 2)
++#define SNAND_MEMORG_8G_4K_256_2D	SNAND_MEMORG(4096, 256, 64, 2048, 1, 2)
++
++static const SNAND_IO_CAP(snand_cap_read_from_cache_quad,
++	SPI_IO_1_1_1 | SPI_IO_1_1_2 | SPI_IO_1_2_2 | SPI_IO_1_1_4 |
++	SPI_IO_1_4_4,
++	SNAND_OP(SNAND_IO_1_1_1, SNAND_CMD_READ_FROM_CACHE, 8),
++	SNAND_OP(SNAND_IO_1_1_2, SNAND_CMD_READ_FROM_CACHE_X2, 8),
++	SNAND_OP(SNAND_IO_1_2_2, SNAND_CMD_READ_FROM_CACHE_DUAL, 4),
++	SNAND_OP(SNAND_IO_1_1_4, SNAND_CMD_READ_FROM_CACHE_X4, 8),
++	SNAND_OP(SNAND_IO_1_4_4, SNAND_CMD_READ_FROM_CACHE_QUAD, 4));
++
++static const SNAND_IO_CAP(snand_cap_read_from_cache_quad_q2d,
++	SPI_IO_1_1_1 | SPI_IO_1_1_2 | SPI_IO_1_2_2 | SPI_IO_1_1_4 |
++	SPI_IO_1_4_4,
++	SNAND_OP(SNAND_IO_1_1_1, SNAND_CMD_READ_FROM_CACHE, 8),
++	SNAND_OP(SNAND_IO_1_1_2, SNAND_CMD_READ_FROM_CACHE_X2, 8),
++	SNAND_OP(SNAND_IO_1_2_2, SNAND_CMD_READ_FROM_CACHE_DUAL, 4),
++	SNAND_OP(SNAND_IO_1_1_4, SNAND_CMD_READ_FROM_CACHE_X4, 8),
++	SNAND_OP(SNAND_IO_1_4_4, SNAND_CMD_READ_FROM_CACHE_QUAD, 2));
++
++static const SNAND_IO_CAP(snand_cap_read_from_cache_quad_a8d,
++	SPI_IO_1_1_1 | SPI_IO_1_1_2 | SPI_IO_1_2_2 | SPI_IO_1_1_4 |
++	SPI_IO_1_4_4,
++	SNAND_OP(SNAND_IO_1_1_1, SNAND_CMD_READ_FROM_CACHE, 8),
++	SNAND_OP(SNAND_IO_1_1_2, SNAND_CMD_READ_FROM_CACHE_X2, 8),
++	SNAND_OP(SNAND_IO_1_2_2, SNAND_CMD_READ_FROM_CACHE_DUAL, 8),
++	SNAND_OP(SNAND_IO_1_1_4, SNAND_CMD_READ_FROM_CACHE_X4, 8),
++	SNAND_OP(SNAND_IO_1_4_4, SNAND_CMD_READ_FROM_CACHE_QUAD, 8));
++
++static const SNAND_IO_CAP(snand_cap_read_from_cache_x4,
++	SPI_IO_1_1_1 | SPI_IO_1_1_2 | SPI_IO_1_1_4,
++	SNAND_OP(SNAND_IO_1_1_1, SNAND_CMD_READ_FROM_CACHE, 8),
++	SNAND_OP(SNAND_IO_1_1_2, SNAND_CMD_READ_FROM_CACHE_X2, 8),
++	SNAND_OP(SNAND_IO_1_1_4, SNAND_CMD_READ_FROM_CACHE_X4, 8));
++
++static const SNAND_IO_CAP(snand_cap_read_from_cache_x4_only,
++	SPI_IO_1_1_1 | SPI_IO_1_1_4,
++	SNAND_OP(SNAND_IO_1_1_1, SNAND_CMD_READ_FROM_CACHE, 8),
++	SNAND_OP(SNAND_IO_1_1_4, SNAND_CMD_READ_FROM_CACHE_X4, 8));
++
++static const SNAND_IO_CAP(snand_cap_program_load_x1,
++	SPI_IO_1_1_1,
++	SNAND_OP(SNAND_IO_1_1_1, SNAND_CMD_PROGRAM_LOAD, 0));
++
++static const SNAND_IO_CAP(snand_cap_program_load_x4,
++	SPI_IO_1_1_1 | SPI_IO_1_1_4,
++	SNAND_OP(SNAND_IO_1_1_1, SNAND_CMD_PROGRAM_LOAD, 0),
++	SNAND_OP(SNAND_IO_1_1_4, SNAND_CMD_PROGRAM_LOAD_X4, 0));
++
++static const struct snand_flash_info snand_flash_ids[] = {
++	SNAND_INFO("W25N512GV", SNAND_ID(SNAND_ID_DYMMY, 0xef, 0xaa, 0x20),
++		   SNAND_MEMORG_512M_2K_64,
++		   &snand_cap_read_from_cache_quad,
++		   &snand_cap_program_load_x4),
++	SNAND_INFO("W25N01GV", SNAND_ID(SNAND_ID_DYMMY, 0xef, 0xaa, 0x21),
++		   SNAND_MEMORG_1G_2K_64,
++		   &snand_cap_read_from_cache_quad,
++		   &snand_cap_program_load_x4),
++	SNAND_INFO("W25M02GV", SNAND_ID(SNAND_ID_DYMMY, 0xef, 0xab, 0x21),
++		   SNAND_MEMORG_2G_2K_64_2D,
++		   &snand_cap_read_from_cache_quad,
++		   &snand_cap_program_load_x4,
++		   mtk_snand_winbond_select_die),
++	SNAND_INFO("W25N02KV", SNAND_ID(SNAND_ID_DYMMY, 0xef, 0xaa, 0x22),
++		   SNAND_MEMORG_2G_2K_128,
++		   &snand_cap_read_from_cache_quad,
++		   &snand_cap_program_load_x4),
++
++	SNAND_INFO("GD5F1GQ4UAWxx", SNAND_ID(SNAND_ID_ADDR, 0xc8, 0x10),
++		   SNAND_MEMORG_1G_2K_64,
++		   &snand_cap_read_from_cache_quad_q2d,
++		   &snand_cap_program_load_x4),
++	SNAND_INFO("GD5F1GQ4UExIG", SNAND_ID(SNAND_ID_ADDR, 0xc8, 0xd1),
++		   SNAND_MEMORG_1G_2K_128,
++		   &snand_cap_read_from_cache_quad_q2d,
++		   &snand_cap_program_load_x4),
++	SNAND_INFO("GD5F1GQ4UExxH", SNAND_ID(SNAND_ID_ADDR, 0xc8, 0xd9),
++		   SNAND_MEMORG_1G_2K_64,
++		   &snand_cap_read_from_cache_quad_q2d,
++		   &snand_cap_program_load_x4),
++	SNAND_INFO("GD5F1GQ4xAYIG", SNAND_ID(SNAND_ID_ADDR, 0xc8, 0xf1),
++		   SNAND_MEMORG_1G_2K_64,
++		   &snand_cap_read_from_cache_quad_q2d,
++		   &snand_cap_program_load_x4),
++	SNAND_INFO("GD5F2GQ4UExIG", SNAND_ID(SNAND_ID_ADDR, 0xc8, 0xd2),
++		   SNAND_MEMORG_2G_2K_128,
++		   &snand_cap_read_from_cache_quad_q2d,
++		   &snand_cap_program_load_x4),
++	SNAND_INFO("GD5F2GQ5UExxH", SNAND_ID(SNAND_ID_ADDR, 0xc8, 0x32),
++		   SNAND_MEMORG_2G_2K_64,
++		   &snand_cap_read_from_cache_quad_a8d,
++		   &snand_cap_program_load_x4),
++	SNAND_INFO("GD5F2GQ4xAYIG", SNAND_ID(SNAND_ID_ADDR, 0xc8, 0xf2),
++		   SNAND_MEMORG_2G_2K_64,
++		   &snand_cap_read_from_cache_quad_q2d,
++		   &snand_cap_program_load_x4),
++	SNAND_INFO("GD5F4GQ4UBxIG", SNAND_ID(SNAND_ID_ADDR, 0xc8, 0xd4),
++		   SNAND_MEMORG_4G_4K_256,
++		   &snand_cap_read_from_cache_quad_q2d,
++		   &snand_cap_program_load_x4),
++	SNAND_INFO("GD5F4GQ4xAYIG", SNAND_ID(SNAND_ID_ADDR, 0xc8, 0xf4),
++		   SNAND_MEMORG_4G_2K_64,
++		   &snand_cap_read_from_cache_quad_q2d,
++		   &snand_cap_program_load_x4),
++	SNAND_INFO("GD5F2GQ5UExxG", SNAND_ID(SNAND_ID_DYMMY, 0xc8, 0x52),
++		   SNAND_MEMORG_2G_2K_128,
++		   &snand_cap_read_from_cache_quad_q2d,
++		   &snand_cap_program_load_x4),
++	SNAND_INFO("GD5F4GQ4UCxIG", SNAND_ID(SNAND_ID_DYMMY, 0xc8, 0xb4),
++		   SNAND_MEMORG_4G_4K_256,
++		   &snand_cap_read_from_cache_quad_q2d,
++		   &snand_cap_program_load_x4),
++
++	SNAND_INFO("MX35LF1GE4AB", SNAND_ID(SNAND_ID_DYMMY, 0xc2, 0x12),
++		   SNAND_MEMORG_1G_2K_64,
++		   &snand_cap_read_from_cache_x4,
++		   &snand_cap_program_load_x4),
++	SNAND_INFO("MX35LF1G24AD", SNAND_ID(SNAND_ID_DYMMY, 0xc2, 0x14),
++		   SNAND_MEMORG_1G_2K_128,
++		   &snand_cap_read_from_cache_quad,
++		   &snand_cap_program_load_x4),
++	SNAND_INFO("MX31LF1GE4BC", SNAND_ID(SNAND_ID_DYMMY, 0xc2, 0x1e),
++		   SNAND_MEMORG_1G_2K_64,
++		   &snand_cap_read_from_cache_x4,
++		   &snand_cap_program_load_x4),
++	SNAND_INFO("MX35LF2GE4AB", SNAND_ID(SNAND_ID_DYMMY, 0xc2, 0x22),
++		   SNAND_MEMORG_2G_2K_64,
++		   &snand_cap_read_from_cache_x4,
++		   &snand_cap_program_load_x4),
++	SNAND_INFO("MX35LF2G24AD", SNAND_ID(SNAND_ID_DYMMY, 0xc2, 0x24),
++		   SNAND_MEMORG_2G_2K_128,
++		   &snand_cap_read_from_cache_quad,
++		   &snand_cap_program_load_x4),
++	SNAND_INFO("MX35LF2GE4AD", SNAND_ID(SNAND_ID_DYMMY, 0xc2, 0x26),
++		   SNAND_MEMORG_2G_2K_128,
++		   &snand_cap_read_from_cache_x4,
++		   &snand_cap_program_load_x4),
++	SNAND_INFO("MX35LF2G14AC", SNAND_ID(SNAND_ID_DYMMY, 0xc2, 0x20),
++		   SNAND_MEMORG_2G_2K_64,
++		   &snand_cap_read_from_cache_x4,
++		   &snand_cap_program_load_x4),
++	SNAND_INFO("MX35LF4G24AD", SNAND_ID(SNAND_ID_DYMMY, 0xc2, 0x35),
++		   SNAND_MEMORG_4G_4K_256,
++		   &snand_cap_read_from_cache_quad,
++		   &snand_cap_program_load_x4),
++	SNAND_INFO("MX35LF4GE4AD", SNAND_ID(SNAND_ID_DYMMY, 0xc2, 0x37),
++		   SNAND_MEMORG_4G_4K_256,
++		   &snand_cap_read_from_cache_x4,
++		   &snand_cap_program_load_x4),
++
++	SNAND_INFO("MT29F1G01AAADD", SNAND_ID(SNAND_ID_DYMMY, 0x2c, 0x12),
++		   SNAND_MEMORG_1G_2K_64,
++		   &snand_cap_read_from_cache_x4,
++		   &snand_cap_program_load_x1),
++	SNAND_INFO("MT29F1G01ABAFD", SNAND_ID(SNAND_ID_DYMMY, 0x2c, 0x14),
++		   SNAND_MEMORG_1G_2K_128,
++		   &snand_cap_read_from_cache_quad,
++		   &snand_cap_program_load_x4),
++	SNAND_INFO("MT29F2G01AAAED", SNAND_ID(SNAND_ID_DYMMY, 0x2c, 0x9f),
++		   SNAND_MEMORG_2G_2K_64_2P,
++		   &snand_cap_read_from_cache_x4,
++		   &snand_cap_program_load_x1),
++	SNAND_INFO("MT29F2G01ABAGD", SNAND_ID(SNAND_ID_DYMMY, 0x2c, 0x24),
++		   SNAND_MEMORG_2G_2K_128_2P,
++		   &snand_cap_read_from_cache_quad,
++		   &snand_cap_program_load_x4),
++	SNAND_INFO("MT29F4G01AAADD", SNAND_ID(SNAND_ID_DYMMY, 0x2c, 0x32),
++		   SNAND_MEMORG_4G_2K_64_2P,
++		   &snand_cap_read_from_cache_x4,
++		   &snand_cap_program_load_x1),
++	SNAND_INFO("MT29F4G01ABAFD", SNAND_ID(SNAND_ID_DYMMY, 0x2c, 0x34),
++		   SNAND_MEMORG_4G_4K_256,
++		   &snand_cap_read_from_cache_quad,
++		   &snand_cap_program_load_x4),
++	SNAND_INFO("MT29F4G01ADAGD", SNAND_ID(SNAND_ID_DYMMY, 0x2c, 0x36),
++		   SNAND_MEMORG_4G_2K_128_2P_2D,
++		   &snand_cap_read_from_cache_quad,
++		   &snand_cap_program_load_x4,
++		   mtk_snand_micron_select_die),
++	SNAND_INFO("MT29F8G01ADAFD", SNAND_ID(SNAND_ID_DYMMY, 0x2c, 0x46),
++		   SNAND_MEMORG_8G_4K_256_2D,
++		   &snand_cap_read_from_cache_quad,
++		   &snand_cap_program_load_x4,
++		   mtk_snand_micron_select_die),
++
++	SNAND_INFO("TC58CVG0S3HRAIG", SNAND_ID(SNAND_ID_DYMMY, 0x98, 0xc2),
++		   SNAND_MEMORG_1G_2K_128,
++		   &snand_cap_read_from_cache_x4,
++		   &snand_cap_program_load_x1),
++	SNAND_INFO("TC58CVG1S3HRAIG", SNAND_ID(SNAND_ID_DYMMY, 0x98, 0xcb),
++		   SNAND_MEMORG_2G_2K_128,
++		   &snand_cap_read_from_cache_x4,
++		   &snand_cap_program_load_x1),
++	SNAND_INFO("TC58CVG2S0HRAIG", SNAND_ID(SNAND_ID_DYMMY, 0x98, 0xcd),
++		   SNAND_MEMORG_4G_4K_256,
++		   &snand_cap_read_from_cache_x4,
++		   &snand_cap_program_load_x1),
++	SNAND_INFO("TC58CVG0S3HRAIJ", SNAND_ID(SNAND_ID_DYMMY, 0x98, 0xe2),
++		   SNAND_MEMORG_1G_2K_128,
++		   &snand_cap_read_from_cache_x4,
++		   &snand_cap_program_load_x4),
++	SNAND_INFO("TC58CVG1S3HRAIJ", SNAND_ID(SNAND_ID_DYMMY, 0x98, 0xeb),
++		   SNAND_MEMORG_2G_2K_128,
++		   &snand_cap_read_from_cache_x4,
++		   &snand_cap_program_load_x4),
++	SNAND_INFO("TC58CVG2S0HRAIJ", SNAND_ID(SNAND_ID_DYMMY, 0x98, 0xed),
++		   SNAND_MEMORG_4G_4K_256,
++		   &snand_cap_read_from_cache_x4,
++		   &snand_cap_program_load_x4),
++	SNAND_INFO("TH58CVG3S0HRAIJ", SNAND_ID(SNAND_ID_DYMMY, 0x98, 0xe4),
++		   SNAND_MEMORG_8G_4K_256,
++		   &snand_cap_read_from_cache_x4,
++		   &snand_cap_program_load_x4),
++
++	SNAND_INFO("F50L512M41A", SNAND_ID(SNAND_ID_DYMMY, 0xc8, 0x20),
++		   SNAND_MEMORG_512M_2K_64,
++		   &snand_cap_read_from_cache_x4,
++		   &snand_cap_program_load_x4),
++	SNAND_INFO("F50L1G41A", SNAND_ID(SNAND_ID_DYMMY, 0xc8, 0x21),
++		   SNAND_MEMORG_1G_2K_64,
++		   &snand_cap_read_from_cache_x4,
++		   &snand_cap_program_load_x4),
++	SNAND_INFO("F50L1G41LB", SNAND_ID(SNAND_ID_DYMMY, 0xc8, 0x01),
++		   SNAND_MEMORG_1G_2K_64,
++		   &snand_cap_read_from_cache_quad,
++		   &snand_cap_program_load_x4),
++	SNAND_INFO("F50L2G41LB", SNAND_ID(SNAND_ID_DYMMY, 0xc8, 0x0a),
++		   SNAND_MEMORG_2G_2K_64_2D,
++		   &snand_cap_read_from_cache_quad,
++		   &snand_cap_program_load_x4,
++		   mtk_snand_winbond_select_die),
++
++	SNAND_INFO("CS11G0T0A0AA", SNAND_ID(SNAND_ID_DYMMY, 0x6b, 0x00),
++		   SNAND_MEMORG_1G_2K_128,
++		   &snand_cap_read_from_cache_quad_q2d,
++		   &snand_cap_program_load_x4),
++	SNAND_INFO("CS11G0G0A0AA", SNAND_ID(SNAND_ID_DYMMY, 0x6b, 0x10),
++		   SNAND_MEMORG_1G_2K_128,
++		   &snand_cap_read_from_cache_quad_q2d,
++		   &snand_cap_program_load_x4),
++	SNAND_INFO("CS11G0S0A0AA", SNAND_ID(SNAND_ID_DYMMY, 0x6b, 0x20),
++		   SNAND_MEMORG_1G_2K_64,
++		   &snand_cap_read_from_cache_quad_q2d,
++		   &snand_cap_program_load_x4),
++	SNAND_INFO("CS11G1T0A0AA", SNAND_ID(SNAND_ID_DYMMY, 0x6b, 0x01),
++		   SNAND_MEMORG_2G_2K_128,
++		   &snand_cap_read_from_cache_quad_q2d,
++		   &snand_cap_program_load_x4),
++	SNAND_INFO("CS11G1S0A0AA", SNAND_ID(SNAND_ID_DYMMY, 0x6b, 0x21),
++		   SNAND_MEMORG_2G_2K_64,
++		   &snand_cap_read_from_cache_quad_q2d,
++		   &snand_cap_program_load_x4),
++	SNAND_INFO("CS11G2T0A0AA", SNAND_ID(SNAND_ID_DYMMY, 0x6b, 0x02),
++		   SNAND_MEMORG_4G_2K_128,
++		   &snand_cap_read_from_cache_quad_q2d,
++		   &snand_cap_program_load_x4),
++	SNAND_INFO("CS11G2S0A0AA", SNAND_ID(SNAND_ID_DYMMY, 0x6b, 0x22),
++		   SNAND_MEMORG_4G_2K_64,
++		   &snand_cap_read_from_cache_quad_q2d,
++		   &snand_cap_program_load_x4),
++
++	SNAND_INFO("EM73B044VCA", SNAND_ID(SNAND_ID_DYMMY, 0xd5, 0x01),
++		   SNAND_MEMORG_512M_2K_64,
++		   &snand_cap_read_from_cache_quad_q2d,
++		   &snand_cap_program_load_x4),
++	SNAND_INFO("EM73C044SNB", SNAND_ID(SNAND_ID_DYMMY, 0xd5, 0x11),
++		   SNAND_MEMORG_1G_2K_120,
++		   &snand_cap_read_from_cache_quad_q2d,
++		   &snand_cap_program_load_x4),
++	SNAND_INFO("EM73C044SNF", SNAND_ID(SNAND_ID_DYMMY, 0xd5, 0x09),
++		   SNAND_MEMORG_1G_2K_128,
++		   &snand_cap_read_from_cache_quad_q2d,
++		   &snand_cap_program_load_x4),
++	SNAND_INFO("EM73C044VCA", SNAND_ID(SNAND_ID_DYMMY, 0xd5, 0x18),
++		   SNAND_MEMORG_1G_2K_64,
++		   &snand_cap_read_from_cache_quad_q2d,
++		   &snand_cap_program_load_x4),
++	SNAND_INFO("EM73C044SNA", SNAND_ID(SNAND_ID_DYMMY, 0xd5, 0x19),
++		   SNAND_MEMORG(2048, 64, 128, 512, 1, 1),
++		   &snand_cap_read_from_cache_quad_q2d,
++		   &snand_cap_program_load_x4),
++	SNAND_INFO("EM73C044VCD", SNAND_ID(SNAND_ID_DYMMY, 0xd5, 0x1c),
++		   SNAND_MEMORG_1G_2K_64,
++		   &snand_cap_read_from_cache_quad_q2d,
++		   &snand_cap_program_load_x4),
++	SNAND_INFO("EM73C044SND", SNAND_ID(SNAND_ID_DYMMY, 0xd5, 0x1d),
++		   SNAND_MEMORG_1G_2K_64,
++		   &snand_cap_read_from_cache_quad_q2d,
++		   &snand_cap_program_load_x4),
++	SNAND_INFO("EM73D044SND", SNAND_ID(SNAND_ID_DYMMY, 0xd5, 0x1e),
++		   SNAND_MEMORG_2G_2K_64,
++		   &snand_cap_read_from_cache_quad_q2d,
++		   &snand_cap_program_load_x4),
++	SNAND_INFO("EM73C044VCC", SNAND_ID(SNAND_ID_DYMMY, 0xd5, 0x22),
++		   SNAND_MEMORG_1G_2K_64,
++		   &snand_cap_read_from_cache_quad_q2d,
++		   &snand_cap_program_load_x4),
++	SNAND_INFO("EM73C044VCF", SNAND_ID(SNAND_ID_DYMMY, 0xd5, 0x25),
++		   SNAND_MEMORG_1G_2K_64,
++		   &snand_cap_read_from_cache_quad_q2d,
++		   &snand_cap_program_load_x4),
++	SNAND_INFO("EM73C044SNC", SNAND_ID(SNAND_ID_DYMMY, 0xd5, 0x31),
++		   SNAND_MEMORG_1G_2K_128,
++		   &snand_cap_read_from_cache_quad_q2d,
++		   &snand_cap_program_load_x4),
++	SNAND_INFO("EM73D044SNC", SNAND_ID(SNAND_ID_DYMMY, 0xd5, 0x0a),
++		   SNAND_MEMORG_2G_2K_120,
++		   &snand_cap_read_from_cache_quad_q2d,
++		   &snand_cap_program_load_x4),
++	SNAND_INFO("EM73D044SNA", SNAND_ID(SNAND_ID_DYMMY, 0xd5, 0x12),
++		   SNAND_MEMORG_2G_2K_128,
++		   &snand_cap_read_from_cache_quad_q2d,
++		   &snand_cap_program_load_x4),
++	SNAND_INFO("EM73D044SNF", SNAND_ID(SNAND_ID_DYMMY, 0xd5, 0x10),
++		   SNAND_MEMORG_2G_2K_128,
++		   &snand_cap_read_from_cache_quad_q2d,
++		   &snand_cap_program_load_x4),
++	SNAND_INFO("EM73D044VCA", SNAND_ID(SNAND_ID_DYMMY, 0xd5, 0x13),
++		   SNAND_MEMORG_2G_2K_128,
++		   &snand_cap_read_from_cache_quad_q2d,
++		   &snand_cap_program_load_x4),
++	SNAND_INFO("EM73D044VCB", SNAND_ID(SNAND_ID_DYMMY, 0xd5, 0x14),
++		   SNAND_MEMORG_2G_2K_64,
++		   &snand_cap_read_from_cache_quad_q2d,
++		   &snand_cap_program_load_x4),
++	SNAND_INFO("EM73D044VCD", SNAND_ID(SNAND_ID_DYMMY, 0xd5, 0x17),
++		   SNAND_MEMORG_2G_2K_128,
++		   &snand_cap_read_from_cache_quad_q2d,
++		   &snand_cap_program_load_x4),
++	SNAND_INFO("EM73D044VCH", SNAND_ID(SNAND_ID_DYMMY, 0xd5, 0x1b),
++		   SNAND_MEMORG_2G_2K_64,
++		   &snand_cap_read_from_cache_quad_q2d,
++		   &snand_cap_program_load_x4),
++	SNAND_INFO("EM73D044SND", SNAND_ID(SNAND_ID_DYMMY, 0xd5, 0x1d),
++		   SNAND_MEMORG_2G_2K_64,
++		   &snand_cap_read_from_cache_quad_q2d,
++		   &snand_cap_program_load_x4),
++	SNAND_INFO("EM73D044VCG", SNAND_ID(SNAND_ID_DYMMY, 0xd5, 0x1f),
++		   SNAND_MEMORG_2G_2K_64,
++		   &snand_cap_read_from_cache_quad_q2d,
++		   &snand_cap_program_load_x4),
++	SNAND_INFO("EM73D044VCE", SNAND_ID(SNAND_ID_DYMMY, 0xd5, 0x20),
++		   SNAND_MEMORG_2G_2K_64,
++		   &snand_cap_read_from_cache_quad_q2d,
++		   &snand_cap_program_load_x4),
++	SNAND_INFO("EM73D044VCL", SNAND_ID(SNAND_ID_DYMMY, 0xd5, 0x2e),
++		   SNAND_MEMORG_2G_2K_128,
++		   &snand_cap_read_from_cache_quad_q2d,
++		   &snand_cap_program_load_x4),
++	SNAND_INFO("EM73D044SNB", SNAND_ID(SNAND_ID_DYMMY, 0xd5, 0x32),
++		   SNAND_MEMORG_2G_2K_128,
++		   &snand_cap_read_from_cache_quad_q2d,
++		   &snand_cap_program_load_x4),
++	SNAND_INFO("EM73E044SNA", SNAND_ID(SNAND_ID_DYMMY, 0xd5, 0x03),
++		   SNAND_MEMORG_4G_4K_256,
++		   &snand_cap_read_from_cache_quad_q2d,
++		   &snand_cap_program_load_x4),
++	SNAND_INFO("EM73E044SND", SNAND_ID(SNAND_ID_DYMMY, 0xd5, 0x0b),
++		   SNAND_MEMORG_4G_4K_240,
++		   &snand_cap_read_from_cache_quad_q2d,
++		   &snand_cap_program_load_x4),
++	SNAND_INFO("EM73E044SNB", SNAND_ID(SNAND_ID_DYMMY, 0xd5, 0x23),
++		   SNAND_MEMORG_4G_4K_256,
++		   &snand_cap_read_from_cache_quad_q2d,
++		   &snand_cap_program_load_x4),
++	SNAND_INFO("EM73E044VCA", SNAND_ID(SNAND_ID_DYMMY, 0xd5, 0x2c),
++		   SNAND_MEMORG_4G_4K_256,
++		   &snand_cap_read_from_cache_quad_q2d,
++		   &snand_cap_program_load_x4),
++	SNAND_INFO("EM73E044VCB", SNAND_ID(SNAND_ID_DYMMY, 0xd5, 0x2f),
++		   SNAND_MEMORG_4G_2K_128,
++		   &snand_cap_read_from_cache_quad_q2d,
++		   &snand_cap_program_load_x4),
++	SNAND_INFO("EM73F044SNA", SNAND_ID(SNAND_ID_DYMMY, 0xd5, 0x24),
++		   SNAND_MEMORG_8G_4K_256,
++		   &snand_cap_read_from_cache_quad_q2d,
++		   &snand_cap_program_load_x4),
++	SNAND_INFO("EM73F044VCA", SNAND_ID(SNAND_ID_DYMMY, 0xd5, 0x2d),
++		   SNAND_MEMORG_8G_4K_256,
++		   &snand_cap_read_from_cache_quad_q2d,
++		   &snand_cap_program_load_x4),
++	SNAND_INFO("EM73E044SNE", SNAND_ID(SNAND_ID_DYMMY, 0xd5, 0x0e),
++		   SNAND_MEMORG_8G_4K_256,
++		   &snand_cap_read_from_cache_quad_q2d,
++		   &snand_cap_program_load_x4),
++	SNAND_INFO("EM73C044SNG", SNAND_ID(SNAND_ID_DYMMY, 0xd5, 0x0c),
++		   SNAND_MEMORG_1G_2K_120,
++		   &snand_cap_read_from_cache_quad_q2d,
++		   &snand_cap_program_load_x4),
++	SNAND_INFO("EM73D044VCN", SNAND_ID(SNAND_ID_DYMMY, 0xd5, 0x0f),
++		   SNAND_MEMORG_2G_2K_64,
++		   &snand_cap_read_from_cache_quad_q2d,
++		   &snand_cap_program_load_x4),
++
++	SNAND_INFO("FM35Q1GA", SNAND_ID(SNAND_ID_DYMMY, 0xe5, 0x71),
++		   SNAND_MEMORG_1G_2K_64,
++		   &snand_cap_read_from_cache_x4,
++		   &snand_cap_program_load_x4),
++
++	SNAND_INFO("PN26G01A", SNAND_ID(SNAND_ID_DYMMY, 0xa1, 0xe1),
++		   SNAND_MEMORG_1G_2K_128,
++		   &snand_cap_read_from_cache_quad_q2d,
++		   &snand_cap_program_load_x4),
++	SNAND_INFO("PN26G02A", SNAND_ID(SNAND_ID_DYMMY, 0xa1, 0xe2),
++		   SNAND_MEMORG_2G_2K_128,
++		   &snand_cap_read_from_cache_quad_q2d,
++		   &snand_cap_program_load_x4),
++
++	SNAND_INFO("IS37SML01G1", SNAND_ID(SNAND_ID_DYMMY, 0xc8, 0x21),
++		   SNAND_MEMORG_1G_2K_64,
++		   &snand_cap_read_from_cache_x4,
++		   &snand_cap_program_load_x4),
++
++	SNAND_INFO("ATO25D1GA", SNAND_ID(SNAND_ID_DYMMY, 0x9b, 0x12),
++		   SNAND_MEMORG_1G_2K_64,
++		   &snand_cap_read_from_cache_x4_only,
++		   &snand_cap_program_load_x4),
++
++	SNAND_INFO("HYF1GQ4U", SNAND_ID(SNAND_ID_DYMMY, 0xc9, 0x51),
++		   SNAND_MEMORG_1G_2K_128,
++		   &snand_cap_read_from_cache_quad_q2d,
++		   &snand_cap_program_load_x4),
++	SNAND_INFO("HYF2GQ4U", SNAND_ID(SNAND_ID_DYMMY, 0xc9, 0x52),
++		   SNAND_MEMORG_2G_2K_128,
++		   &snand_cap_read_from_cache_quad_q2d,
++		   &snand_cap_program_load_x4),
++};
++
++static int mtk_snand_winbond_select_die(struct mtk_snand *snf, uint32_t dieidx)
++{
++	uint8_t op[2];
++
++	if (dieidx > 1) {
++		snand_log_chip(snf->pdev, "Invalid die index %u\n", dieidx);
++		return -EINVAL;
++	}
++
++	op[0] = SNAND_CMD_WINBOND_SELECT_DIE;
++	op[1] = (uint8_t)dieidx;
++
++	return mtk_snand_mac_io(snf, op, sizeof(op), NULL, 0);
++}
++
++static int mtk_snand_micron_select_die(struct mtk_snand *snf, uint32_t dieidx)
++{
++	int ret;
++
++	if (dieidx > 1) {
++		snand_log_chip(snf->pdev, "Invalid die index %u\n", dieidx);
++		return -EINVAL;
++	}
++
++	ret = mtk_snand_set_feature(snf, SNAND_FEATURE_MICRON_DIE_ADDR,
++				    SNAND_MICRON_DIE_SEL_1);
++	if (ret) {
++		snand_log_chip(snf->pdev,
++			       "Failed to set die selection feature\n");
++		return ret;
++	}
++
++	return 0;
++}
++
++const struct snand_flash_info *snand_flash_id_lookup(enum snand_id_type type,
++						     const uint8_t *id)
++{
++	const struct snand_id *fid;
++	uint32_t i;
++
++	for (i = 0; i < ARRAY_SIZE(snand_flash_ids); i++) {
++		if (snand_flash_ids[i].id.type != type)
++			continue;
++
++		fid = &snand_flash_ids[i].id;
++		if (memcmp(fid->id, id, fid->len))
++			continue;
++
++		return &snand_flash_ids[i];
++	}
++
++	return NULL;
++}
+--- /dev/null
++++ b/drivers/mtd/mtk-snand/mtk-snand-mtd.c
+@@ -0,0 +1,526 @@
++// SPDX-License-Identifier: GPL-2.0
++/*
++ * Copyright (C) 2020 MediaTek Inc. All Rights Reserved.
++ *
++ * Author: Weijie Gao <weijie.gao@mediatek.com>
++ */
++
++#include <common.h>
++#include <dm.h>
++#include <malloc.h>
++#include <mapmem.h>
++#include <linux/mtd/mtd.h>
++#include <watchdog.h>
++
++#include "mtk-snand.h"
++
++struct mtk_snand_mtd {
++	struct udevice *dev;
++	struct mtk_snand *snf;
++	struct mtk_snand_chip_info cinfo;
++	uint8_t *page_cache;
++};
++
++static const char snand_mtd_name_prefix[] = "spi-nand";
++
++static u32 snandidx;
++
++static inline struct mtk_snand_mtd *mtd_to_msm(struct mtd_info *mtd)
++{
++	return mtd->priv;
++}
++
++static int mtk_snand_mtd_erase(struct mtd_info *mtd, struct erase_info *instr)
++{
++	struct mtk_snand_mtd *msm = mtd_to_msm(mtd);
++	u64 start_addr, end_addr;
++	int ret;
++
++	/* Do not allow write past end of device */
++	if ((instr->addr + instr->len) > mtd->size) {
++		pr_debug("%s: attempt to erase beyond end of device\n",
++			 __func__);
++		return -EINVAL;
++	}
++
++	start_addr = instr->addr & (~mtd->erasesize_mask);
++	end_addr = instr->addr + instr->len;
++	if (end_addr & mtd->erasesize_mask) {
++		end_addr = (end_addr + mtd->erasesize_mask) &
++			   (~mtd->erasesize_mask);
++	}
++
++	instr->state = MTD_ERASING;
++
++	while (start_addr < end_addr) {
++		WATCHDOG_RESET();
++
++		if (mtk_snand_block_isbad(msm->snf, start_addr)) {
++			if (!instr->scrub) {
++				instr->fail_addr = start_addr;
++				ret = -EIO;
++				break;
++			}
++		}
++
++		ret = mtk_snand_erase_block(msm->snf, start_addr);
++		if (ret) {
++			instr->fail_addr = start_addr;
++			break;
++		}
++
++		start_addr += mtd->erasesize;
++	}
++
++	if (ret)
++		instr->state = MTD_ERASE_FAILED;
++	else
++		instr->state = MTD_ERASE_DONE;
++
++	if (!ret)
++		mtd_erase_callback(instr);
++	else
++		ret = -EIO;
++
++	return ret;
++}
++
++static int mtk_snand_mtd_read_data(struct mtk_snand_mtd *msm, uint64_t addr,
++				   struct mtd_oob_ops *ops)
++{
++	struct mtd_info *mtd = dev_get_uclass_priv(msm->dev);
++	size_t len, ooblen, maxooblen, chklen;
++	uint32_t col, ooboffs;
++	uint8_t *datcache, *oobcache;
++	bool raw = ops->mode == MTD_OPS_RAW ? true : false;
++	int ret;
++
++	col = addr & mtd->writesize_mask;
++	addr &= ~mtd->writesize_mask;
++	maxooblen = mtd_oobavail(mtd, ops);
++	ooboffs = ops->ooboffs;
++	ooblen = ops->ooblen;
++	len = ops->len;
++
++	datcache = len ? msm->page_cache : NULL;
++	oobcache = ooblen ? msm->page_cache + mtd->writesize : NULL;
++
++	ops->oobretlen = 0;
++	ops->retlen = 0;
++
++	while (len || ooblen) {
++		WATCHDOG_RESET();
++
++		if (ops->mode == MTD_OPS_AUTO_OOB)
++			ret = mtk_snand_read_page_auto_oob(msm->snf, addr,
++				datcache, oobcache, maxooblen, NULL, raw);
++		else
++			ret = mtk_snand_read_page(msm->snf, addr, datcache,
++				oobcache, raw);
++
++		if (ret < 0)
++			return ret;
++
++		if (len) {
++			/* Move data */
++			chklen = mtd->writesize - col;
++			if (chklen > len)
++				chklen = len;
++
++			memcpy(ops->datbuf + ops->retlen, datcache + col,
++			       chklen);
++			len -= chklen;
++			col = 0; /* (col + chklen) %  */
++			ops->retlen += chklen;
++		}
++
++		if (ooblen) {
++			/* Move oob */
++			chklen = maxooblen - ooboffs;
++			if (chklen > ooblen)
++				chklen = ooblen;
++
++			memcpy(ops->oobbuf + ops->oobretlen, oobcache + ooboffs,
++			       chklen);
++			ooblen -= chklen;
++			ooboffs = 0; /* (ooboffs + chklen) % maxooblen; */
++			ops->oobretlen += chklen;
++		}
++
++		addr += mtd->writesize;
++	}
++
++	return 0;
++}
++
++static int mtk_snand_mtd_read_oob(struct mtd_info *mtd, loff_t from,
++				  struct mtd_oob_ops *ops)
++{
++	struct mtk_snand_mtd *msm = mtd_to_msm(mtd);
++	uint32_t maxooblen;
++
++	if (!ops->oobbuf && !ops->datbuf) {
++		if (ops->ooblen || ops->len)
++			return -EINVAL;
++
++		return 0;
++	}
++
++	switch (ops->mode) {
++	case MTD_OPS_PLACE_OOB:
++	case MTD_OPS_AUTO_OOB:
++	case MTD_OPS_RAW:
++		break;
++	default:
++		pr_debug("%s: unsupported oob mode: %u\n", __func__, ops->mode);
++		return -EINVAL;
++	}
++
++	maxooblen = mtd_oobavail(mtd, ops);
++
++	/* Do not allow read past end of device */
++	if (ops->datbuf && (from + ops->len) > mtd->size) {
++		pr_debug("%s: attempt to read beyond end of device\n",
++			 __func__);
++		return -EINVAL;
++	}
++
++	if (unlikely(ops->ooboffs >= maxooblen)) {
++		pr_debug("%s: attempt to start read outside oob\n",
++			 __func__);
++		return -EINVAL;
++	}
++
++	if (unlikely(from >= mtd->size ||
++	    ops->ooboffs + ops->ooblen > ((mtd->size >> mtd->writesize_shift) -
++	    (from >> mtd->writesize_shift)) * maxooblen)) {
++		pr_debug("%s: attempt to read beyond end of device\n",
++			 __func__);
++		return -EINVAL;
++	}
++
++	return mtk_snand_mtd_read_data(msm, from, ops);
++}
++
++static int mtk_snand_mtd_write_data(struct mtk_snand_mtd *msm, uint64_t addr,
++				    struct mtd_oob_ops *ops)
++{
++	struct mtd_info *mtd = dev_get_uclass_priv(msm->dev);
++	size_t len, ooblen, maxooblen, chklen, oobwrlen;
++	uint32_t col, ooboffs;
++	uint8_t *datcache, *oobcache;
++	bool raw = ops->mode == MTD_OPS_RAW ? true : false;
++	int ret;
++
++	col = addr & mtd->writesize_mask;
++	addr &= ~mtd->writesize_mask;
++	maxooblen = mtd_oobavail(mtd, ops);
++	ooboffs = ops->ooboffs;
++	ooblen = ops->ooblen;
++	len = ops->len;
++
++	datcache = len ? msm->page_cache : NULL;
++	oobcache = ooblen ? msm->page_cache + mtd->writesize : NULL;
++
++	ops->oobretlen = 0;
++	ops->retlen = 0;
++
++	while (len || ooblen) {
++		WATCHDOG_RESET();
++
++		if (len) {
++			/* Move data */
++			chklen = mtd->writesize - col;
++			if (chklen > len)
++				chklen = len;
++
++			memset(datcache, 0xff, col);
++			memcpy(datcache + col, ops->datbuf + ops->retlen,
++			       chklen);
++			memset(datcache + col + chklen, 0xff,
++			       mtd->writesize - col - chklen);
++			len -= chklen;
++			col = 0; /* (col + chklen) %  */
++			ops->retlen += chklen;
++		}
++
++		oobwrlen = 0;
++		if (ooblen) {
++			/* Move oob */
++			chklen = maxooblen - ooboffs;
++			if (chklen > ooblen)
++				chklen = ooblen;
++
++			memset(oobcache, 0xff, ooboffs);
++			memcpy(oobcache + ooboffs,
++			       ops->oobbuf + ops->oobretlen, chklen);
++			memset(oobcache + ooboffs + chklen, 0xff,
++			       mtd->oobsize - ooboffs - chklen);
++			oobwrlen = chklen + ooboffs;
++			ooblen -= chklen;
++			ooboffs = 0; /* (ooboffs + chklen) % maxooblen; */
++			ops->oobretlen += chklen;
++		}
++
++		if (ops->mode == MTD_OPS_AUTO_OOB)
++			ret = mtk_snand_write_page_auto_oob(msm->snf, addr,
++				datcache, oobcache, oobwrlen, NULL, raw);
++		else
++			ret = mtk_snand_write_page(msm->snf, addr, datcache,
++				oobcache, raw);
++
++		if (ret)
++			return ret;
++
++		addr += mtd->writesize;
++	}
++
++	return 0;
++}
++
++static int mtk_snand_mtd_write_oob(struct mtd_info *mtd, loff_t to,
++				   struct mtd_oob_ops *ops)
++{
++	struct mtk_snand_mtd *msm = mtd_to_msm(mtd);
++	uint32_t maxooblen;
++
++	if (!ops->oobbuf && !ops->datbuf) {
++		if (ops->ooblen || ops->len)
++			return -EINVAL;
++
++		return 0;
++	}
++
++	switch (ops->mode) {
++	case MTD_OPS_PLACE_OOB:
++	case MTD_OPS_AUTO_OOB:
++	case MTD_OPS_RAW:
++		break;
++	default:
++		pr_debug("%s: unsupported oob mode: %u\n", __func__, ops->mode);
++		return -EINVAL;
++	}
++
++	maxooblen = mtd_oobavail(mtd, ops);
++
++	/* Do not allow write past end of device */
++	if (ops->datbuf && (to + ops->len) > mtd->size) {
++		pr_debug("%s: attempt to write beyond end of device\n",
++			 __func__);
++		return -EINVAL;
++	}
++
++	if (unlikely(ops->ooboffs >= maxooblen)) {
++		pr_debug("%s: attempt to start write outside oob\n",
++			 __func__);
++		return -EINVAL;
++	}
++
++	if (unlikely(to >= mtd->size ||
++	    ops->ooboffs + ops->ooblen > ((mtd->size >> mtd->writesize_shift) -
++	    (to >> mtd->writesize_shift)) * maxooblen)) {
++		pr_debug("%s: attempt to write beyond end of device\n",
++			 __func__);
++		return -EINVAL;
++	}
++
++	return mtk_snand_mtd_write_data(msm, to, ops);
++}
++
++static int mtk_snand_mtd_read(struct mtd_info *mtd, loff_t from, size_t len,
++			      size_t *retlen, u_char *buf)
++{
++	struct mtd_oob_ops ops = {
++		.mode = MTD_OPS_PLACE_OOB,
++		.datbuf = buf,
++		.len = len,
++	};
++	int ret;
++
++	ret = mtk_snand_mtd_read_oob(mtd, from, &ops);
++
++	if (retlen)
++		*retlen = ops.retlen;
++
++	return ret;
++}
++
++static int mtk_snand_mtd_write(struct mtd_info *mtd, loff_t to, size_t len,
++			       size_t *retlen, const u_char *buf)
++{
++	struct mtd_oob_ops ops = {
++		.mode = MTD_OPS_PLACE_OOB,
++		.datbuf = (void *)buf,
++		.len = len,
++	};
++	int ret;
++
++	ret = mtk_snand_mtd_write_oob(mtd, to, &ops);
++
++	if (retlen)
++		*retlen = ops.retlen;
++
++	return ret;
++}
++
++static int mtk_snand_mtd_block_isbad(struct mtd_info *mtd, loff_t offs)
++{
++	struct mtk_snand_mtd *msm = mtd_to_msm(mtd);
++
++	return mtk_snand_block_isbad(msm->snf, offs);
++}
++
++static int mtk_snand_mtd_block_markbad(struct mtd_info *mtd, loff_t offs)
++{
++	struct mtk_snand_mtd *msm = mtd_to_msm(mtd);
++
++	return mtk_snand_block_markbad(msm->snf, offs);
++}
++
++static int mtk_snand_ooblayout_ecc(struct mtd_info *mtd, int section,
++				   struct mtd_oob_region *oobecc)
++{
++	struct mtk_snand_mtd *msm = mtd_to_msm(mtd);
++
++	if (section)
++		return -ERANGE;
++
++	oobecc->offset = msm->cinfo.fdm_size * msm->cinfo.num_sectors;
++	oobecc->length = mtd->oobsize - oobecc->offset;
++
++	return 0;
++}
++
++static int mtk_snand_ooblayout_free(struct mtd_info *mtd, int section,
++				    struct mtd_oob_region *oobfree)
++{
++	struct mtk_snand_mtd *msm = mtd_to_msm(mtd);
++
++	if (section >= msm->cinfo.num_sectors)
++		return -ERANGE;
++
++	oobfree->length = msm->cinfo.fdm_size - 1;
++	oobfree->offset = section * msm->cinfo.fdm_size + 1;
++
++	return 0;
++}
++
++static const struct mtd_ooblayout_ops mtk_snand_ooblayout = {
++	.ecc = mtk_snand_ooblayout_ecc,
++	.rfree = mtk_snand_ooblayout_free,
++};
++
++static int mtk_snand_mtd_probe(struct udevice *dev)
++{
++	struct mtk_snand_mtd *msm = dev_get_priv(dev);
++	struct mtd_info *mtd = dev_get_uclass_priv(dev);
++	struct mtk_snand_platdata mtk_snand_pdata = {};
++	size_t namelen;
++	fdt_addr_t base;
++	int ret;
++
++	base = dev_read_addr_name(dev, "nfi");
++	if (base == FDT_ADDR_T_NONE)
++		return -EINVAL;
++	mtk_snand_pdata.nfi_base = map_sysmem(base, 0);
++
++	base = dev_read_addr_name(dev, "ecc");
++	if (base == FDT_ADDR_T_NONE)
++		return -EINVAL;
++	mtk_snand_pdata.ecc_base = map_sysmem(base, 0);
++
++	mtk_snand_pdata.soc = dev_get_driver_data(dev);
++	mtk_snand_pdata.quad_spi = dev_read_bool(dev, "quad-spi");
++
++	ret = mtk_snand_init(NULL, &mtk_snand_pdata, &msm->snf);
++	if (ret)
++		return ret;
++
++	mtk_snand_get_chip_info(msm->snf, &msm->cinfo);
++
++	msm->page_cache = malloc(msm->cinfo.pagesize + msm->cinfo.sparesize);
++	if (!msm->page_cache) {
++		printf("%s: failed to allocate memory for page cache\n",
++		       __func__);
++		ret = -ENOMEM;
++		goto errout1;
++	}
++
++	namelen = sizeof(snand_mtd_name_prefix) + 12;
++
++	mtd->name = malloc(namelen);
++	if (!mtd->name) {
++		printf("%s: failed to allocate memory for MTD name\n",
++		       __func__);
++		ret = -ENOMEM;
++		goto errout2;
++	}
++
++	msm->dev = dev;
++
++	snprintf(mtd->name, namelen, "%s%u", snand_mtd_name_prefix, snandidx++);
++
++	mtd->priv = msm;
++	mtd->dev = dev;
++	mtd->type = MTD_NANDFLASH;
++	mtd->flags = MTD_CAP_NANDFLASH;
++
++	mtd->size = msm->cinfo.chipsize;
++	mtd->erasesize = msm->cinfo.blocksize;
++	mtd->writesize = msm->cinfo.pagesize;
++	mtd->writebufsize = mtd->writesize;
++	mtd->oobsize = msm->cinfo.sparesize;
++	mtd->oobavail = msm->cinfo.num_sectors * (msm->cinfo.fdm_size - 1);
++
++	mtd->ooblayout = &mtk_snand_ooblayout;
++
++	mtd->ecc_strength = msm->cinfo.ecc_strength * msm->cinfo.num_sectors;
++	mtd->bitflip_threshold = (mtd->ecc_strength * 3) / 4;
++	mtd->ecc_step_size = msm->cinfo.sector_size;
++
++	mtd->_read = mtk_snand_mtd_read;
++	mtd->_write = mtk_snand_mtd_write;
++	mtd->_erase = mtk_snand_mtd_erase;
++	mtd->_read_oob = mtk_snand_mtd_read_oob;
++	mtd->_write_oob = mtk_snand_mtd_write_oob;
++	mtd->_block_isbad = mtk_snand_mtd_block_isbad;
++	mtd->_block_markbad = mtk_snand_mtd_block_markbad;
++
++	ret = add_mtd_device(mtd);
++	if (ret) {
++		printf("%s: failed to add SPI-NAND MTD device\n", __func__);
++		ret = -ENODEV;
++		goto errout3;
++	}
++
++	printf("SPI-NAND: %s (%lluMB)\n", msm->cinfo.model,
++	       msm->cinfo.chipsize >> 20);
++
++	return 0;
++
++errout3:
++	free(mtd->name);
++
++errout2:
++	free(msm->page_cache);
++
++errout1:
++	mtk_snand_cleanup(msm->snf);
++
++	return ret;
++}
++
++static const struct udevice_id mtk_snand_ids[] = {
++	{ .compatible = "mediatek,mt7622-snand", .data = SNAND_SOC_MT7622 },
++	{ .compatible = "mediatek,mt7629-snand", .data = SNAND_SOC_MT7629 },
++	{ .compatible = "mediatek,mt7986-snand", .data = SNAND_SOC_MT7986 },
++	{ /* sentinel */ },
++};
++
++U_BOOT_DRIVER(spinand) = {
++	.name = "mtk-snand",
++	.id = UCLASS_MTD,
++	.of_match = mtk_snand_ids,
++	.priv_auto = sizeof(struct mtk_snand_mtd),
++	.probe = mtk_snand_mtd_probe,
++};
+--- /dev/null
++++ b/drivers/mtd/mtk-snand/mtk-snand-os.c
+@@ -0,0 +1,39 @@
++// SPDX-License-Identifier: GPL-2.0
++/*
++ * Copyright (C) 2020 MediaTek Inc. All Rights Reserved.
++ *
++ * Author: Weijie Gao <weijie.gao@mediatek.com>
++ */
++
++#include "mtk-snand-def.h"
++
++int mtk_snand_log(struct mtk_snand_plat_dev *pdev,
++		  enum mtk_snand_log_category cat, const char *fmt, ...)
++{
++	const char *catname = "";
++	va_list ap;
++	int ret;
++
++	switch (cat) {
++	case SNAND_LOG_NFI:
++		catname = "NFI: ";
++		break;
++	case SNAND_LOG_SNFI:
++		catname = "SNFI: ";
++		break;
++	case SNAND_LOG_ECC:
++		catname = "ECC: ";
++		break;
++	default:
++		break;
++	}
++
++	puts("SPI-NAND: ");
++	puts(catname);
++
++	va_start(ap, fmt);
++	ret = vprintf(fmt, ap);
++	va_end(ap);
++
++	return ret;
++}
+--- /dev/null
++++ b/drivers/mtd/mtk-snand/mtk-snand-os.h
+@@ -0,0 +1,120 @@
++/* SPDX-License-Identifier: GPL-2.0 */
++/*
++ * Copyright (C) 2020 MediaTek Inc. All Rights Reserved.
++ *
++ * Author: Weijie Gao <weijie.gao@mediatek.com>
++ */
++
++#ifndef _MTK_SNAND_OS_H_
++#define _MTK_SNAND_OS_H_
++
++#include <common.h>
++#include <cpu_func.h>
++#include <errno.h>
++#include <div64.h>
++#include <malloc.h>
++#include <stdbool.h>
++#include <stdarg.h>
++#include <linux/types.h>
++#include <asm/io.h>
++#include <linux/bitops.h>
++#include <linux/sizes.h>
++#include <linux/iopoll.h>
++
++#ifndef ARCH_DMA_MINALIGN
++#define ARCH_DMA_MINALIGN		64
++#endif
++
++struct mtk_snand_plat_dev {
++	ulong unused;
++};
++
++/* Polling helpers */
++#define read16_poll_timeout(addr, val, cond, sleep_us, timeout_us) \
++	readw_poll_timeout((addr), (val), (cond), (timeout_us))
++
++#define read32_poll_timeout(addr, val, cond, sleep_us, timeout_us) \
++	readl_poll_timeout((addr), (val), (cond), (timeout_us))
++
++/* Timer helpers */
++typedef uint64_t mtk_snand_time_t;
++
++static inline mtk_snand_time_t timer_get_ticks(void)
++{
++	return get_ticks();
++}
++
++static inline mtk_snand_time_t timer_time_to_tick(uint32_t timeout_us)
++{
++	return usec_to_tick(timeout_us);
++}
++
++static inline bool timer_is_timeout(mtk_snand_time_t start_tick,
++				    mtk_snand_time_t timeout_tick)
++{
++	return get_ticks() - start_tick > timeout_tick;
++}
++
++/* Memory helpers */
++static inline void *generic_mem_alloc(struct mtk_snand_plat_dev *pdev,
++				      size_t size)
++{
++	return calloc(1, size);
++}
++
++static inline void generic_mem_free(struct mtk_snand_plat_dev *pdev, void *ptr)
++{
++	free(ptr);
++}
++
++static inline void *dma_mem_alloc(struct mtk_snand_plat_dev *pdev, size_t size)
++{
++	return memalign(ARCH_DMA_MINALIGN, size);
++}
++
++static inline void dma_mem_free(struct mtk_snand_plat_dev *pdev, void *ptr)
++{
++	free(ptr);
++}
++
++static inline int dma_mem_map(struct mtk_snand_plat_dev *pdev, void *vaddr,
++			      uintptr_t *dma_addr, size_t size, bool to_device)
++{
++	size_t cachelen = roundup(size, ARCH_DMA_MINALIGN);
++	uintptr_t endaddr = (uintptr_t)vaddr + cachelen;
++
++	if (to_device)
++		flush_dcache_range((uintptr_t)vaddr, endaddr);
++	else
++		invalidate_dcache_range((uintptr_t)vaddr, endaddr);
++
++	*dma_addr = (uintptr_t)vaddr;
++
++	return 0;
++}
++
++static inline void dma_mem_unmap(struct mtk_snand_plat_dev *pdev,
++				 uintptr_t dma_addr, size_t size,
++				 bool to_device)
++{
++}
++
++/* Interrupt helpers */
++static inline void irq_completion_done(struct mtk_snand_plat_dev *pdev)
++{
++}
++
++static inline void irq_completion_init(struct mtk_snand_plat_dev *pdev)
++{
++}
++
++static inline int irq_completion_wait(struct mtk_snand_plat_dev *pdev,
++				      void __iomem *reg, uint32_t bit,
++				      uint32_t timeout_us)
++{
++	uint32_t val;
++
++	return read32_poll_timeout(reg, val, val & bit, 0, timeout_us);
++}
++
++#endif /* _MTK_SNAND_OS_H_ */
+--- /dev/null
++++ b/drivers/mtd/mtk-snand/mtk-snand.c
+@@ -0,0 +1,1776 @@
++// SPDX-License-Identifier: GPL-2.0 OR BSD-3-Clause
++/*
++ * Copyright (C) 2020 MediaTek Inc. All Rights Reserved.
++ *
++ * Author: Weijie Gao <weijie.gao@mediatek.com>
++ */
++
++#include "mtk-snand-def.h"
++
++/* NFI registers */
++#define NFI_CNFG			0x000
++#define CNFG_OP_MODE_S			12
++#define   CNFG_OP_MODE_CUST		6
++#define   CNFG_OP_MODE_PROGRAM		3
++#define CNFG_AUTO_FMT_EN		BIT(9)
++#define CNFG_HW_ECC_EN			BIT(8)
++#define CNFG_DMA_BURST_EN		BIT(2)
++#define CNFG_READ_MODE			BIT(1)
++#define CNFG_DMA_MODE			BIT(0)
++
++#define NFI_PAGEFMT			0x0004
++#define NFI_SPARE_SIZE_LS_S		16
++#define NFI_FDM_ECC_NUM_S		12
++#define NFI_FDM_NUM_S			8
++#define NFI_SPARE_SIZE_S		4
++#define NFI_SEC_SEL_512			BIT(2)
++#define NFI_PAGE_SIZE_S			0
++#define   NFI_PAGE_SIZE_512_2K		0
++#define   NFI_PAGE_SIZE_2K_4K		1
++#define   NFI_PAGE_SIZE_4K_8K		2
++#define   NFI_PAGE_SIZE_8K_16K		3
++
++#define NFI_CON				0x008
++#define CON_SEC_NUM_S			12
++#define CON_BWR				BIT(9)
++#define CON_BRD				BIT(8)
++#define CON_NFI_RST			BIT(1)
++#define CON_FIFO_FLUSH			BIT(0)
++
++#define NFI_INTR_EN			0x010
++#define NFI_INTR_STA			0x014
++#define NFI_IRQ_INTR_EN			BIT(31)
++#define NFI_IRQ_CUS_READ		BIT(8)
++#define NFI_IRQ_CUS_PG			BIT(7)
++
++#define NFI_CMD				0x020
++
++#define NFI_STRDATA			0x040
++#define STR_DATA			BIT(0)
++
++#define NFI_STA				0x060
++#define NFI_NAND_FSM			GENMASK(28, 24)
++#define NFI_FSM				GENMASK(19, 16)
++#define READ_EMPTY			BIT(12)
++
++#define NFI_FIFOSTA			0x064
++#define FIFO_WR_REMAIN_S		8
++#define FIFO_RD_REMAIN_S		0
++
++#define NFI_STRADDR			0x080
++
++#define NFI_FDM0L			0x0a0
++#define NFI_FDM0M			0x0a4
++#define NFI_FDML(n)			(NFI_FDM0L + (n) * 8)
++#define NFI_FDMM(n)			(NFI_FDM0M + (n) * 8)
++
++#define NFI_DEBUG_CON1			0x220
++#define WBUF_EN				BIT(2)
++
++#define NFI_MASTERSTA			0x224
++#define MAS_ADDR			GENMASK(11, 9)
++#define MAS_RD				GENMASK(8, 6)
++#define MAS_WR				GENMASK(5, 3)
++#define MAS_RDDLY			GENMASK(2, 0)
++#define NFI_MASTERSTA_MASK_7622		(MAS_ADDR | MAS_RD | MAS_WR | MAS_RDDLY)
++#define AHB_BUS_BUSY			BIT(1)
++#define BUS_BUSY			BIT(0)
++#define NFI_MASTERSTA_MASK_7986		(AHB_BUS_BUSY | BUS_BUSY)
++
++/* SNFI registers */
++#define SNF_MAC_CTL			0x500
++#define MAC_XIO_SEL			BIT(4)
++#define SF_MAC_EN			BIT(3)
++#define SF_TRIG				BIT(2)
++#define WIP_READY			BIT(1)
++#define WIP				BIT(0)
++
++#define SNF_MAC_OUTL			0x504
++#define SNF_MAC_INL			0x508
++
++#define SNF_RD_CTL2			0x510
++#define DATA_READ_DUMMY_S		8
++#define DATA_READ_CMD_S			0
++
++#define SNF_RD_CTL3			0x514
++
++#define SNF_PG_CTL1			0x524
++#define PG_LOAD_CMD_S			8
++
++#define SNF_PG_CTL2			0x528
++
++#define SNF_MISC_CTL			0x538
++#define SW_RST				BIT(28)
++#define FIFO_RD_LTC_S			25
++#define PG_LOAD_X4_EN			BIT(20)
++#define DATA_READ_MODE_S		16
++#define DATA_READ_MODE			GENMASK(18, 16)
++#define   DATA_READ_MODE_X1		0
++#define   DATA_READ_MODE_X2		1
++#define   DATA_READ_MODE_X4		2
++#define   DATA_READ_MODE_DUAL		5
++#define   DATA_READ_MODE_QUAD		6
++#define PG_LOAD_CUSTOM_EN		BIT(7)
++#define DATARD_CUSTOM_EN		BIT(6)
++#define CS_DESELECT_CYC_S		0
++
++#define SNF_MISC_CTL2			0x53c
++#define PROGRAM_LOAD_BYTE_NUM_S		16
++#define READ_DATA_BYTE_NUM_S		11
++
++#define SNF_DLY_CTL3			0x548
++#define SFCK_SAM_DLY_S			0
++
++#define SNF_STA_CTL1			0x550
++#define CUS_PG_DONE			BIT(28)
++#define CUS_READ_DONE			BIT(27)
++#define SPI_STATE_S			0
++#define SPI_STATE			GENMASK(3, 0)
++
++#define SNF_CFG				0x55c
++#define SPI_MODE			BIT(0)
++
++#define SNF_GPRAM			0x800
++#define SNF_GPRAM_SIZE			0xa0
++
++#define SNFI_POLL_INTERVAL		1000000
++
++static const uint8_t mt7622_spare_sizes[] = { 16, 26, 27, 28 };
++
++static const uint8_t mt7986_spare_sizes[] = {
++	16, 26, 27, 28, 32, 36, 40, 44, 48, 49, 50, 51, 52, 62, 61, 63, 64,
++	67, 74
++};
++
++static const struct mtk_snand_soc_data mtk_snand_socs[__SNAND_SOC_MAX] = {
++	[SNAND_SOC_MT7622] = {
++		.sector_size = 512,
++		.max_sectors = 8,
++		.fdm_size = 8,
++		.fdm_ecc_size = 1,
++		.fifo_size = 32,
++		.bbm_swap = false,
++		.empty_page_check = false,
++		.mastersta_mask = NFI_MASTERSTA_MASK_7622,
++		.spare_sizes = mt7622_spare_sizes,
++		.num_spare_size = ARRAY_SIZE(mt7622_spare_sizes)
++	},
++	[SNAND_SOC_MT7629] = {
++		.sector_size = 512,
++		.max_sectors = 8,
++		.fdm_size = 8,
++		.fdm_ecc_size = 1,
++		.fifo_size = 32,
++		.bbm_swap = true,
++		.empty_page_check = false,
++		.mastersta_mask = NFI_MASTERSTA_MASK_7622,
++		.spare_sizes = mt7622_spare_sizes,
++		.num_spare_size = ARRAY_SIZE(mt7622_spare_sizes)
++	},
++	[SNAND_SOC_MT7986] = {
++		.sector_size = 1024,
++		.max_sectors = 16,
++		.fdm_size = 8,
++		.fdm_ecc_size = 1,
++		.fifo_size = 64,
++		.bbm_swap = true,
++		.empty_page_check = true,
++		.mastersta_mask = NFI_MASTERSTA_MASK_7986,
++		.spare_sizes = mt7986_spare_sizes,
++		.num_spare_size = ARRAY_SIZE(mt7986_spare_sizes)
++	},
++};
++
++static inline uint32_t nfi_read32(struct mtk_snand *snf, uint32_t reg)
++{
++	return readl(snf->nfi_base + reg);
++}
++
++static inline void nfi_write32(struct mtk_snand *snf, uint32_t reg,
++			       uint32_t val)
++{
++	writel(val, snf->nfi_base + reg);
++}
++
++static inline void nfi_write16(struct mtk_snand *snf, uint32_t reg,
++			       uint16_t val)
++{
++	writew(val, snf->nfi_base + reg);
++}
++
++static inline void nfi_rmw32(struct mtk_snand *snf, uint32_t reg, uint32_t clr,
++			     uint32_t set)
++{
++	uint32_t val;
++
++	val = readl(snf->nfi_base + reg);
++	val &= ~clr;
++	val |= set;
++	writel(val, snf->nfi_base + reg);
++}
++
++static void nfi_write_data(struct mtk_snand *snf, uint32_t reg,
++			   const uint8_t *data, uint32_t len)
++{
++	uint32_t i, val = 0, es = sizeof(uint32_t);
++
++	for (i = reg; i < reg + len; i++) {
++		val |= ((uint32_t)*data++) << (8 * (i % es));
++
++		if (i % es == es - 1 || i == reg + len - 1) {
++			nfi_write32(snf, i & ~(es - 1), val);
++			val = 0;
++		}
++	}
++}
++
++static void nfi_read_data(struct mtk_snand *snf, uint32_t reg, uint8_t *data,
++			  uint32_t len)
++{
++	uint32_t i, val = 0, es = sizeof(uint32_t);
++
++	for (i = reg; i < reg + len; i++) {
++		if (i == reg || i % es == 0)
++			val = nfi_read32(snf, i & ~(es - 1));
++
++		*data++ = (uint8_t)(val >> (8 * (i % es)));
++	}
++}
++
++static inline void do_bm_swap(uint8_t *bm1, uint8_t *bm2)
++{
++	uint8_t tmp = *bm1;
++	*bm1 = *bm2;
++	*bm2 = tmp;
++}
++
++static void mtk_snand_bm_swap_raw(struct mtk_snand *snf)
++{
++	uint32_t fdm_bbm_pos;
++
++	if (!snf->nfi_soc->bbm_swap || snf->ecc_steps == 1)
++		return;
++
++	fdm_bbm_pos = (snf->ecc_steps - 1) * snf->raw_sector_size +
++		      snf->nfi_soc->sector_size;
++	do_bm_swap(&snf->page_cache[fdm_bbm_pos],
++		   &snf->page_cache[snf->writesize]);
++}
++
++static void mtk_snand_bm_swap(struct mtk_snand *snf)
++{
++	uint32_t buf_bbm_pos, fdm_bbm_pos;
++
++	if (!snf->nfi_soc->bbm_swap || snf->ecc_steps == 1)
++		return;
++
++	buf_bbm_pos = snf->writesize -
++		      (snf->ecc_steps - 1) * snf->spare_per_sector;
++	fdm_bbm_pos = snf->writesize +
++		      (snf->ecc_steps - 1) * snf->nfi_soc->fdm_size;
++	do_bm_swap(&snf->page_cache[fdm_bbm_pos],
++		   &snf->page_cache[buf_bbm_pos]);
++}
++
++static void mtk_snand_fdm_bm_swap_raw(struct mtk_snand *snf)
++{
++	uint32_t fdm_bbm_pos1, fdm_bbm_pos2;
++
++	if (!snf->nfi_soc->bbm_swap || snf->ecc_steps == 1)
++		return;
++
++	fdm_bbm_pos1 = snf->nfi_soc->sector_size;
++	fdm_bbm_pos2 = (snf->ecc_steps - 1) * snf->raw_sector_size +
++		       snf->nfi_soc->sector_size;
++	do_bm_swap(&snf->page_cache[fdm_bbm_pos1],
++		   &snf->page_cache[fdm_bbm_pos2]);
++}
++
++static void mtk_snand_fdm_bm_swap(struct mtk_snand *snf)
++{
++	uint32_t fdm_bbm_pos1, fdm_bbm_pos2;
++
++	if (!snf->nfi_soc->bbm_swap || snf->ecc_steps == 1)
++		return;
++
++	fdm_bbm_pos1 = snf->writesize;
++	fdm_bbm_pos2 = snf->writesize +
++		       (snf->ecc_steps - 1) * snf->nfi_soc->fdm_size;
++	do_bm_swap(&snf->page_cache[fdm_bbm_pos1],
++		   &snf->page_cache[fdm_bbm_pos2]);
++}
++
++static int mtk_nfi_reset(struct mtk_snand *snf)
++{
++	uint32_t val, fifo_mask;
++	int ret;
++
++	nfi_write32(snf, NFI_CON, CON_FIFO_FLUSH | CON_NFI_RST);
++
++	ret = read16_poll_timeout(snf->nfi_base + NFI_MASTERSTA, val,
++				  !(val & snf->nfi_soc->mastersta_mask), 0,
++				  SNFI_POLL_INTERVAL);
++	if (ret) {
++		snand_log_nfi(snf->pdev,
++			      "NFI master is still busy after reset\n");
++		return ret;
++	}
++
++	ret = read32_poll_timeout(snf->nfi_base + NFI_STA, val,
++				  !(val & (NFI_FSM | NFI_NAND_FSM)), 0,
++				  SNFI_POLL_INTERVAL);
++	if (ret) {
++		snand_log_nfi(snf->pdev, "Failed to reset NFI\n");
++		return ret;
++	}
++
++	fifo_mask = ((snf->nfi_soc->fifo_size - 1) << FIFO_RD_REMAIN_S) |
++		    ((snf->nfi_soc->fifo_size - 1) << FIFO_WR_REMAIN_S);
++	ret = read16_poll_timeout(snf->nfi_base + NFI_FIFOSTA, val,
++				  !(val & fifo_mask), 0, SNFI_POLL_INTERVAL);
++	if (ret) {
++		snand_log_nfi(snf->pdev, "NFI FIFOs are not empty\n");
++		return ret;
++	}
++
++	return 0;
++}
++
++static int mtk_snand_mac_reset(struct mtk_snand *snf)
++{
++	int ret;
++	uint32_t val;
++
++	nfi_rmw32(snf, SNF_MISC_CTL, 0, SW_RST);
++
++	ret = read32_poll_timeout(snf->nfi_base + SNF_STA_CTL1, val,
++				  !(val & SPI_STATE), 0, SNFI_POLL_INTERVAL);
++	if (ret)
++		snand_log_snfi(snf->pdev, "Failed to reset SNFI MAC\n");
++
++	nfi_write32(snf, SNF_MISC_CTL, (2 << FIFO_RD_LTC_S) |
++		    (10 << CS_DESELECT_CYC_S));
++
++	return ret;
++}
++
++static int mtk_snand_mac_trigger(struct mtk_snand *snf, uint32_t outlen,
++				 uint32_t inlen)
++{
++	int ret;
++	uint32_t val;
++
++	nfi_write32(snf, SNF_MAC_CTL, SF_MAC_EN);
++	nfi_write32(snf, SNF_MAC_OUTL, outlen);
++	nfi_write32(snf, SNF_MAC_INL, inlen);
++
++	nfi_write32(snf, SNF_MAC_CTL, SF_MAC_EN | SF_TRIG);
++
++	ret = read32_poll_timeout(snf->nfi_base + SNF_MAC_CTL, val,
++				  val & WIP_READY, 0, SNFI_POLL_INTERVAL);
++	if (ret) {
++		snand_log_snfi(snf->pdev, "Timed out waiting for WIP_READY\n");
++		goto cleanup;
++	}
++
++	ret = read32_poll_timeout(snf->nfi_base + SNF_MAC_CTL, val,
++				  !(val & WIP), 0, SNFI_POLL_INTERVAL);
++	if (ret) {
++		snand_log_snfi(snf->pdev,
++			       "Timed out waiting for WIP cleared\n");
++	}
++
++cleanup:
++	nfi_write32(snf, SNF_MAC_CTL, 0);
++
++	return ret;
++}
++
++int mtk_snand_mac_io(struct mtk_snand *snf, const uint8_t *out, uint32_t outlen,
++		     uint8_t *in, uint32_t inlen)
++{
++	int ret;
++
++	if (outlen + inlen > SNF_GPRAM_SIZE)
++		return -EINVAL;
++
++	mtk_snand_mac_reset(snf);
++
++	nfi_write_data(snf, SNF_GPRAM, out, outlen);
++
++	ret = mtk_snand_mac_trigger(snf, outlen, inlen);
++	if (ret)
++		return ret;
++
++	if (!inlen)
++		return 0;
++
++	nfi_read_data(snf, SNF_GPRAM + outlen, in, inlen);
++
++	return 0;
++}
++
++static int mtk_snand_get_feature(struct mtk_snand *snf, uint32_t addr)
++{
++	uint8_t op[2], val;
++	int ret;
++
++	op[0] = SNAND_CMD_GET_FEATURE;
++	op[1] = (uint8_t)addr;
++
++	ret = mtk_snand_mac_io(snf, op, sizeof(op), &val, 1);
++	if (ret)
++		return ret;
++
++	return val;
++}
++
++int mtk_snand_set_feature(struct mtk_snand *snf, uint32_t addr, uint32_t val)
++{
++	uint8_t op[3];
++
++	op[0] = SNAND_CMD_SET_FEATURE;
++	op[1] = (uint8_t)addr;
++	op[2] = (uint8_t)val;
++
++	return mtk_snand_mac_io(snf, op, sizeof(op), NULL, 0);
++}
++
++static int mtk_snand_poll_status(struct mtk_snand *snf, uint32_t wait_us)
++{
++	int val;
++	mtk_snand_time_t time_start, tmo;
++
++	time_start = timer_get_ticks();
++	tmo = timer_time_to_tick(wait_us);
++
++	do {
++		val = mtk_snand_get_feature(snf, SNAND_FEATURE_STATUS_ADDR);
++		if (!(val & SNAND_STATUS_OIP))
++			return val & (SNAND_STATUS_ERASE_FAIL |
++				      SNAND_STATUS_PROGRAM_FAIL);
++	} while (!timer_is_timeout(time_start, tmo));
++
++	return -ETIMEDOUT;
++}
++
++int mtk_snand_chip_reset(struct mtk_snand *snf)
++{
++	uint8_t op = SNAND_CMD_RESET;
++	int ret;
++
++	ret = mtk_snand_mac_io(snf, &op, 1, NULL, 0);
++	if (ret)
++		return ret;
++
++	ret = mtk_snand_poll_status(snf, SNFI_POLL_INTERVAL);
++	if (ret < 0)
++		return ret;
++
++	return 0;
++}
++
++static int mtk_snand_config_feature(struct mtk_snand *snf, uint8_t clr,
++				    uint8_t set)
++{
++	int val, newval;
++	int ret;
++
++	val = mtk_snand_get_feature(snf, SNAND_FEATURE_CONFIG_ADDR);
++	if (val < 0) {
++		snand_log_chip(snf->pdev,
++			       "Failed to get configuration feature\n");
++		return val;
++	}
++
++	newval = (val & (~clr)) | set;
++
++	if (newval == val)
++		return 0;
++
++	ret = mtk_snand_set_feature(snf, SNAND_FEATURE_CONFIG_ADDR,
++				    (uint8_t)newval);
++	if (val < 0) {
++		snand_log_chip(snf->pdev,
++			       "Failed to set configuration feature\n");
++		return ret;
++	}
++
++	val = mtk_snand_get_feature(snf, SNAND_FEATURE_CONFIG_ADDR);
++	if (val < 0) {
++		snand_log_chip(snf->pdev,
++			       "Failed to get configuration feature\n");
++		return val;
++	}
++
++	if (newval != val)
++		return -ENOTSUPP;
++
++	return 0;
++}
++
++static int mtk_snand_ondie_ecc_control(struct mtk_snand *snf, bool enable)
++{
++	int ret;
++
++	if (enable)
++		ret = mtk_snand_config_feature(snf, 0, SNAND_FEATURE_ECC_EN);
++	else
++		ret = mtk_snand_config_feature(snf, SNAND_FEATURE_ECC_EN, 0);
++
++	if (ret) {
++		snand_log_chip(snf->pdev, "Failed to %s On-Die ECC engine\n",
++			       enable ? "enable" : "disable");
++	}
++
++	return ret;
++}
++
++static int mtk_snand_qspi_control(struct mtk_snand *snf, bool enable)
++{
++	int ret;
++
++	if (enable) {
++		ret = mtk_snand_config_feature(snf, 0,
++					       SNAND_FEATURE_QUAD_ENABLE);
++	} else {
++		ret = mtk_snand_config_feature(snf,
++					       SNAND_FEATURE_QUAD_ENABLE, 0);
++	}
++
++	if (ret) {
++		snand_log_chip(snf->pdev, "Failed to %s quad spi\n",
++			       enable ? "enable" : "disable");
++	}
++
++	return ret;
++}
++
++static int mtk_snand_unlock(struct mtk_snand *snf)
++{
++	int ret;
++
++	ret = mtk_snand_set_feature(snf, SNAND_FEATURE_PROTECT_ADDR, 0);
++	if (ret) {
++		snand_log_chip(snf->pdev, "Failed to set protection feature\n");
++		return ret;
++	}
++
++	return 0;
++}
++
++static int mtk_snand_write_enable(struct mtk_snand *snf)
++{
++	uint8_t op = SNAND_CMD_WRITE_ENABLE;
++	int ret, val;
++
++	ret = mtk_snand_mac_io(snf, &op, 1, NULL, 0);
++	if (ret)
++		return ret;
++
++	val = mtk_snand_get_feature(snf, SNAND_FEATURE_STATUS_ADDR);
++	if (val < 0)
++		return ret;
++
++	if (val & SNAND_STATUS_WEL)
++		return 0;
++
++	snand_log_chip(snf->pdev, "Failed to send write-enable command\n");
++
++	return -ENOTSUPP;
++}
++
++static int mtk_snand_select_die(struct mtk_snand *snf, uint32_t dieidx)
++{
++	if (!snf->select_die)
++		return 0;
++
++	return snf->select_die(snf, dieidx);
++}
++
++static uint64_t mtk_snand_select_die_address(struct mtk_snand *snf,
++					     uint64_t addr)
++{
++	uint32_t dieidx;
++
++	if (!snf->select_die)
++		return addr;
++
++	dieidx = addr >> snf->die_shift;
++
++	mtk_snand_select_die(snf, dieidx);
++
++	return addr & snf->die_mask;
++}
++
++static uint32_t mtk_snand_get_plane_address(struct mtk_snand *snf,
++					    uint32_t page)
++{
++	uint32_t pages_per_block;
++
++	pages_per_block = 1 << (snf->erasesize_shift - snf->writesize_shift);
++
++	if (page & pages_per_block)
++		return 1 << (snf->writesize_shift + 1);
++
++	return 0;
++}
++
++static int mtk_snand_page_op(struct mtk_snand *snf, uint32_t page, uint8_t cmd)
++{
++	uint8_t op[4];
++
++	op[0] = cmd;
++	op[1] = (page >> 16) & 0xff;
++	op[2] = (page >> 8) & 0xff;
++	op[3] = page & 0xff;
++
++	return mtk_snand_mac_io(snf, op, sizeof(op), NULL, 0);
++}
++
++static void mtk_snand_read_fdm(struct mtk_snand *snf, uint8_t *buf)
++{
++	uint32_t vall, valm;
++	uint8_t *oobptr = buf;
++	int i, j;
++
++	for (i = 0; i < snf->ecc_steps; i++) {
++		vall = nfi_read32(snf, NFI_FDML(i));
++		valm = nfi_read32(snf, NFI_FDMM(i));
++
++		for (j = 0; j < snf->nfi_soc->fdm_size; j++)
++			oobptr[j] = (j >= 4 ? valm : vall) >> ((j % 4) * 8);
++
++		oobptr += snf->nfi_soc->fdm_size;
++	}
++}
++
++static int mtk_snand_read_cache(struct mtk_snand *snf, uint32_t page, bool raw)
++{
++	uint32_t coladdr, rwbytes, mode, len;
++	uintptr_t dma_addr;
++	int ret;
++
++	/* Column address with plane bit */
++	coladdr = mtk_snand_get_plane_address(snf, page);
++
++	mtk_snand_mac_reset(snf);
++	mtk_nfi_reset(snf);
++
++	/* Command and dummy cycles */
++	nfi_write32(snf, SNF_RD_CTL2,
++		    ((uint32_t)snf->dummy_rfc << DATA_READ_DUMMY_S) |
++		    (snf->opcode_rfc << DATA_READ_CMD_S));
++
++	/* Column address */
++	nfi_write32(snf, SNF_RD_CTL3, coladdr);
++
++	/* Set read mode */
++	mode = (uint32_t)snf->mode_rfc << DATA_READ_MODE_S;
++	nfi_rmw32(snf, SNF_MISC_CTL, DATA_READ_MODE, mode | DATARD_CUSTOM_EN);
++
++	/* Set bytes to read */
++	rwbytes = snf->ecc_steps * snf->raw_sector_size;
++	nfi_write32(snf, SNF_MISC_CTL2, (rwbytes << PROGRAM_LOAD_BYTE_NUM_S) |
++		    rwbytes);
++
++	/* NFI read prepare */
++	mode = raw ? 0 : CNFG_HW_ECC_EN | CNFG_AUTO_FMT_EN;
++	nfi_write16(snf, NFI_CNFG, (CNFG_OP_MODE_CUST << CNFG_OP_MODE_S) |
++		    CNFG_DMA_BURST_EN | CNFG_READ_MODE | CNFG_DMA_MODE | mode);
++
++	nfi_write32(snf, NFI_CON, (snf->ecc_steps << CON_SEC_NUM_S));
++
++	/* Prepare for DMA read */
++	len = snf->writesize + snf->oobsize;
++	ret = dma_mem_map(snf->pdev, snf->page_cache, &dma_addr, len, false);
++	if (ret) {
++		snand_log_nfi(snf->pdev,
++			      "DMA map from device failed with %d\n", ret);
++		return ret;
++	}
++
++	nfi_write32(snf, NFI_STRADDR, (uint32_t)dma_addr);
++
++	if (!raw)
++		mtk_snand_ecc_decoder_start(snf);
++
++	/* Prepare for custom read interrupt */
++	nfi_write32(snf, NFI_INTR_EN, NFI_IRQ_INTR_EN | NFI_IRQ_CUS_READ);
++	irq_completion_init(snf->pdev);
++
++	/* Trigger NFI into custom mode */
++	nfi_write16(snf, NFI_CMD, NFI_CMD_DUMMY_READ);
++
++	/* Start DMA read */
++	nfi_rmw32(snf, NFI_CON, 0, CON_BRD);
++	nfi_write16(snf, NFI_STRDATA, STR_DATA);
++
++	/* Wait for operation finished */
++	ret = irq_completion_wait(snf->pdev, snf->nfi_base + SNF_STA_CTL1,
++				  CUS_READ_DONE, SNFI_POLL_INTERVAL);
++	if (ret) {
++		snand_log_nfi(snf->pdev,
++			      "DMA timed out for reading from cache\n");
++		goto cleanup;
++	}
++
++	if (!raw) {
++		ret = mtk_ecc_wait_decoder_done(snf);
++		if (ret)
++			goto cleanup;
++
++		mtk_snand_read_fdm(snf, snf->page_cache + snf->writesize);
++
++		/*
++		 * For new IPs, ecc error may occur on empty pages.
++		 * Use an specific indication bit to check empty page.
++		 */
++		if (snf->nfi_soc->empty_page_check &&
++		    (nfi_read32(snf, NFI_STA) & READ_EMPTY))
++			ret = 0;
++		else
++			ret = mtk_ecc_check_decode_error(snf, page);
++
++		mtk_snand_ecc_decoder_stop(snf);
++	}
++
++cleanup:
++	/* DMA cleanup */
++	dma_mem_unmap(snf->pdev, dma_addr, len, false);
++
++	/* Stop read */
++	nfi_write32(snf, NFI_CON, 0);
++
++	/* Clear SNF done flag */
++	nfi_rmw32(snf, SNF_STA_CTL1, 0, CUS_READ_DONE);
++	nfi_write32(snf, SNF_STA_CTL1, 0);
++
++	/* Disable interrupt */
++	nfi_read32(snf, NFI_INTR_STA);
++	nfi_write32(snf, NFI_INTR_EN, 0);
++
++	nfi_rmw32(snf, SNF_MISC_CTL, DATARD_CUSTOM_EN, 0);
++
++	return ret;
++}
++
++static void mtk_snand_from_raw_page(struct mtk_snand *snf, void *buf, void *oob)
++{
++	uint32_t i, ecc_bytes = snf->spare_per_sector - snf->nfi_soc->fdm_size;
++	uint8_t *eccptr = oob + snf->ecc_steps * snf->nfi_soc->fdm_size;
++	uint8_t *bufptr = buf, *oobptr = oob, *raw_sector;
++
++	for (i = 0; i < snf->ecc_steps; i++) {
++		raw_sector = snf->page_cache + i * snf->raw_sector_size;
++
++		if (buf) {
++			memcpy(bufptr, raw_sector, snf->nfi_soc->sector_size);
++			bufptr += snf->nfi_soc->sector_size;
++		}
++
++		raw_sector += snf->nfi_soc->sector_size;
++
++		if (oob) {
++			memcpy(oobptr, raw_sector, snf->nfi_soc->fdm_size);
++			oobptr += snf->nfi_soc->fdm_size;
++			raw_sector += snf->nfi_soc->fdm_size;
++
++			memcpy(eccptr, raw_sector, ecc_bytes);
++			eccptr += ecc_bytes;
++		}
++	}
++}
++
++static int mtk_snand_do_read_page(struct mtk_snand *snf, uint64_t addr,
++				  void *buf, void *oob, bool raw, bool format)
++{
++	uint64_t die_addr;
++	uint32_t page;
++	int ret;
++
++	die_addr = mtk_snand_select_die_address(snf, addr);
++	page = die_addr >> snf->writesize_shift;
++
++	ret = mtk_snand_page_op(snf, page, SNAND_CMD_READ_TO_CACHE);
++	if (ret)
++		return ret;
++
++	ret = mtk_snand_poll_status(snf, SNFI_POLL_INTERVAL);
++	if (ret < 0) {
++		snand_log_chip(snf->pdev, "Read to cache command timed out\n");
++		return ret;
++	}
++
++	ret = mtk_snand_read_cache(snf, page, raw);
++	if (ret < 0 && ret != -EBADMSG)
++		return ret;
++
++	if (raw) {
++		if (format) {
++			mtk_snand_bm_swap_raw(snf);
++			mtk_snand_fdm_bm_swap_raw(snf);
++			mtk_snand_from_raw_page(snf, buf, oob);
++		} else {
++			if (buf)
++				memcpy(buf, snf->page_cache, snf->writesize);
++
++			if (oob) {
++				memset(oob, 0xff, snf->oobsize);
++				memcpy(oob, snf->page_cache + snf->writesize,
++				       snf->ecc_steps * snf->spare_per_sector);
++			}
++		}
++	} else {
++		mtk_snand_bm_swap(snf);
++		mtk_snand_fdm_bm_swap(snf);
++
++		if (buf)
++			memcpy(buf, snf->page_cache, snf->writesize);
++
++		if (oob) {
++			memset(oob, 0xff, snf->oobsize);
++			memcpy(oob, snf->page_cache + snf->writesize,
++			       snf->ecc_steps * snf->nfi_soc->fdm_size);
++		}
++	}
++
++	return ret;
++}
++
++int mtk_snand_read_page(struct mtk_snand *snf, uint64_t addr, void *buf,
++			void *oob, bool raw)
++{
++	if (!snf || (!buf && !oob))
++		return -EINVAL;
++
++	if (addr >= snf->size)
++		return -EINVAL;
++
++	return mtk_snand_do_read_page(snf, addr, buf, oob, raw, true);
++}
++
++static void mtk_snand_write_fdm(struct mtk_snand *snf, const uint8_t *buf)
++{
++	uint32_t vall, valm, fdm_size = snf->nfi_soc->fdm_size;
++	const uint8_t *oobptr = buf;
++	int i, j;
++
++	for (i = 0; i < snf->ecc_steps; i++) {
++		vall = 0;
++		valm = 0;
++
++		for (j = 0; j < 8; j++) {
++			if (j < 4)
++				vall |= (j < fdm_size ? oobptr[j] : 0xff)
++						<< (j * 8);
++			else
++				valm |= (j < fdm_size ? oobptr[j] : 0xff)
++						<< ((j - 4) * 8);
++		}
++
++		nfi_write32(snf, NFI_FDML(i), vall);
++		nfi_write32(snf, NFI_FDMM(i), valm);
++
++		oobptr += fdm_size;
++	}
++}
++
++static int mtk_snand_program_load(struct mtk_snand *snf, uint32_t page,
++				  bool raw)
++{
++	uint32_t coladdr, rwbytes, mode, len;
++	uintptr_t dma_addr;
++	int ret;
++
++	/* Column address with plane bit */
++	coladdr = mtk_snand_get_plane_address(snf, page);
++
++	mtk_snand_mac_reset(snf);
++	mtk_nfi_reset(snf);
++
++	/* Write FDM registers if necessary */
++	if (!raw)
++		mtk_snand_write_fdm(snf, snf->page_cache + snf->writesize);
++
++	/* Command */
++	nfi_write32(snf, SNF_PG_CTL1, (snf->opcode_pl << PG_LOAD_CMD_S));
++
++	/* Column address */
++	nfi_write32(snf, SNF_PG_CTL2, coladdr);
++
++	/* Set write mode */
++	mode = snf->mode_pl ? PG_LOAD_X4_EN : 0;
++	nfi_rmw32(snf, SNF_MISC_CTL, PG_LOAD_X4_EN, mode | PG_LOAD_CUSTOM_EN);
++
++	/* Set bytes to write */
++	rwbytes = snf->ecc_steps * snf->raw_sector_size;
++	nfi_write32(snf, SNF_MISC_CTL2, (rwbytes << PROGRAM_LOAD_BYTE_NUM_S) |
++		    rwbytes);
++
++	/* NFI write prepare */
++	mode = raw ? 0 : CNFG_HW_ECC_EN | CNFG_AUTO_FMT_EN;
++	nfi_write16(snf, NFI_CNFG, (CNFG_OP_MODE_PROGRAM << CNFG_OP_MODE_S) |
++		    CNFG_DMA_BURST_EN | CNFG_DMA_MODE | mode);
++
++	nfi_write32(snf, NFI_CON, (snf->ecc_steps << CON_SEC_NUM_S));
++
++	/* Prepare for DMA write */
++	len = snf->writesize + snf->oobsize;
++	ret = dma_mem_map(snf->pdev, snf->page_cache, &dma_addr, len, true);
++	if (ret) {
++		snand_log_nfi(snf->pdev,
++			      "DMA map to device failed with %d\n", ret);
++		return ret;
++	}
++
++	nfi_write32(snf, NFI_STRADDR, (uint32_t)dma_addr);
++
++	if (!raw)
++		mtk_snand_ecc_encoder_start(snf);
++
++	/* Prepare for custom write interrupt */
++	nfi_write32(snf, NFI_INTR_EN, NFI_IRQ_INTR_EN | NFI_IRQ_CUS_PG);
++	irq_completion_init(snf->pdev);
++
++	/* Trigger NFI into custom mode */
++	nfi_write16(snf, NFI_CMD, NFI_CMD_DUMMY_WRITE);
++
++	/* Start DMA write */
++	nfi_rmw32(snf, NFI_CON, 0, CON_BWR);
++	nfi_write16(snf, NFI_STRDATA, STR_DATA);
++
++	/* Wait for operation finished */
++	ret = irq_completion_wait(snf->pdev, snf->nfi_base + SNF_STA_CTL1,
++				  CUS_PG_DONE, SNFI_POLL_INTERVAL);
++	if (ret) {
++		snand_log_nfi(snf->pdev,
++			      "DMA timed out for program load\n");
++		goto cleanup;
++	}
++
++	if (!raw)
++		mtk_snand_ecc_encoder_stop(snf);
++
++cleanup:
++	/* DMA cleanup */
++	dma_mem_unmap(snf->pdev, dma_addr, len, true);
++
++	/* Stop write */
++	nfi_write16(snf, NFI_CON, 0);
++
++	/* Clear SNF done flag */
++	nfi_rmw32(snf, SNF_STA_CTL1, 0, CUS_PG_DONE);
++	nfi_write32(snf, SNF_STA_CTL1, 0);
++
++	/* Disable interrupt */
++	nfi_read32(snf, NFI_INTR_STA);
++	nfi_write32(snf, NFI_INTR_EN, 0);
++
++	nfi_rmw32(snf, SNF_MISC_CTL, PG_LOAD_CUSTOM_EN, 0);
++
++	return ret;
++}
++
++static void mtk_snand_to_raw_page(struct mtk_snand *snf,
++				  const void *buf, const void *oob,
++				  bool empty_ecc)
++{
++	uint32_t i, ecc_bytes = snf->spare_per_sector - snf->nfi_soc->fdm_size;
++	const uint8_t *eccptr = oob + snf->ecc_steps * snf->nfi_soc->fdm_size;
++	const uint8_t *bufptr = buf, *oobptr = oob;
++	uint8_t *raw_sector;
++
++	memset(snf->page_cache, 0xff, snf->writesize + snf->oobsize);
++	for (i = 0; i < snf->ecc_steps; i++) {
++		raw_sector = snf->page_cache + i * snf->raw_sector_size;
++
++		if (buf) {
++			memcpy(raw_sector, bufptr, snf->nfi_soc->sector_size);
++			bufptr += snf->nfi_soc->sector_size;
++		}
++
++		raw_sector += snf->nfi_soc->sector_size;
++
++		if (oob) {
++			memcpy(raw_sector, oobptr, snf->nfi_soc->fdm_size);
++			oobptr += snf->nfi_soc->fdm_size;
++			raw_sector += snf->nfi_soc->fdm_size;
++
++			if (empty_ecc)
++				memset(raw_sector, 0xff, ecc_bytes);
++			else
++				memcpy(raw_sector, eccptr, ecc_bytes);
++			eccptr += ecc_bytes;
++		}
++	}
++}
++
++static bool mtk_snand_is_empty_page(struct mtk_snand *snf, const void *buf,
++				    const void *oob)
++{
++	const uint8_t *p = buf;
++	uint32_t i, j;
++
++	if (buf) {
++		for (i = 0; i < snf->writesize; i++) {
++			if (p[i] != 0xff)
++				return false;
++		}
++	}
++
++	if (oob) {
++		for (j = 0; j < snf->ecc_steps; j++) {
++			p = oob + j * snf->nfi_soc->fdm_size;
++
++			for (i = 0; i < snf->nfi_soc->fdm_ecc_size; i++) {
++				if (p[i] != 0xff)
++					return false;
++			}
++		}
++	}
++
++	return true;
++}
++
++static int mtk_snand_do_write_page(struct mtk_snand *snf, uint64_t addr,
++				   const void *buf, const void *oob,
++				   bool raw, bool format)
++{
++	uint64_t die_addr;
++	bool empty_ecc = false;
++	uint32_t page;
++	int ret;
++
++	die_addr = mtk_snand_select_die_address(snf, addr);
++	page = die_addr >> snf->writesize_shift;
++
++	if (!raw && mtk_snand_is_empty_page(snf, buf, oob)) {
++		/*
++		 * If the data in the page to be ecc-ed is full 0xff,
++		 * change to raw write mode
++		 */
++		raw = true;
++		format = true;
++
++		/* fill ecc parity code region with 0xff */
++		empty_ecc = true;
++	}
++
++	if (raw) {
++		if (format) {
++			mtk_snand_to_raw_page(snf, buf, oob, empty_ecc);
++			mtk_snand_fdm_bm_swap_raw(snf);
++			mtk_snand_bm_swap_raw(snf);
++		} else {
++			memset(snf->page_cache, 0xff,
++			       snf->writesize + snf->oobsize);
++
++			if (buf)
++				memcpy(snf->page_cache, buf, snf->writesize);
++
++			if (oob) {
++				memcpy(snf->page_cache + snf->writesize, oob,
++				       snf->ecc_steps * snf->spare_per_sector);
++			}
++		}
++	} else {
++		memset(snf->page_cache, 0xff, snf->writesize + snf->oobsize);
++		if (buf)
++			memcpy(snf->page_cache, buf, snf->writesize);
++
++		if (oob) {
++			memcpy(snf->page_cache + snf->writesize, oob,
++			       snf->ecc_steps * snf->nfi_soc->fdm_size);
++		}
++
++		mtk_snand_fdm_bm_swap(snf);
++		mtk_snand_bm_swap(snf);
++	}
++
++	ret = mtk_snand_write_enable(snf);
++	if (ret)
++		return ret;
++
++	ret = mtk_snand_program_load(snf, page, raw);
++	if (ret)
++		return ret;
++
++	ret = mtk_snand_page_op(snf, page, SNAND_CMD_PROGRAM_EXECUTE);
++	if (ret)
++		return ret;
++
++	ret = mtk_snand_poll_status(snf, SNFI_POLL_INTERVAL);
++	if (ret < 0) {
++		snand_log_chip(snf->pdev,
++			       "Page program command timed out on page %u\n",
++			       page);
++		return ret;
++	}
++
++	if (ret & SNAND_STATUS_PROGRAM_FAIL) {
++		snand_log_chip(snf->pdev,
++			       "Page program failed on page %u\n", page);
++		return -EIO;
++	}
++
++	return 0;
++}
++
++int mtk_snand_write_page(struct mtk_snand *snf, uint64_t addr, const void *buf,
++			 const void *oob, bool raw)
++{
++	if (!snf || (!buf && !oob))
++		return -EINVAL;
++
++	if (addr >= snf->size)
++		return -EINVAL;
++
++	return mtk_snand_do_write_page(snf, addr, buf, oob, raw, true);
++}
++
++int mtk_snand_erase_block(struct mtk_snand *snf, uint64_t addr)
++{
++	uint64_t die_addr;
++	uint32_t page, block;
++	int ret;
++
++	if (!snf)
++		return -EINVAL;
++
++	if (addr >= snf->size)
++		return -EINVAL;
++
++	die_addr = mtk_snand_select_die_address(snf, addr);
++	block = die_addr >> snf->erasesize_shift;
++	page = block << (snf->erasesize_shift - snf->writesize_shift);
++
++	ret = mtk_snand_write_enable(snf);
++	if (ret)
++		return ret;
++
++	ret = mtk_snand_page_op(snf, page, SNAND_CMD_BLOCK_ERASE);
++	if (ret)
++		return ret;
++
++	ret = mtk_snand_poll_status(snf, SNFI_POLL_INTERVAL);
++	if (ret < 0) {
++		snand_log_chip(snf->pdev,
++			       "Block erase command timed out on block %u\n",
++			       block);
++		return ret;
++	}
++
++	if (ret & SNAND_STATUS_ERASE_FAIL) {
++		snand_log_chip(snf->pdev,
++			       "Block erase failed on block %u\n", block);
++		return -EIO;
++	}
++
++	return 0;
++}
++
++static int mtk_snand_block_isbad_std(struct mtk_snand *snf, uint64_t addr)
++{
++	int ret;
++
++	ret = mtk_snand_do_read_page(snf, addr, NULL, snf->buf_cache, true,
++				     false);
++	if (ret && ret != -EBADMSG)
++		return ret;
++
++	return snf->buf_cache[0] != 0xff;
++}
++
++static int mtk_snand_block_isbad_mtk(struct mtk_snand *snf, uint64_t addr)
++{
++	int ret;
++
++	ret = mtk_snand_do_read_page(snf, addr, NULL, snf->buf_cache, true,
++				     true);
++	if (ret && ret != -EBADMSG)
++		return ret;
++
++	return snf->buf_cache[0] != 0xff;
++}
++
++int mtk_snand_block_isbad(struct mtk_snand *snf, uint64_t addr)
++{
++	if (!snf)
++		return -EINVAL;
++
++	if (addr >= snf->size)
++		return -EINVAL;
++
++	addr &= ~snf->erasesize_mask;
++
++	if (snf->nfi_soc->bbm_swap)
++		return mtk_snand_block_isbad_std(snf, addr);
++
++	return mtk_snand_block_isbad_mtk(snf, addr);
++}
++
++static int mtk_snand_block_markbad_std(struct mtk_snand *snf, uint64_t addr)
++{
++	/* Standard BBM position */
++	memset(snf->buf_cache, 0xff, snf->oobsize);
++	snf->buf_cache[0] = 0;
++
++	return mtk_snand_do_write_page(snf, addr, NULL, snf->buf_cache, true,
++				       false);
++}
++
++static int mtk_snand_block_markbad_mtk(struct mtk_snand *snf, uint64_t addr)
++{
++	/* Write the whole page with zeros */
++	memset(snf->buf_cache, 0, snf->writesize + snf->oobsize);
++
++	return mtk_snand_do_write_page(snf, addr, snf->buf_cache,
++				       snf->buf_cache + snf->writesize, true,
++				       true);
++}
++
++int mtk_snand_block_markbad(struct mtk_snand *snf, uint64_t addr)
++{
++	if (!snf)
++		return -EINVAL;
++
++	if (addr >= snf->size)
++		return -EINVAL;
++
++	addr &= ~snf->erasesize_mask;
++
++	if (snf->nfi_soc->bbm_swap)
++		return mtk_snand_block_markbad_std(snf, addr);
++
++	return mtk_snand_block_markbad_mtk(snf, addr);
++}
++
++int mtk_snand_fill_oob(struct mtk_snand *snf, uint8_t *oobraw,
++		       const uint8_t *oobbuf, size_t ooblen)
++{
++	size_t len = ooblen, sect_fdm_len;
++	const uint8_t *oob = oobbuf;
++	uint32_t step = 0;
++
++	if (!snf || !oobraw || !oob)
++		return -EINVAL;
++
++	while (len && step < snf->ecc_steps) {
++		sect_fdm_len = snf->nfi_soc->fdm_size - 1;
++		if (sect_fdm_len > len)
++			sect_fdm_len = len;
++
++		memcpy(oobraw + step * snf->nfi_soc->fdm_size + 1, oob,
++		       sect_fdm_len);
++
++		len -= sect_fdm_len;
++		oob += sect_fdm_len;
++		step++;
++	}
++
++	return len;
++}
++
++int mtk_snand_transfer_oob(struct mtk_snand *snf, uint8_t *oobbuf,
++			   size_t ooblen, const uint8_t *oobraw)
++{
++	size_t len = ooblen, sect_fdm_len;
++	uint8_t *oob = oobbuf;
++	uint32_t step = 0;
++
++	if (!snf || !oobraw || !oob)
++		return -EINVAL;
++
++	while (len && step < snf->ecc_steps) {
++		sect_fdm_len = snf->nfi_soc->fdm_size - 1;
++		if (sect_fdm_len > len)
++			sect_fdm_len = len;
++
++		memcpy(oob, oobraw + step * snf->nfi_soc->fdm_size + 1,
++		       sect_fdm_len);
++
++		len -= sect_fdm_len;
++		oob += sect_fdm_len;
++		step++;
++	}
++
++	return len;
++}
++
++int mtk_snand_read_page_auto_oob(struct mtk_snand *snf, uint64_t addr,
++				 void *buf, void *oob, size_t ooblen,
++				 size_t *actualooblen, bool raw)
++{
++	int ret, oobremain;
++
++	if (!snf)
++		return -EINVAL;
++
++	if (!oob)
++		return mtk_snand_read_page(snf, addr, buf, NULL, raw);
++
++	ret = mtk_snand_read_page(snf, addr, buf, snf->buf_cache, raw);
++	if (ret && ret != -EBADMSG) {
++		if (actualooblen)
++			*actualooblen = 0;
++		return ret;
++	}
++
++	oobremain = mtk_snand_transfer_oob(snf, oob, ooblen, snf->buf_cache);
++	if (actualooblen)
++		*actualooblen = ooblen - oobremain;
++
++	return ret;
++}
++
++int mtk_snand_write_page_auto_oob(struct mtk_snand *snf, uint64_t addr,
++				  const void *buf, const void *oob,
++				  size_t ooblen, size_t *actualooblen, bool raw)
++{
++	int oobremain;
++
++	if (!snf)
++		return -EINVAL;
++
++	if (!oob)
++		return mtk_snand_write_page(snf, addr, buf, NULL, raw);
++
++	memset(snf->buf_cache, 0xff, snf->oobsize);
++	oobremain = mtk_snand_fill_oob(snf, snf->buf_cache, oob, ooblen);
++	if (actualooblen)
++		*actualooblen = ooblen - oobremain;
++
++	return mtk_snand_write_page(snf, addr, buf, snf->buf_cache, raw);
++}
++
++int mtk_snand_get_chip_info(struct mtk_snand *snf,
++			    struct mtk_snand_chip_info *info)
++{
++	if (!snf || !info)
++		return -EINVAL;
++
++	info->model = snf->model;
++	info->chipsize = snf->size;
++	info->blocksize = snf->erasesize;
++	info->pagesize = snf->writesize;
++	info->sparesize = snf->oobsize;
++	info->spare_per_sector = snf->spare_per_sector;
++	info->fdm_size = snf->nfi_soc->fdm_size;
++	info->fdm_ecc_size = snf->nfi_soc->fdm_ecc_size;
++	info->num_sectors = snf->ecc_steps;
++	info->sector_size = snf->nfi_soc->sector_size;
++	info->ecc_strength = snf->ecc_strength;
++	info->ecc_bytes = snf->ecc_bytes;
++
++	return 0;
++}
++
++int mtk_snand_irq_process(struct mtk_snand *snf)
++{
++	uint32_t sta, ien;
++
++	if (!snf)
++		return -EINVAL;
++
++	sta = nfi_read32(snf, NFI_INTR_STA);
++	ien = nfi_read32(snf, NFI_INTR_EN);
++
++	if (!(sta & ien))
++		return 0;
++
++	nfi_write32(snf, NFI_INTR_EN, 0);
++	irq_completion_done(snf->pdev);
++
++	return 1;
++}
++
++static int mtk_snand_select_spare_per_sector(struct mtk_snand *snf)
++{
++	uint32_t spare_per_step = snf->oobsize / snf->ecc_steps;
++	int i, mul = 1;
++
++	/*
++	 * If we're using the 1KB sector size, HW will automatically
++	 * double the spare size. So we should only use half of the value.
++	 */
++	if (snf->nfi_soc->sector_size == 1024)
++		mul = 2;
++
++	spare_per_step /= mul;
++
++	for (i = snf->nfi_soc->num_spare_size - 1; i >= 0; i--) {
++		if (snf->nfi_soc->spare_sizes[i] <= spare_per_step) {
++			snf->spare_per_sector = snf->nfi_soc->spare_sizes[i];
++			snf->spare_per_sector *= mul;
++			return i;
++		}
++	}
++
++	snand_log_nfi(snf->pdev,
++		      "Page size %u+%u is not supported\n", snf->writesize,
++		      snf->oobsize);
++
++	return -1;
++}
++
++static int mtk_snand_pagefmt_setup(struct mtk_snand *snf)
++{
++	uint32_t spare_size_idx, spare_size_shift, pagesize_idx;
++	uint32_t sector_size_512;
++
++	if (snf->nfi_soc->sector_size == 512) {
++		sector_size_512 = NFI_SEC_SEL_512;
++		spare_size_shift = NFI_SPARE_SIZE_S;
++	} else {
++		sector_size_512 = 0;
++		spare_size_shift = NFI_SPARE_SIZE_LS_S;
++	}
++
++	switch (snf->writesize) {
++	case SZ_512:
++		pagesize_idx = NFI_PAGE_SIZE_512_2K;
++		break;
++	case SZ_2K:
++		if (snf->nfi_soc->sector_size == 512)
++			pagesize_idx = NFI_PAGE_SIZE_2K_4K;
++		else
++			pagesize_idx = NFI_PAGE_SIZE_512_2K;
++		break;
++	case SZ_4K:
++		if (snf->nfi_soc->sector_size == 512)
++			pagesize_idx = NFI_PAGE_SIZE_4K_8K;
++		else
++			pagesize_idx = NFI_PAGE_SIZE_2K_4K;
++		break;
++	case SZ_8K:
++		if (snf->nfi_soc->sector_size == 512)
++			pagesize_idx = NFI_PAGE_SIZE_8K_16K;
++		else
++			pagesize_idx = NFI_PAGE_SIZE_4K_8K;
++		break;
++	case SZ_16K:
++		pagesize_idx = NFI_PAGE_SIZE_8K_16K;
++		break;
++	default:
++		snand_log_nfi(snf->pdev, "Page size %u is not supported\n",
++			      snf->writesize);
++		return -ENOTSUPP;
++	}
++
++	spare_size_idx = mtk_snand_select_spare_per_sector(snf);
++	if (unlikely(spare_size_idx < 0))
++		return -ENOTSUPP;
++
++	snf->raw_sector_size = snf->nfi_soc->sector_size +
++			       snf->spare_per_sector;
++
++	/* Setup page format */
++	nfi_write32(snf, NFI_PAGEFMT,
++		    (snf->nfi_soc->fdm_ecc_size << NFI_FDM_ECC_NUM_S) |
++		    (snf->nfi_soc->fdm_size << NFI_FDM_NUM_S) |
++		    (spare_size_idx << spare_size_shift) |
++		    (pagesize_idx << NFI_PAGE_SIZE_S) |
++		    sector_size_512);
++
++	return 0;
++}
++
++static enum snand_flash_io mtk_snand_select_opcode(struct mtk_snand *snf,
++				   uint32_t snfi_caps, uint8_t *opcode,
++				   uint8_t *dummy,
++				   const struct snand_io_cap *op_cap)
++{
++	uint32_t i, caps;
++
++	caps = snfi_caps & op_cap->caps;
++
++	i = fls(caps);
++	if (i > 0) {
++		*opcode = op_cap->opcodes[i - 1].opcode;
++		if (dummy)
++			*dummy = op_cap->opcodes[i - 1].dummy;
++		return i - 1;
++	}
++
++	return __SNAND_IO_MAX;
++}
++
++static int mtk_snand_select_opcode_rfc(struct mtk_snand *snf,
++				       uint32_t snfi_caps,
++				       const struct snand_io_cap *op_cap)
++{
++	enum snand_flash_io idx;
++
++	static const uint8_t rfc_modes[__SNAND_IO_MAX] = {
++		[SNAND_IO_1_1_1] = DATA_READ_MODE_X1,
++		[SNAND_IO_1_1_2] = DATA_READ_MODE_X2,
++		[SNAND_IO_1_2_2] = DATA_READ_MODE_DUAL,
++		[SNAND_IO_1_1_4] = DATA_READ_MODE_X4,
++		[SNAND_IO_1_4_4] = DATA_READ_MODE_QUAD,
++	};
++
++	idx = mtk_snand_select_opcode(snf, snfi_caps, &snf->opcode_rfc,
++				      &snf->dummy_rfc, op_cap);
++	if (idx >= __SNAND_IO_MAX) {
++		snand_log_snfi(snf->pdev,
++			       "No capable opcode for read from cache\n");
++		return -ENOTSUPP;
++	}
++
++	snf->mode_rfc = rfc_modes[idx];
++
++	if (idx == SNAND_IO_1_1_4 || idx == SNAND_IO_1_4_4)
++		snf->quad_spi_op = true;
++
++	return 0;
++}
++
++static int mtk_snand_select_opcode_pl(struct mtk_snand *snf, uint32_t snfi_caps,
++				      const struct snand_io_cap *op_cap)
++{
++	enum snand_flash_io idx;
++
++	static const uint8_t pl_modes[__SNAND_IO_MAX] = {
++		[SNAND_IO_1_1_1] = 0,
++		[SNAND_IO_1_1_4] = 1,
++	};
++
++	idx = mtk_snand_select_opcode(snf, snfi_caps, &snf->opcode_pl,
++				      NULL, op_cap);
++	if (idx >= __SNAND_IO_MAX) {
++		snand_log_snfi(snf->pdev,
++			       "No capable opcode for program load\n");
++		return -ENOTSUPP;
++	}
++
++	snf->mode_pl = pl_modes[idx];
++
++	if (idx == SNAND_IO_1_1_4)
++		snf->quad_spi_op = true;
++
++	return 0;
++}
++
++static int mtk_snand_setup(struct mtk_snand *snf,
++			   const struct snand_flash_info *snand_info)
++{
++	const struct snand_mem_org *memorg = &snand_info->memorg;
++	uint32_t i, msg_size, snfi_caps;
++	int ret;
++
++	/* Calculate flash memory organization */
++	snf->model = snand_info->model;
++	snf->writesize = memorg->pagesize;
++	snf->oobsize = memorg->sparesize;
++	snf->erasesize = snf->writesize * memorg->pages_per_block;
++	snf->die_size = (uint64_t)snf->erasesize * memorg->blocks_per_die;
++	snf->size = snf->die_size * memorg->ndies;
++	snf->num_dies = memorg->ndies;
++
++	snf->writesize_mask = snf->writesize - 1;
++	snf->erasesize_mask = snf->erasesize - 1;
++	snf->die_mask = snf->die_size - 1;
++
++	snf->writesize_shift = ffs(snf->writesize) - 1;
++	snf->erasesize_shift = ffs(snf->erasesize) - 1;
++	snf->die_shift = mtk_snand_ffs64(snf->die_size) - 1;
++
++	snf->select_die = snand_info->select_die;
++
++	/* Determine opcodes for read from cache/program load */
++	snfi_caps = SPI_IO_1_1_1 | SPI_IO_1_1_2 | SPI_IO_1_2_2;
++	if (snf->snfi_quad_spi)
++		snfi_caps |= SPI_IO_1_1_4 | SPI_IO_1_4_4;
++
++	ret = mtk_snand_select_opcode_rfc(snf, snfi_caps, snand_info->cap_rd);
++	if (ret)
++		return ret;
++
++	ret = mtk_snand_select_opcode_pl(snf, snfi_caps, snand_info->cap_pl);
++	if (ret)
++		return ret;
++
++	/* ECC and page format */
++	snf->ecc_steps = snf->writesize / snf->nfi_soc->sector_size;
++	if (snf->ecc_steps > snf->nfi_soc->max_sectors) {
++		snand_log_nfi(snf->pdev, "Page size %u is not supported\n",
++			      snf->writesize);
++		return -ENOTSUPP;
++	}
++
++	ret = mtk_snand_pagefmt_setup(snf);
++	if (ret)
++		return ret;
++
++	msg_size = snf->nfi_soc->sector_size + snf->nfi_soc->fdm_ecc_size;
++	ret = mtk_ecc_setup(snf, snf->nfi_base + NFI_FDM0L,
++			    snf->spare_per_sector - snf->nfi_soc->fdm_size,
++			    msg_size);
++	if (ret)
++		return ret;
++
++	nfi_write16(snf, NFI_CNFG, 0);
++
++	/* Tuning options */
++	nfi_write16(snf, NFI_DEBUG_CON1, WBUF_EN);
++	nfi_write32(snf, SNF_DLY_CTL3, (40 << SFCK_SAM_DLY_S));
++
++	/* Interrupts */
++	nfi_read32(snf, NFI_INTR_STA);
++	nfi_write32(snf, NFI_INTR_EN, 0);
++
++	/* Clear SNF done flag */
++	nfi_rmw32(snf, SNF_STA_CTL1, 0, CUS_READ_DONE | CUS_PG_DONE);
++	nfi_write32(snf, SNF_STA_CTL1, 0);
++
++	/* Initialization on all dies */
++	for (i = 0; i < snf->num_dies; i++) {
++		mtk_snand_select_die(snf, i);
++
++		/* Disable On-Die ECC engine */
++		ret = mtk_snand_ondie_ecc_control(snf, false);
++		if (ret)
++			return ret;
++
++		/* Disable block protection */
++		mtk_snand_unlock(snf);
++
++		/* Enable/disable quad-spi */
++		mtk_snand_qspi_control(snf, snf->quad_spi_op);
++	}
++
++	mtk_snand_select_die(snf, 0);
++
++	return 0;
++}
++
++static int mtk_snand_id_probe(struct mtk_snand *snf,
++			      const struct snand_flash_info **snand_info)
++{
++	uint8_t id[4], op[2];
++	int ret;
++
++	/* Read SPI-NAND JEDEC ID, OP + dummy/addr + ID */
++	op[0] = SNAND_CMD_READID;
++	op[1] = 0;
++	ret = mtk_snand_mac_io(snf, op, 2, id, sizeof(id));
++	if (ret)
++		return ret;
++
++	*snand_info = snand_flash_id_lookup(SNAND_ID_DYMMY, id);
++	if (*snand_info)
++		return 0;
++
++	/* Read SPI-NAND JEDEC ID, OP + ID */
++	op[0] = SNAND_CMD_READID;
++	ret = mtk_snand_mac_io(snf, op, 1, id, sizeof(id));
++	if (ret)
++		return ret;
++
++	*snand_info = snand_flash_id_lookup(SNAND_ID_DYMMY, id);
++	if (*snand_info)
++		return 0;
++
++	snand_log_chip(snf->pdev,
++		       "Unrecognized SPI-NAND ID: %02x %02x %02x %02x\n",
++		       id[0], id[1], id[2], id[3]);
++
++	return -EINVAL;
++}
++
++int mtk_snand_init(void *dev, const struct mtk_snand_platdata *pdata,
++		   struct mtk_snand **psnf)
++{
++	const struct snand_flash_info *snand_info;
++	struct mtk_snand tmpsnf, *snf;
++	uint32_t rawpage_size;
++	int ret;
++
++	if (!pdata || !psnf)
++		return -EINVAL;
++
++	if (pdata->soc >= __SNAND_SOC_MAX) {
++		snand_log_chip(dev, "Invalid SOC %u for MTK-SNAND\n",
++			       pdata->soc);
++		return -EINVAL;
++	}
++
++	/* Dummy instance only for initial reset and id probe */
++	tmpsnf.nfi_base = pdata->nfi_base;
++	tmpsnf.ecc_base = pdata->ecc_base;
++	tmpsnf.soc = pdata->soc;
++	tmpsnf.nfi_soc = &mtk_snand_socs[pdata->soc];
++	tmpsnf.pdev = dev;
++
++	/* Switch to SNFI mode */
++	writel(SPI_MODE, tmpsnf.nfi_base + SNF_CFG);
++
++	/* Reset SNFI & NFI */
++	mtk_snand_mac_reset(&tmpsnf);
++	mtk_nfi_reset(&tmpsnf);
++
++	/* Reset SPI-NAND chip */
++	ret = mtk_snand_chip_reset(&tmpsnf);
++	if (ret) {
++		snand_log_chip(dev, "Failed to reset SPI-NAND chip\n");
++		return ret;
++	}
++
++	/* Probe SPI-NAND flash by JEDEC ID */
++	ret = mtk_snand_id_probe(&tmpsnf, &snand_info);
++	if (ret)
++		return ret;
++
++	rawpage_size = snand_info->memorg.pagesize +
++		       snand_info->memorg.sparesize;
++
++	/* Allocate memory for instance and cache */
++	snf = generic_mem_alloc(dev, sizeof(*snf) + rawpage_size);
++	if (!snf) {
++		snand_log_chip(dev, "Failed to allocate memory for instance\n");
++		return -ENOMEM;
++	}
++
++	snf->buf_cache = (uint8_t *)((uintptr_t)snf + sizeof(*snf));
++
++	/* Allocate memory for DMA buffer */
++	snf->page_cache = dma_mem_alloc(dev, rawpage_size);
++	if (!snf->page_cache) {
++		generic_mem_free(dev, snf);
++		snand_log_chip(dev,
++			       "Failed to allocate memory for DMA buffer\n");
++		return -ENOMEM;
++	}
++
++	/* Fill up instance */
++	snf->pdev = dev;
++	snf->nfi_base = pdata->nfi_base;
++	snf->ecc_base = pdata->ecc_base;
++	snf->soc = pdata->soc;
++	snf->nfi_soc = &mtk_snand_socs[pdata->soc];
++	snf->snfi_quad_spi = pdata->quad_spi;
++
++	/* Initialize SNFI & ECC engine */
++	ret = mtk_snand_setup(snf, snand_info);
++	if (ret) {
++		dma_mem_free(dev, snf->page_cache);
++		generic_mem_free(dev, snf);
++		return ret;
++	}
++
++	*psnf = snf;
++
++	return 0;
++}
++
++int mtk_snand_cleanup(struct mtk_snand *snf)
++{
++	if (!snf)
++		return 0;
++
++	dma_mem_free(snf->pdev, snf->page_cache);
++	generic_mem_free(snf->pdev, snf);
++
++	return 0;
++}
+--- /dev/null
++++ b/drivers/mtd/mtk-snand/mtk-snand.h
+@@ -0,0 +1,77 @@
++/* SPDX-License-Identifier: GPL-2.0 OR BSD-3-Clause */
++/*
++ * Copyright (C) 2020 MediaTek Inc. All Rights Reserved.
++ *
++ * Author: Weijie Gao <weijie.gao@mediatek.com>
++ */
++
++#ifndef _MTK_SNAND_H_
++#define _MTK_SNAND_H_
++
++#ifndef PRIVATE_MTK_SNAND_HEADER
++#include <stddef.h>
++#include <stdint.h>
++#include <stdbool.h>
++#endif
++
++enum mtk_snand_soc {
++	SNAND_SOC_MT7622,
++	SNAND_SOC_MT7629,
++	SNAND_SOC_MT7986,
++
++	__SNAND_SOC_MAX
++};
++
++struct mtk_snand_platdata {
++	void *nfi_base;
++	void *ecc_base;
++	enum mtk_snand_soc soc;
++	bool quad_spi;
++};
++
++struct mtk_snand_chip_info {
++	const char *model;
++	uint64_t chipsize;
++	uint32_t blocksize;
++	uint32_t pagesize;
++	uint32_t sparesize;
++	uint32_t spare_per_sector;
++	uint32_t fdm_size;
++	uint32_t fdm_ecc_size;
++	uint32_t num_sectors;
++	uint32_t sector_size;
++	uint32_t ecc_strength;
++	uint32_t ecc_bytes;
++};
++
++struct mtk_snand;
++struct snand_flash_info;
++
++int mtk_snand_init(void *dev, const struct mtk_snand_platdata *pdata,
++		   struct mtk_snand **psnf);
++int mtk_snand_cleanup(struct mtk_snand *snf);
++
++int mtk_snand_chip_reset(struct mtk_snand *snf);
++int mtk_snand_read_page(struct mtk_snand *snf, uint64_t addr, void *buf,
++			void *oob, bool raw);
++int mtk_snand_write_page(struct mtk_snand *snf, uint64_t addr, const void *buf,
++			 const void *oob, bool raw);
++int mtk_snand_erase_block(struct mtk_snand *snf, uint64_t addr);
++int mtk_snand_block_isbad(struct mtk_snand *snf, uint64_t addr);
++int mtk_snand_block_markbad(struct mtk_snand *snf, uint64_t addr);
++int mtk_snand_fill_oob(struct mtk_snand *snf, uint8_t *oobraw,
++		       const uint8_t *oobbuf, size_t ooblen);
++int mtk_snand_transfer_oob(struct mtk_snand *snf, uint8_t *oobbuf,
++			   size_t ooblen, const uint8_t *oobraw);
++int mtk_snand_read_page_auto_oob(struct mtk_snand *snf, uint64_t addr,
++				 void *buf, void *oob, size_t ooblen,
++				 size_t *actualooblen, bool raw);
++int mtk_snand_write_page_auto_oob(struct mtk_snand *snf, uint64_t addr,
++				  const void *buf, const void *oob,
++				  size_t ooblen, size_t *actualooblen,
++				  bool raw);
++int mtk_snand_get_chip_info(struct mtk_snand *snf,
++			    struct mtk_snand_chip_info *info);
++int mtk_snand_irq_process(struct mtk_snand *snf);
++
++#endif /* _MTK_SNAND_H_ */
diff --git a/package/boot/uboot-mediatek/patches/000-mtk-15-mtd-mtk-snand-add-support-for-SPL.patch b/package/boot/uboot-mediatek/patches/000-mtk-15-mtd-mtk-snand-add-support-for-SPL.patch
new file mode 100644
index 0000000000..4a06acc2dc
--- /dev/null
+++ b/package/boot/uboot-mediatek/patches/000-mtk-15-mtd-mtk-snand-add-support-for-SPL.patch
@@ -0,0 +1,174 @@
+From b7fb0e0674db12bcf53df4b107a17c80758ee5d3 Mon Sep 17 00:00:00 2001
+From: Weijie Gao <weijie.gao@mediatek.com>
+Date: Wed, 3 Mar 2021 08:57:29 +0800
+Subject: [PATCH 05/12] mtd: mtk-snand: add support for SPL
+
+Add support to initialize SPI-NAND in SPL.
+Add implementation for SPL NAND loader.
+
+Signed-off-by: Weijie Gao <weijie.gao@mediatek.com>
+---
+ drivers/mtd/mtk-snand/Kconfig         |   6 ++
+ drivers/mtd/mtk-snand/Makefile        |   4 +
+ drivers/mtd/mtk-snand/mtk-snand-spl.c | 132 ++++++++++++++++++++++++++
+ 3 files changed, 142 insertions(+)
+ create mode 100644 drivers/mtd/mtk-snand/mtk-snand-spl.c
+
+--- a/drivers/mtd/mtk-snand/Kconfig
++++ b/drivers/mtd/mtk-snand/Kconfig
+@@ -19,3 +19,9 @@ config MTK_SPI_NAND_MTD
+ 	help
+ 	  This option enables access to SPI-NAND flashes through the
+ 	  MTD interface of MediaTek SPI NAND Flash Controller
++
++config SPL_MTK_SPI_NAND
++	tristate "SPL support for MediaTek SPI NAND flash controller"
++	depends on MTK_SPI_NAND
++	help
++	  This option enables access to SPI-NAND flashes in the SPL stage
+--- a/drivers/mtd/mtk-snand/Makefile
++++ b/drivers/mtd/mtk-snand/Makefile
+@@ -8,4 +8,8 @@
+ obj-y += mtk-snand.o mtk-snand-ecc.o mtk-snand-ids.o mtk-snand-os.o
+ obj-$(CONFIG_MTK_SPI_NAND_MTD) += mtk-snand-mtd.o
+ 
++ifdef CONFIG_SPL_BUILD
++obj-$(CONFIG_SPL_MTK_SPI_NAND) += mtk-snand-spl.o
++endif
++
+ ccflags-y += -DPRIVATE_MTK_SNAND_HEADER
+--- /dev/null
++++ b/drivers/mtd/mtk-snand/mtk-snand-spl.c
+@@ -0,0 +1,132 @@
++// SPDX-License-Identifier: GPL-2.0
++/*
++ * Copyright (C) 2020 MediaTek Inc. All Rights Reserved.
++ *
++ * Author: Weijie Gao <weijie.gao@mediatek.com>
++ */
++
++#include <common.h>
++#include <dm.h>
++#include <dm/uclass.h>
++#include <malloc.h>
++#include <mapmem.h>
++#include <mtd.h>
++#include <watchdog.h>
++
++#include "mtk-snand.h"
++
++static struct mtk_snand *snf;
++static struct mtk_snand_chip_info cinfo;
++static u32 oobavail;
++
++static u8 *page_cache;
++
++int nand_spl_load_image(uint32_t offs, unsigned int size, void *dst)
++{
++	u32 sizeremain = size, chunksize, leading;
++	uint32_t off = offs, writesize_mask = cinfo.pagesize - 1;
++	uint8_t *ptr = dst;
++	int ret;
++
++	if (!snf)
++		return -ENODEV;
++
++	while (sizeremain) {
++		WATCHDOG_RESET();
++
++		leading = off & writesize_mask;
++		chunksize = cinfo.pagesize - leading;
++		if (chunksize > sizeremain)
++			chunksize = sizeremain;
++
++		if (chunksize == cinfo.pagesize) {
++			ret = mtk_snand_read_page(snf, off - leading, ptr,
++						  NULL, false);
++			if (ret)
++				break;
++		} else {
++			ret = mtk_snand_read_page(snf, off - leading,
++						  page_cache, NULL, false);
++			if (ret)
++				break;
++
++			memcpy(ptr, page_cache + leading, chunksize);
++		}
++
++		off += chunksize;
++		ptr += chunksize;
++		sizeremain -= chunksize;
++	}
++
++	return ret;
++}
++
++void nand_init(void)
++{
++	struct mtk_snand_platdata mtk_snand_pdata = {};
++	struct udevice *dev;
++	fdt_addr_t base;
++	int ret;
++
++	ret = uclass_get_device_by_driver(UCLASS_MTD, DM_DRIVER_GET(mtk_snand),
++					  &dev);
++	if (ret) {
++		printf("mtk-snand-spl: Device instance not found!\n");
++		return;
++	}
++
++	base = dev_read_addr_name(dev, "nfi");
++	if (base == FDT_ADDR_T_NONE) {
++		printf("mtk-snand-spl: NFI base not set\n");
++		return;
++	}
++	mtk_snand_pdata.nfi_base = map_sysmem(base, 0);
++
++	base = dev_read_addr_name(dev, "ecc");
++	if (base == FDT_ADDR_T_NONE) {
++		printf("mtk-snand-spl: ECC base not set\n");
++		return;
++	}
++	mtk_snand_pdata.ecc_base = map_sysmem(base, 0);
++
++	mtk_snand_pdata.soc = dev_get_driver_data(dev);
++	mtk_snand_pdata.quad_spi = dev_read_bool(dev, "quad-spi");
++
++	ret = mtk_snand_init(NULL, &mtk_snand_pdata, &snf);
++	if (ret) {
++		printf("mtk-snand-spl: failed to initialize SPI-NAND\n");
++		return;
++	}
++
++	mtk_snand_get_chip_info(snf, &cinfo);
++
++	oobavail = cinfo.num_sectors * (cinfo.fdm_size - 1);
++
++	printf("SPI-NAND: %s (%uMB)\n", cinfo.model,
++	       (u32)(cinfo.chipsize >> 20));
++
++	page_cache = malloc(cinfo.pagesize + cinfo.sparesize);
++	if (!page_cache) {
++		mtk_snand_cleanup(snf);
++		printf("mtk-snand-spl: failed to allocate page cache\n");
++	}
++}
++
++void nand_deselect(void)
++{
++
++}
++
++static const struct udevice_id mtk_snand_ids[] = {
++	{ .compatible = "mediatek,mt7622-snand", .data = SNAND_SOC_MT7622 },
++	{ .compatible = "mediatek,mt7629-snand", .data = SNAND_SOC_MT7629 },
++	{ .compatible = "mediatek,mt7986-snand", .data = SNAND_SOC_MT7986 },
++	{ /* sentinel */ },
++};
++
++U_BOOT_DRIVER(mtk_snand) = {
++	.name = "mtk-snand",
++	.id = UCLASS_MTD,
++	.of_match = mtk_snand_ids,
++	.flags = DM_FLAG_PRE_RELOC,
++};
diff --git a/package/boot/uboot-mediatek/patches/000-mtk-16-env-add-support-for-generic-MTD-device.patch b/package/boot/uboot-mediatek/patches/000-mtk-16-env-add-support-for-generic-MTD-device.patch
new file mode 100644
index 0000000000..11eccb8a3b
--- /dev/null
+++ b/package/boot/uboot-mediatek/patches/000-mtk-16-env-add-support-for-generic-MTD-device.patch
@@ -0,0 +1,409 @@
+From a26620ec83fa3077f0c261046e82091f7455736f Mon Sep 17 00:00:00 2001
+From: Weijie Gao <weijie.gao@mediatek.com>
+Date: Wed, 3 Mar 2021 10:11:32 +0800
+Subject: [PATCH 06/12] env: add support for generic MTD device
+
+Add an env driver for generic MTD device.
+
+Signed-off-by: Weijie Gao <weijie.gao@mediatek.com>
+---
+ cmd/nvedit.c           |   3 +-
+ env/Kconfig            |  37 +++++-
+ env/Makefile           |   1 +
+ env/env.c              |   3 +
+ env/mtd.c              | 256 +++++++++++++++++++++++++++++++++++++++++
+ include/env_internal.h |   1 +
+ tools/Makefile         |   1 +
+ 7 files changed, 299 insertions(+), 3 deletions(-)
+ create mode 100644 env/mtd.c
+
+--- a/cmd/nvedit.c
++++ b/cmd/nvedit.c
+@@ -50,6 +50,7 @@ DECLARE_GLOBAL_DATA_PTR;
+ 	defined(CONFIG_ENV_IS_IN_MMC)		|| \
+ 	defined(CONFIG_ENV_IS_IN_FAT)		|| \
+ 	defined(CONFIG_ENV_IS_IN_EXT4)		|| \
++	defined(CONFIG_ENV_IS_IN_MTD)		|| \
+ 	defined(CONFIG_ENV_IS_IN_NAND)		|| \
+ 	defined(CONFIG_ENV_IS_IN_NVRAM)		|| \
+ 	defined(CONFIG_ENV_IS_IN_ONENAND)	|| \
+@@ -64,7 +65,7 @@ DECLARE_GLOBAL_DATA_PTR;
+ 
+ #if	!defined(ENV_IS_IN_DEVICE)		&& \
+ 	!defined(CONFIG_ENV_IS_NOWHERE)
+-# error Define one of CONFIG_ENV_IS_IN_{EEPROM|FLASH|MMC|FAT|EXT4|\
++# error Define one of CONFIG_ENV_IS_IN_{EEPROM|FLASH|MMC|FAT|EXT4|MTD|\
+ NAND|NVRAM|ONENAND|SATA|SPI_FLASH|REMOTE|UBI} or CONFIG_ENV_IS_NOWHERE
+ #endif
+ 
+--- a/env/Kconfig
++++ b/env/Kconfig
+@@ -19,7 +19,7 @@ config ENV_IS_NOWHERE
+ 		     !ENV_IS_IN_MMC && !ENV_IS_IN_NAND && \
+ 		     !ENV_IS_IN_NVRAM && !ENV_IS_IN_ONENAND && \
+ 		     !ENV_IS_IN_REMOTE && !ENV_IS_IN_SPI_FLASH && \
+-		     !ENV_IS_IN_UBI
++		     !ENV_IS_IN_UBI && !ENV_IS_IN_MTD
+ 	help
+ 	  Define this if you don't want to or can't have an environment stored
+ 	  on a storage medium. In this case the environment will still exist
+@@ -207,6 +207,27 @@ config ENV_IS_IN_MMC
+ 	  This value is also in units of bytes, but must also be aligned to
+ 	  an MMC sector boundary.
+ 
++config ENV_IS_IN_MTD
++	bool "Environment in a MTD device"
++	depends on !CHAIN_OF_TRUST
++	depends on MTD
++	help
++	  Define this if you have a MTD device which you want to use for
++	  the environment.
++
++	  - CONFIG_ENV_MTD_NAME:
++	  - CONFIG_ENV_OFFSET:
++	  - CONFIG_ENV_SIZE:
++
++	  These three #defines specify the MTD device where the environment
++	  is stored, offset and size of the environment area within the MTD
++	  device. CONFIG_ENV_OFFSET must be aligned to an erase block boundary.
++
++	  - CONFIG_ENV_SIZE_REDUND:
++
++	  This #define specify the maximum size allowed for read/write/erase
++	  with skipped bad blocks starting from ENV_OFFSET.
++
+ config ENV_IS_IN_NAND
+ 	bool "Environment in a NAND device"
+ 	depends on !CHAIN_OF_TRUST
+@@ -534,10 +555,16 @@ config ENV_ADDR_REDUND
+ 	  Offset from the start of the device (or partition) of the redundant
+ 	  environment location.
+ 
++config ENV_MTD_NAME
++	string "Name of the MTD device storing the environment"
++	depends on ENV_IS_IN_MTD
++	help
++	  Name of the MTD device that stores the environment
++
+ config ENV_OFFSET
+ 	hex "Environment offset"
+ 	depends on ENV_IS_IN_EEPROM || ENV_IS_IN_MMC || ENV_IS_IN_NAND || \
+-		    ENV_IS_IN_SPI_FLASH
++		    ENV_IS_IN_SPI_FLASH || ENV_IS_IN_MTD
+ 	default 0x3f8000 if ARCH_ROCKCHIP && ENV_IS_IN_MMC
+ 	default 0x140000 if ARCH_ROCKCHIP && ENV_IS_IN_SPI_FLASH
+ 	default 0x88000 if ARCH_SUNXI
+@@ -582,6 +609,12 @@ config ENV_SECT_SIZE
+ 	help
+ 	  Size of the sector containing the environment.
+ 
++config ENV_SIZE_REDUND
++	hex "Redundant environment size"
++	depends on ENV_IS_IN_MTD
++	help
++	  The maximum size allowed for read/write/erase with skipped bad blocks.
++
+ config ENV_UBI_PART
+ 	string "UBI partition name"
+ 	depends on ENV_IS_IN_UBI
+--- a/env/Makefile
++++ b/env/Makefile
+@@ -26,6 +26,7 @@ obj-$(CONFIG_$(SPL_TPL_)ENV_IS_NOWHERE)
+ obj-$(CONFIG_$(SPL_TPL_)ENV_IS_IN_MMC) += mmc.o
+ obj-$(CONFIG_$(SPL_TPL_)ENV_IS_IN_FAT) += fat.o
+ obj-$(CONFIG_$(SPL_TPL_)ENV_IS_IN_EXT4) += ext4.o
++obj-$(CONFIG_$(SPL_TPL_)ENV_IS_IN_MTD) += mtd.o
+ obj-$(CONFIG_$(SPL_TPL_)ENV_IS_IN_NAND) += nand.o
+ obj-$(CONFIG_$(SPL_TPL_)ENV_IS_IN_SPI_FLASH) += sf.o
+ obj-$(CONFIG_$(SPL_TPL_)ENV_IS_IN_FLASH) += flash.o
+--- a/env/env.c
++++ b/env/env.c
+@@ -69,6 +69,9 @@ static enum env_location env_locations[]
+ #ifdef CONFIG_ENV_IS_IN_MMC
+ 	ENVL_MMC,
+ #endif
++#ifdef CONFIG_ENV_IS_IN_MTD
++	ENVL_MTD,
++#endif
+ #ifdef CONFIG_ENV_IS_IN_NAND
+ 	ENVL_NAND,
+ #endif
+--- /dev/null
++++ b/env/mtd.c
+@@ -0,0 +1,256 @@
++/* SPDX-License-Identifier: GPL-2.0 */
++/*
++ * Copyright (C) 2021 MediaTek Inc. All Rights Reserved.
++ *
++ * Author: Weijie Gao <weijie.gao@mediatek.com>
++ */
++
++#include <command.h>
++#include <env.h>
++#include <env_internal.h>
++#include <errno.h>
++#include <linux/kernel.h>
++#include <linux/stddef.h>
++#include <linux/types.h>
++#include <linux/mtd/mtd.h>
++#include <malloc.h>
++#include <memalign.h>
++#include <mtd.h>
++#include <search.h>
++
++#if CONFIG_ENV_SIZE_REDUND < CONFIG_ENV_SIZE
++#undef CONFIG_ENV_SIZE_REDUND
++#define CONFIG_ENV_SIZE_REDUND CONFIG_ENV_SIZE
++#endif
++
++#if defined(ENV_IS_EMBEDDED)
++env_t *env_ptr = &environment;
++#else /* ! ENV_IS_EMBEDDED */
++env_t *env_ptr;
++#endif /* ENV_IS_EMBEDDED */
++
++DECLARE_GLOBAL_DATA_PTR;
++
++static int env_mtd_init(void)
++{
++#if defined(ENV_IS_EMBEDDED)
++	int crc1_ok = 0, crc2_ok = 0;
++	env_t *tmp_env1;
++
++	tmp_env1 = env_ptr;
++	crc1_ok = crc32(0, tmp_env1->data, ENV_SIZE) == tmp_env1->crc;
++
++	if (!crc1_ok && !crc2_ok) {
++		gd->env_addr	= 0;
++		gd->env_valid	= ENV_INVALID;
++
++		return 0;
++	} else if (crc1_ok && !crc2_ok) {
++		gd->env_valid = ENV_VALID;
++	}
++
++	if (gd->env_valid == ENV_VALID)
++		env_ptr = tmp_env1;
++
++	gd->env_addr = (ulong)env_ptr->data;
++
++#else /* ENV_IS_EMBEDDED */
++	gd->env_addr	= (ulong)&default_environment[0];
++	gd->env_valid	= ENV_VALID;
++#endif /* ENV_IS_EMBEDDED */
++
++	return 0;
++}
++
++static struct mtd_info *env_mtd_get_dev(void)
++{
++	struct mtd_info *mtd;
++
++	mtd_probe_devices();
++
++	mtd = get_mtd_device_nm(CONFIG_ENV_MTD_NAME);
++	if (IS_ERR(mtd) || !mtd) {
++		printf("MTD device '%s' not found\n", CONFIG_ENV_MTD_NAME);
++		return NULL;
++	}
++
++	return mtd;
++}
++
++static inline bool mtd_addr_is_block_aligned(struct mtd_info *mtd, u64 addr)
++{
++	return (addr & mtd->erasesize_mask) == 0;
++}
++
++static int mtd_io_skip_bad(struct mtd_info *mtd, bool read, loff_t offset,
++			   size_t length, size_t redund, u8 *buffer)
++{
++	struct mtd_oob_ops io_op = {};
++	size_t remaining = length;
++	loff_t off, end;
++	int ret;
++
++	io_op.mode = MTD_OPS_PLACE_OOB;
++	io_op.len = mtd->writesize;
++	io_op.datbuf = (void *)buffer;
++
++	/* Search for the first good block after the given offset */
++	off = offset;
++	end = (off + redund) | (mtd->erasesize - 1);
++	while (mtd_block_isbad(mtd, off) && off < end)
++		off += mtd->erasesize;
++
++	/* Reached end position */
++	if (off >= end)
++		return -EIO;
++
++	/* Loop over the pages to do the actual read/write */
++	while (remaining) {
++		/* Skip the block if it is bad */
++		if (mtd_addr_is_block_aligned(mtd, off) &&
++		    mtd_block_isbad(mtd, off)) {
++			off += mtd->erasesize;
++			continue;
++		}
++
++		if (read)
++			ret = mtd_read_oob(mtd, off, &io_op);
++		else
++			ret = mtd_write_oob(mtd, off, &io_op);
++
++		if (ret) {
++			printf("Failure while %s at offset 0x%llx\n",
++			       read ? "reading" : "writing", off);
++			break;
++		}
++
++		off += io_op.retlen;
++		remaining -= io_op.retlen;
++		io_op.datbuf += io_op.retlen;
++		io_op.oobbuf += io_op.oobretlen;
++
++		/* Reached end position */
++		if (off >= end)
++			return -EIO;
++	}
++
++	return 0;
++}
++
++#ifdef CONFIG_CMD_SAVEENV
++static int mtd_erase_skip_bad(struct mtd_info *mtd, loff_t offset,
++			      size_t length, size_t redund)
++{
++	struct erase_info erase_op = {};
++	loff_t end = (offset + redund) | (mtd->erasesize - 1);
++	int ret;
++
++	erase_op.mtd = mtd;
++	erase_op.addr = offset;
++	erase_op.len = length;
++
++	while (erase_op.len) {
++		ret = mtd_erase(mtd, &erase_op);
++
++		/* Abort if its not a bad block error */
++		if (ret != -EIO)
++			return ret;
++
++		printf("Skipping bad block at 0x%08llx\n", erase_op.fail_addr);
++
++		/* Skip bad block and continue behind it */
++		erase_op.len -= erase_op.fail_addr - erase_op.addr;
++		erase_op.len -= mtd->erasesize;
++		erase_op.addr = erase_op.fail_addr + mtd->erasesize;
++
++		/* Reached end position */
++		if (erase_op.addr >= end)
++			return -EIO;
++	}
++
++	return 0;
++}
++
++static int env_mtd_save(void)
++{
++	ALLOC_CACHE_ALIGN_BUFFER(env_t, env_new, 1);
++	struct mtd_info *mtd;
++	int ret = 0;
++
++	ret = env_export(env_new);
++	if (ret)
++		return ret;
++
++	mtd = env_mtd_get_dev();
++	if (!mtd)
++		return 1;
++
++	printf("Erasing on MTD device '%s'... ", mtd->name);
++
++	ret = mtd_erase_skip_bad(mtd, CONFIG_ENV_OFFSET, CONFIG_ENV_SIZE,
++				 CONFIG_ENV_SIZE_REDUND);
++
++	puts(ret ? "FAILED\n" : "OK\n");
++
++	if (ret) {
++		put_mtd_device(mtd);
++		return 1;
++	}
++
++	printf("Writing to MTD device '%s'... ", mtd->name);
++
++	ret = mtd_io_skip_bad(mtd, false, CONFIG_ENV_OFFSET, CONFIG_ENV_SIZE,
++			      CONFIG_ENV_SIZE_REDUND, (u8 *)env_new);
++
++	puts(ret ? "FAILED\n" : "OK\n");
++
++	put_mtd_device(mtd);
++
++	return !!ret;
++}
++#endif /* CONFIG_CMD_SAVEENV */
++
++static int readenv(size_t offset, u_char *buf)
++{
++	struct mtd_info *mtd;
++	int ret;
++
++	mtd = env_mtd_get_dev();
++	if (!mtd)
++		return 1;
++
++	ret = mtd_io_skip_bad(mtd, true, offset, CONFIG_ENV_SIZE,
++			      CONFIG_ENV_SIZE_REDUND, buf);
++
++	put_mtd_device(mtd);
++
++	return !!ret;
++}
++
++static int env_mtd_load(void)
++{
++#if !defined(ENV_IS_EMBEDDED)
++	ALLOC_CACHE_ALIGN_BUFFER(char, buf, CONFIG_ENV_SIZE);
++	int ret;
++
++	ret = readenv(CONFIG_ENV_OFFSET, (u_char *)buf);
++	if (ret) {
++		env_set_default("readenv() failed", 0);
++		return -EIO;
++	}
++
++	return env_import(buf, 1, H_EXTERNAL);
++#endif /* ! ENV_IS_EMBEDDED */
++
++	return 0;
++}
++
++U_BOOT_ENV_LOCATION(mtd) = {
++	.location	= ENVL_MTD,
++	ENV_NAME("MTD")
++	.load		= env_mtd_load,
++#if defined(CONFIG_CMD_SAVEENV)
++	.save		= env_save_ptr(env_mtd_save),
++#endif
++	.init		= env_mtd_init,
++};
+--- a/include/env_internal.h
++++ b/include/env_internal.h
+@@ -131,6 +131,7 @@ enum env_location {
+ 	ENVL_FAT,
+ 	ENVL_FLASH,
+ 	ENVL_MMC,
++	ENVL_MTD,
+ 	ENVL_NAND,
+ 	ENVL_NVRAM,
+ 	ENVL_ONENAND,
+--- a/tools/Makefile
++++ b/tools/Makefile
+@@ -41,6 +41,7 @@ ENVCRC-$(CONFIG_ENV_IS_EMBEDDED) = y
+ ENVCRC-$(CONFIG_ENV_IS_IN_EEPROM) = y
+ ENVCRC-$(CONFIG_ENV_IS_IN_FLASH) = y
+ ENVCRC-$(CONFIG_ENV_IS_IN_ONENAND) = y
++ENVCRC-$(CONFIG_ENV_IS_IN_MTD) = y
+ ENVCRC-$(CONFIG_ENV_IS_IN_NAND) = y
+ ENVCRC-$(CONFIG_ENV_IS_IN_NVRAM) = y
+ ENVCRC-$(CONFIG_ENV_IS_IN_SPI_FLASH) = y
diff --git a/package/boot/uboot-mediatek/patches/000-mtk-17-board-mt7629-add-support-for-booting-from-SPI-NAND.patch b/package/boot/uboot-mediatek/patches/000-mtk-17-board-mt7629-add-support-for-booting-from-SPI-NAND.patch
new file mode 100644
index 0000000000..1bfa639bc6
--- /dev/null
+++ b/package/boot/uboot-mediatek/patches/000-mtk-17-board-mt7629-add-support-for-booting-from-SPI-NAND.patch
@@ -0,0 +1,266 @@
+From 3757223c3354b9feeffcbe916eb18eb8873bd133 Mon Sep 17 00:00:00 2001
+From: Weijie Gao <weijie.gao@mediatek.com>
+Date: Wed, 3 Mar 2021 10:48:53 +0800
+Subject: [PATCH 07/12] board: mt7629: add support for booting from SPI-NAND
+
+Add support for mt7629 to boot from SPI-NAND.
+Add a new defconfig for mt7629+spi-nand configuration.
+
+Signed-off-by: Weijie Gao <weijie.gao@mediatek.com>
+---
+ arch/arm/dts/mt7629-rfb-u-boot.dtsi |   8 ++
+ arch/arm/dts/mt7629-rfb.dts         |  10 +++
+ arch/arm/dts/mt7629.dtsi            |  16 ++++
+ board/mediatek/mt7629/Kconfig       |  35 ++++++++-
+ configs/mt7629_nand_rfb_defconfig   | 111 ++++++++++++++++++++++++++++
+ include/configs/mt7629.h            |   7 ++
+ 6 files changed, 186 insertions(+), 1 deletion(-)
+ create mode 100644 configs/mt7629_nand_rfb_defconfig
+
+--- a/arch/arm/dts/mt7629-rfb-u-boot.dtsi
++++ b/arch/arm/dts/mt7629-rfb-u-boot.dtsi
+@@ -40,3 +40,11 @@
+ &snfi {
+ 	u-boot,dm-pre-reloc;
+ };
++
++&pinctrl {
++	u-boot,dm-pre-reloc;
++};
++
++&snand {
++	u-boot,dm-pre-reloc;
++};
+--- a/arch/arm/dts/mt7629-rfb.dts
++++ b/arch/arm/dts/mt7629-rfb.dts
+@@ -47,9 +47,12 @@
+ 	};
+ 
+ 	snfi_pins: snfi-pins {
++		u-boot,dm-pre-reloc;
++
+ 		mux {
+ 			function = "flash";
+ 			groups = "snfi";
++			u-boot,dm-pre-reloc;
+ 		};
+ 	};
+ 
+@@ -102,6 +105,13 @@
+ 	};
+ };
+ 
++&snand {
++	pinctrl-names = "default";
++	pinctrl-0 = <&snfi_pins>;
++	status = "okay";
++	quad-spi;
++};
++
+ &uart0 {
+ 	pinctrl-names = "default";
+ 	pinctrl-0 = <&uart0_pins>;
+--- a/arch/arm/dts/mt7629.dtsi
++++ b/arch/arm/dts/mt7629.dtsi
+@@ -229,6 +229,22 @@
+ 		#size-cells = <0>;
+ 	};
+ 
++	snand: snand@1100d000 {
++		compatible = "mediatek,mt7629-snand";
++		reg = <0x1100d000 0x1000>,
++		      <0x1100e000 0x1000>;
++		reg-names = "nfi", "ecc";
++		clocks = <&pericfg CLK_PERI_NFI_PD>,
++			 <&pericfg CLK_PERI_SNFI_PD>,
++			 <&pericfg CLK_PERI_NFIECC_PD>;
++		clock-names = "nfi_clk", "pad_clk", "ecc_clk";
++		assigned-clocks = <&topckgen CLK_TOP_AXI_SEL>,
++				  <&topckgen CLK_TOP_NFI_INFRA_SEL>;
++		assigned-clock-parents = <&topckgen CLK_TOP_SYSPLL1_D2>,
++					 <&topckgen CLK_TOP_UNIVPLL2_D8>;
++		status = "disabled";
++	};
++
+ 	snor: snor@11014000 {
+ 		compatible = "mediatek,mtk-snor";
+ 		reg = <0x11014000 0x1000>;
+--- a/board/mediatek/mt7629/Kconfig
++++ b/board/mediatek/mt7629/Kconfig
+@@ -12,6 +12,39 @@ config MTK_SPL_PAD_SIZE
+ 
+ config MTK_BROM_HEADER_INFO
+ 	string
+-	default "media=nor"
++	default "media=nor" if BOOT_FROM_SNOR
++	default "media=snand;nandinfo=2k+64" if BOOT_FROM_SNAND_2K_64
++	default "media=snand;nandinfo=2k+128" if BOOT_FROM_SNAND_2K_128
++	default "media=snand;nandinfo=4k+128" if BOOT_FROM_SNAND_4K_128
++	default "media=snand;nandinfo=4k+256" if BOOT_FROM_SNAND_4K_256
++
++choice
++	prompt "Boot device"
++	default BOOT_FROM_SNOR
++
++config BOOT_FROM_SNOR
++	bool "SPI-NOR"
++
++config BOOT_FROM_SNAND_2K_64
++	bool "SPI-NAND (2K+64)"
++	select MT7629_BOOT_FROM_SNAND
++
++config BOOT_FROM_SNAND_2K_128
++	bool "SPI-NAND (2K+128)"
++	select MT7629_BOOT_FROM_SNAND
++
++config BOOT_FROM_SNAND_4K_128
++	bool "SPI-NAND (4K+128)"
++	select MT7629_BOOT_FROM_SNAND
++
++config BOOT_FROM_SNAND_4K_256
++	bool "SPI-NAND (4K+256)"
++	select MT7629_BOOT_FROM_SNAND
++
++endchoice
++
++config MT7629_BOOT_FROM_SNAND
++	bool
++	default n
+ 
+ endif
+--- /dev/null
++++ b/configs/mt7629_nand_rfb_defconfig
+@@ -0,0 +1,111 @@
++CONFIG_ARM=y
++CONFIG_SYS_ARCH_TIMER=y
++CONFIG_SYS_THUMB_BUILD=y
++CONFIG_ARCH_MEDIATEK=y
++CONFIG_SYS_TEXT_BASE=0x41e00000
++CONFIG_SYS_MALLOC_F_LEN=0x4000
++CONFIG_NR_DRAM_BANKS=1
++CONFIG_ENV_SIZE=0x20000
++CONFIG_ENV_OFFSET=0x100000
++CONFIG_SPL_TEXT_BASE=0x201000
++CONFIG_TARGET_MT7629=y
++CONFIG_BOOT_FROM_SNAND_2K_64=y
++CONFIG_SPL_SERIAL_SUPPORT=y
++CONFIG_SPL_DRIVERS_MISC_SUPPORT=y
++CONFIG_SPL_STACK_R_ADDR=0x40800000
++CONFIG_SPL_PAYLOAD="u-boot.img"
++CONFIG_BUILD_TARGET="u-boot-mtk.bin"
++CONFIG_DEFAULT_DEVICE_TREE="mt7629-rfb"
++CONFIG_SPL_IMAGE="spl/u-boot-spl-mtk.bin"
++CONFIG_FIT=y
++CONFIG_FIT_VERBOSE=y
++CONFIG_BOOTDELAY=3
++CONFIG_DEFAULT_FDT_FILE="mt7629-rfb"
++CONFIG_SYS_CONSOLE_IS_IN_ENV=y
++CONFIG_SYS_STDIO_DEREGISTER=y
++# CONFIG_DISPLAY_BOARDINFO is not set
++CONFIG_SPL_SYS_MALLOC_SIMPLE=y
++CONFIG_SPL_STACK_R=y
++CONFIG_SPL_MTD_SUPPORT=y
++CONFIG_SPL_NAND_SUPPORT=y
++CONFIG_SPL_WATCHDOG_SUPPORT=y
++CONFIG_HUSH_PARSER=y
++CONFIG_SYS_PROMPT="U-Boot> "
++CONFIG_CMD_BOOTMENU=y
++# CONFIG_BOOTM_NETBSD is not set
++# CONFIG_BOOTM_PLAN9 is not set
++# CONFIG_BOOTM_RTEMS is not set
++# CONFIG_BOOTM_VXWORKS is not set
++# CONFIG_CMD_ELF is not set
++# CONFIG_CMD_XIMG is not set
++CONFIG_CMD_BIND=y
++CONFIG_CMD_DM=y
++# CONFIG_CMD_FLASH is not set
++CONFIG_CMD_GPIO=y
++CONFIG_CMD_MTD=y
++CONFIG_CMD_USB=y
++# CONFIG_CMD_SETEXPR is not set
++# CONFIG_CMD_NFS is not set
++CONFIG_CMD_PING=y
++CONFIG_CMD_FAT=y
++CONFIG_CMD_FS_GENERIC=y
++CONFIG_CMD_LOG=y
++CONFIG_EFI_PARTITION=y
++# CONFIG_SPL_PARTITION_UUIDS is not set
++CONFIG_PARTITION_TYPE_GUID=y
++CONFIG_OF_SPL_REMOVE_PROPS="interrupt-parent assigned-clocks assigned-clock-parents"
++CONFIG_ENV_OVERWRITE=y
++CONFIG_ENV_IS_IN_MTD=y
++CONFIG_ENV_MTD_NAME="spi-nand0"
++CONFIG_ENV_SIZE_REDUND=0x40000
++CONFIG_SYS_RELOC_GD_ENV_ADDR=y
++CONFIG_NET_RANDOM_ETHADDR=y
++CONFIG_SPL_DM_SEQ_ALIAS=y
++CONFIG_REGMAP=y
++CONFIG_SPL_REGMAP=y
++CONFIG_SYSCON=y
++CONFIG_SPL_SYSCON=y
++CONFIG_BLK=y
++CONFIG_CLK=y
++CONFIG_SPL_CLK=y
++# CONFIG_MMC is not set
++CONFIG_MTD=y
++CONFIG_DM_MTD=y
++CONFIG_MTK_SPI_NAND=y
++CONFIG_MTK_SPI_NAND_MTD=y
++CONFIG_SPL_MTK_SPI_NAND=y
++CONFIG_DM_ETH=y
++CONFIG_MEDIATEK_ETH=y
++CONFIG_PHY=y
++CONFIG_PHY_MTK_TPHY=y
++CONFIG_PINCTRL=y
++CONFIG_PINCONF=y
++CONFIG_SPL_PINCTRL=y
++CONFIG_SPL_PINCONF=y
++CONFIG_PINCTRL_MT7629=y
++CONFIG_POWER_DOMAIN=y
++CONFIG_MTK_POWER_DOMAIN=y
++CONFIG_DM_REGULATOR=y
++CONFIG_DM_REGULATOR_FIXED=y
++CONFIG_RAM=y
++CONFIG_SPL_RAM=y
++CONFIG_DM_SERIAL=y
++CONFIG_MTK_SERIAL=y
++CONFIG_SPI=y
++CONFIG_DM_SPI=y
++CONFIG_SPI_MEM=y
++CONFIG_MTK_SNFI_SPI=y
++CONFIG_SYSRESET=y
++CONFIG_SPL_SYSRESET=y
++CONFIG_SYSRESET_WATCHDOG=y
++CONFIG_USB=y
++CONFIG_DM_USB=y
++# CONFIG_SPL_DM_USB is not set
++CONFIG_USB_XHCI_HCD=y
++CONFIG_USB_XHCI_MTK=y
++CONFIG_USB_STORAGE=y
++CONFIG_WDT_MTK=y
++CONFIG_FAT_WRITE=y
++CONFIG_LZMA=y
++CONFIG_SPL_LZMA=y
++# CONFIG_EFI_LOADER is not set
+--- a/include/configs/mt7629.h
++++ b/include/configs/mt7629.h
+@@ -30,12 +30,19 @@
+ 
+ /* Defines for SPL */
+ #define CONFIG_SPL_STACK		0x106000
++#ifdef CONFIG_MT7629_BOOT_FROM_SNAND
++#define CONFIG_SPL_MAX_SIZE		SZ_128K
++#define CONFIG_SPL_MAX_FOOTPRINT	SZ_128K
++#define CONFIG_SPL_PAD_TO		0x20000
++#define CONFIG_SYS_NAND_U_BOOT_OFFS	CONFIG_SPL_PAD_TO
++#else
+ #define CONFIG_SPL_MAX_SIZE		SZ_64K
+ #define CONFIG_SPL_MAX_FOOTPRINT	SZ_64K
+ #define CONFIG_SPL_PAD_TO		0x10000
+ 
+ #define CONFIG_SPI_ADDR			0x30000000
+ #define CONFIG_SYS_UBOOT_BASE		(CONFIG_SPI_ADDR + CONFIG_SPL_PAD_TO)
++#endif
+ 
+ /* SPL -> Uboot */
+ #define CONFIG_SYS_INIT_SP_ADDR		(CONFIG_SYS_TEXT_BASE + SZ_2M - \
diff --git a/package/boot/uboot-mediatek/patches/000-mtk-18-board-mt7622-use-new-spi-nand-driver.patch b/package/boot/uboot-mediatek/patches/000-mtk-18-board-mt7622-use-new-spi-nand-driver.patch
new file mode 100644
index 0000000000..241e873497
--- /dev/null
+++ b/package/boot/uboot-mediatek/patches/000-mtk-18-board-mt7622-use-new-spi-nand-driver.patch
@@ -0,0 +1,76 @@
+From 6bcd65ed47844e747ff6db066b092632f1760256 Mon Sep 17 00:00:00 2001
+From: Weijie Gao <weijie.gao@mediatek.com>
+Date: Wed, 3 Mar 2021 10:51:43 +0800
+Subject: [PATCH 08/12] board: mt7622: use new spi-nand driver
+
+Enable new spi-nand driver support for mt7622_rfb_defconfig
+
+Signed-off-by: Weijie Gao <weijie.gao@mediatek.com>
+---
+ arch/arm/dts/mt7622-rfb.dts  |  7 +++++++
+ arch/arm/dts/mt7622.dtsi     | 16 ++++++++++++++++
+ configs/mt7622_rfb_defconfig |  5 +++++
+ 3 files changed, 28 insertions(+)
+
+--- a/arch/arm/dts/mt7622-rfb.dts
++++ b/arch/arm/dts/mt7622-rfb.dts
+@@ -188,6 +188,13 @@
+ 	};
+ };
+ 
++&snand {
++	pinctrl-names = "default";
++	pinctrl-0 = <&snfi_pins>;
++	status = "okay";
++	quad-spi;
++};
++
+ &uart0 {
+ 	pinctrl-names = "default";
+ 	pinctrl-0 = <&uart0_pins>;
+--- a/arch/arm/dts/mt7622.dtsi
++++ b/arch/arm/dts/mt7622.dtsi
+@@ -53,6 +53,22 @@
+ 		#size-cells = <0>;
+ 	};
+ 
++	snand: snand@1100d000 {
++		compatible = "mediatek,mt7622-snand";
++		reg = <0x1100d000 0x1000>,
++		      <0x1100e000 0x1000>;
++		reg-names = "nfi", "ecc";
++		clocks = <&pericfg CLK_PERI_NFI_PD>,
++			 <&pericfg CLK_PERI_SNFI_PD>,
++			 <&pericfg CLK_PERI_NFIECC_PD>;
++		clock-names = "nfi_clk", "pad_clk", "ecc_clk";
++		assigned-clocks = <&topckgen CLK_TOP_AXI_SEL>,
++				  <&topckgen CLK_TOP_NFI_INFRA_SEL>;
++		assigned-clock-parents = <&topckgen CLK_TOP_SYSPLL1_D2>,
++					 <&topckgen CLK_TOP_UNIVPLL2_D8>;
++		status = "disabled";
++	};
++
+ 	snor: snor@11014000 {
+ 		compatible = "mediatek,mtk-snor";
+ 		reg = <0x11014000 0x1000>;
+--- a/configs/mt7622_rfb_defconfig
++++ b/configs/mt7622_rfb_defconfig
+@@ -15,6 +15,7 @@ CONFIG_LOG=y
+ CONFIG_SYS_PROMPT="MT7622> "
+ CONFIG_CMD_BOOTMENU=y
+ CONFIG_CMD_MMC=y
++CONFIG_CMD_MTD=y
+ CONFIG_CMD_PCI=y
+ CONFIG_CMD_SF_TEST=y
+ CONFIG_CMD_PING=y
+@@ -27,6 +28,10 @@ CONFIG_SYSCON=y
+ CONFIG_CLK=y
+ CONFIG_MMC_HS200_SUPPORT=y
+ CONFIG_MMC_MTK=y
++CONFIG_MTD=y
++CONFIG_DM_MTD=y
++CONFIG_MTK_SPI_NAND=y
++CONFIG_MTK_SPI_NAND_MTD=y
+ CONFIG_DM_SPI_FLASH=y
+ CONFIG_SPI_FLASH_EON=y
+ CONFIG_SPI_FLASH_GIGADEVICE=y
diff --git a/package/boot/uboot-mediatek/patches/000-mtk-19-configs-mt7629-remove-unused-options-and-add-dm-comm.patch b/package/boot/uboot-mediatek/patches/000-mtk-19-configs-mt7629-remove-unused-options-and-add-dm-comm.patch
new file mode 100644
index 0000000000..a1e656d59c
--- /dev/null
+++ b/package/boot/uboot-mediatek/patches/000-mtk-19-configs-mt7629-remove-unused-options-and-add-dm-comm.patch
@@ -0,0 +1,31 @@
+From 632f09f140610cf45da1dba25c66e9ca79a70a15 Mon Sep 17 00:00:00 2001
+From: Weijie Gao <weijie.gao@mediatek.com>
+Date: Wed, 3 Mar 2021 12:12:39 +0800
+Subject: [PATCH 09/12] configs: mt7629: remove unused options and add dm
+ command
+
+Remove unused bootm options
+Add dm command
+
+Signed-off-by: Weijie Gao <weijie.gao@mediatek.com>
+---
+ configs/mt7629_rfb_defconfig | 5 +++++
+ 1 file changed, 5 insertions(+)
+
+--- a/configs/mt7629_rfb_defconfig
++++ b/configs/mt7629_rfb_defconfig
+@@ -28,9 +28,14 @@ CONFIG_SPL_WATCHDOG=y
+ CONFIG_HUSH_PARSER=y
+ CONFIG_SYS_PROMPT="U-Boot> "
+ CONFIG_CMD_BOOTMENU=y
++# CONFIG_BOOTM_NETBSD is not set
++# CONFIG_BOOTM_PLAN9 is not set
++# CONFIG_BOOTM_RTEMS is not set
++# CONFIG_BOOTM_VXWORKS is not set
+ # CONFIG_CMD_ELF is not set
+ # CONFIG_CMD_XIMG is not set
+ CONFIG_CMD_BIND=y
++CONFIG_CMD_DM=y
+ # CONFIG_CMD_FLASH is not set
+ CONFIG_CMD_GPIO=y
+ CONFIG_CMD_SF_TEST=y
diff --git a/package/boot/uboot-mediatek/patches/000-mtk-20-configs-mt7622-enable-environment-for-mt7622_rfb.patch b/package/boot/uboot-mediatek/patches/000-mtk-20-configs-mt7622-enable-environment-for-mt7622_rfb.patch
new file mode 100644
index 0000000000..c38b7bbe67
--- /dev/null
+++ b/package/boot/uboot-mediatek/patches/000-mtk-20-configs-mt7622-enable-environment-for-mt7622_rfb.patch
@@ -0,0 +1,33 @@
+From 93d7086edb0db4b05149dfea21a2a82d8f160944 Mon Sep 17 00:00:00 2001
+From: Weijie Gao <weijie.gao@mediatek.com>
+Date: Sat, 6 Mar 2021 16:29:33 +0800
+Subject: [PATCH 10/12] configs: mt7622: enable environment for mt7622_rfb
+
+Enable environment vairables for mt7622_rfb
+
+Signed-off-by: Weijie Gao <weijie.gao@mediatek.com>
+---
+ configs/mt7622_rfb_defconfig | 5 +++++
+ 1 file changed, 5 insertions(+)
+
+--- a/configs/mt7622_rfb_defconfig
++++ b/configs/mt7622_rfb_defconfig
+@@ -5,6 +5,8 @@ CONFIG_SYS_TEXT_BASE=0x41e00000
+ CONFIG_SYS_MALLOC_F_LEN=0x4000
+ CONFIG_NR_DRAM_BANKS=1
+ CONFIG_DEFAULT_DEVICE_TREE="mt7622-rfb"
++CONFIG_ENV_SIZE=0x20000
++CONFIG_ENV_OFFSET=0x280000
+ CONFIG_DEBUG_UART_BASE=0x11002000
+ CONFIG_DEBUG_UART_CLOCK=25000000
+ CONFIG_DEBUG_UART=y
+@@ -21,6 +23,9 @@ CONFIG_CMD_SF_TEST=y
+ CONFIG_CMD_PING=y
+ CONFIG_CMD_SMC=y
+ CONFIG_ENV_OVERWRITE=y
++CONFIG_ENV_IS_IN_MTD=y
++CONFIG_ENV_MTD_NAME="spi-nand0"
++CONFIG_ENV_SIZE_REDUND=0x40000
+ CONFIG_ENV_VARS_UBOOT_RUNTIME_CONFIG=y
+ CONFIG_NET_RANDOM_ETHADDR=y
+ CONFIG_REGMAP=y
diff --git a/package/boot/uboot-mediatek/patches/002-nand-add-spi-nand-driver.patch b/package/boot/uboot-mediatek/patches/002-nand-add-spi-nand-driver.patch
deleted file mode 100644
index dc3ebaf7af..0000000000
--- a/package/boot/uboot-mediatek/patches/002-nand-add-spi-nand-driver.patch
+++ /dev/null
@@ -1,8659 +0,0 @@
-From de8b6cf615be20b25d0f3c817866de2c0d46a704 Mon Sep 17 00:00:00 2001
-From: Sam Shih <sam.shih@mediatek.com>
-Date: Mon, 20 Apr 2020 17:10:05 +0800
-Subject: [PATCH 1/3] nand: add spi nand driver
-
-Add spi nand driver support for mt7622 based on nfi controller
-
-Signed-off-by: Xiangsheng Hou <xiangsheng.hou@mediatek.com>
----
- drivers/mtd/Kconfig                           |    7 +
- drivers/mtd/Makefile                          |    4 +
- drivers/mtd/nand/raw/nand.c                   |    2 +
- drivers/mtd/nandx/NOTICE                      |   52 +
- drivers/mtd/nandx/Nandx.config                |   17 +
- drivers/mtd/nandx/Nandx.mk                    |   91 ++
- drivers/mtd/nandx/README                      |   31 +
- drivers/mtd/nandx/core/Nandx.mk               |   38 +
- drivers/mtd/nandx/core/core_io.c              |  735 +++++++++
- drivers/mtd/nandx/core/core_io.h              |   39 +
- drivers/mtd/nandx/core/nand/device_spi.c      |  200 +++
- drivers/mtd/nandx/core/nand/device_spi.h      |  132 ++
- drivers/mtd/nandx/core/nand/nand_spi.c        |  526 +++++++
- drivers/mtd/nandx/core/nand/nand_spi.h        |   35 +
- drivers/mtd/nandx/core/nand_base.c            |  304 ++++
- drivers/mtd/nandx/core/nand_base.h            |   71 +
- drivers/mtd/nandx/core/nand_chip.c            |  272 ++++
- drivers/mtd/nandx/core/nand_chip.h            |  103 ++
- drivers/mtd/nandx/core/nand_device.c          |  285 ++++
- drivers/mtd/nandx/core/nand_device.h          |  608 ++++++++
- drivers/mtd/nandx/core/nfi.h                  |   51 +
- drivers/mtd/nandx/core/nfi/nfi_base.c         | 1357 +++++++++++++++++
- drivers/mtd/nandx/core/nfi/nfi_base.h         |   95 ++
- drivers/mtd/nandx/core/nfi/nfi_regs.h         |  114 ++
- drivers/mtd/nandx/core/nfi/nfi_spi.c          |  689 +++++++++
- drivers/mtd/nandx/core/nfi/nfi_spi.h          |   44 +
- drivers/mtd/nandx/core/nfi/nfi_spi_regs.h     |   64 +
- drivers/mtd/nandx/core/nfi/nfiecc.c           |  510 +++++++
- drivers/mtd/nandx/core/nfi/nfiecc.h           |   90 ++
- drivers/mtd/nandx/core/nfi/nfiecc_regs.h      |   51 +
- drivers/mtd/nandx/driver/Nandx.mk             |   18 +
- drivers/mtd/nandx/driver/bbt/bbt.c            |  408 +++++
- drivers/mtd/nandx/driver/uboot/driver.c       |  574 +++++++
- drivers/mtd/nandx/include/Nandx.mk            |   16 +
- drivers/mtd/nandx/include/internal/bbt.h      |   62 +
- .../mtd/nandx/include/internal/nandx_core.h   |  250 +++
- .../mtd/nandx/include/internal/nandx_errno.h  |   40 +
- .../mtd/nandx/include/internal/nandx_util.h   |  221 +++
- drivers/mtd/nandx/include/uboot/nandx_os.h    |   78 +
- include/configs/mt7622.h                      |   25 +
- 40 files changed, 8309 insertions(+)
- create mode 100644 drivers/mtd/nandx/NOTICE
- create mode 100644 drivers/mtd/nandx/Nandx.config
- create mode 100644 drivers/mtd/nandx/Nandx.mk
- create mode 100644 drivers/mtd/nandx/README
- create mode 100644 drivers/mtd/nandx/core/Nandx.mk
- create mode 100644 drivers/mtd/nandx/core/core_io.c
- create mode 100644 drivers/mtd/nandx/core/core_io.h
- create mode 100644 drivers/mtd/nandx/core/nand/device_spi.c
- create mode 100644 drivers/mtd/nandx/core/nand/device_spi.h
- create mode 100644 drivers/mtd/nandx/core/nand/nand_spi.c
- create mode 100644 drivers/mtd/nandx/core/nand/nand_spi.h
- create mode 100644 drivers/mtd/nandx/core/nand_base.c
- create mode 100644 drivers/mtd/nandx/core/nand_base.h
- create mode 100644 drivers/mtd/nandx/core/nand_chip.c
- create mode 100644 drivers/mtd/nandx/core/nand_chip.h
- create mode 100644 drivers/mtd/nandx/core/nand_device.c
- create mode 100644 drivers/mtd/nandx/core/nand_device.h
- create mode 100644 drivers/mtd/nandx/core/nfi.h
- create mode 100644 drivers/mtd/nandx/core/nfi/nfi_base.c
- create mode 100644 drivers/mtd/nandx/core/nfi/nfi_base.h
- create mode 100644 drivers/mtd/nandx/core/nfi/nfi_regs.h
- create mode 100644 drivers/mtd/nandx/core/nfi/nfi_spi.c
- create mode 100644 drivers/mtd/nandx/core/nfi/nfi_spi.h
- create mode 100644 drivers/mtd/nandx/core/nfi/nfi_spi_regs.h
- create mode 100644 drivers/mtd/nandx/core/nfi/nfiecc.c
- create mode 100644 drivers/mtd/nandx/core/nfi/nfiecc.h
- create mode 100644 drivers/mtd/nandx/core/nfi/nfiecc_regs.h
- create mode 100644 drivers/mtd/nandx/driver/Nandx.mk
- create mode 100644 drivers/mtd/nandx/driver/bbt/bbt.c
- create mode 100644 drivers/mtd/nandx/driver/uboot/driver.c
- create mode 100644 drivers/mtd/nandx/include/Nandx.mk
- create mode 100644 drivers/mtd/nandx/include/internal/bbt.h
- create mode 100644 drivers/mtd/nandx/include/internal/nandx_core.h
- create mode 100644 drivers/mtd/nandx/include/internal/nandx_errno.h
- create mode 100644 drivers/mtd/nandx/include/internal/nandx_util.h
- create mode 100644 drivers/mtd/nandx/include/uboot/nandx_os.h
-
-diff --git a/drivers/mtd/Kconfig b/drivers/mtd/Kconfig
-index 5e7571cf3d..34a59b44b9 100644
---- a/drivers/mtd/Kconfig
-+++ b/drivers/mtd/Kconfig
-@@ -101,6 +101,13 @@ config HBMC_AM654
- 	 This is the driver for HyperBus controller on TI's AM65x and
- 	 other SoCs
- 
-+config MTK_SPI_NAND
-+	tristate "Mediatek SPI Nand"
-+	depends on DM_MTD
-+	help
-+	  This option will support SPI Nand device via Mediatek
-+	  NFI controller.
-+
- source "drivers/mtd/nand/Kconfig"
- 
- source "drivers/mtd/spi/Kconfig"
-diff --git a/drivers/mtd/Makefile b/drivers/mtd/Makefile
-index 318788c5e2..1df1031b23 100644
---- a/drivers/mtd/Makefile
-+++ b/drivers/mtd/Makefile
-@@ -41,3 +41,7 @@ obj-$(CONFIG_$(SPL_TPL_)SPI_FLASH_SUPPORT) += spi/
- obj-$(CONFIG_SPL_UBI) += ubispl/
- 
- endif
-+
-+ifeq ($(CONFIG_MTK_SPI_NAND), y)
-+include $(srctree)/drivers/mtd/nandx/Nandx.mk
-+endif
-diff --git a/drivers/mtd/nand/raw/nand.c b/drivers/mtd/nand/raw/nand.c
-index 026419e4e6..4be0c7d8f3 100644
---- a/drivers/mtd/nand/raw/nand.c
-+++ b/drivers/mtd/nand/raw/nand.c
-@@ -91,8 +91,10 @@ static void nand_init_chip(int i)
- 	if (board_nand_init(nand))
- 		return;
- 
-+#ifndef CONFIG_MTK_SPI_NAND
- 	if (nand_scan(mtd, maxchips))
- 		return;
-+#endif
- 
- 	nand_register(i, mtd);
- }
-diff --git a/drivers/mtd/nandx/NOTICE b/drivers/mtd/nandx/NOTICE
-new file mode 100644
-index 0000000000..1a06ca3867
---- /dev/null
-+++ b/drivers/mtd/nandx/NOTICE
-@@ -0,0 +1,52 @@
-+
-+/*
-+ * Nandx - Mediatek Common Nand Driver
-+ * Copyright (C) 2017 MediaTek Inc.
-+ *
-+ * Nandx is dual licensed: you can use it either under the terms of
-+ * the GPL, or the BSD license, at your option.
-+ *
-+ *  a) This program is free software; you can redistribute it and/or modify
-+ *     it under the terms of the GNU General Public License version 2 as
-+ *     published by the Free Software Foundation.
-+ *
-+ *     This library is distributed in the hope that it will be useful,
-+ *     but WITHOUT ANY WARRANTY; without even the implied warranty of
-+ *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-+ *     GNU General Public License for more details.
-+ *
-+ *     This program is distributed in the hope that it will be useful,
-+ *     but WITHOUT ANY WARRANTY; without even the implied warranty of
-+ *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
-+ *     See http://www.gnu.org/licenses/gpl-2.0.html for more details.
-+ *
-+ * Alternatively,
-+ *
-+ *  b) Redistribution and use in source and binary forms, with or
-+ *     without modification, are permitted provided that the following
-+ *     conditions are met:
-+ *
-+ *     1. Redistributions of source code must retain the above
-+ *        copyright notice, this list of conditions and the following
-+ *        disclaimer.
-+ *     2. Redistributions in binary form must reproduce the above
-+ *        copyright notice, this list of conditions and the following
-+ *        disclaimer in the documentation and/or other materials
-+ *        provided with the distribution.
-+ *
-+ *     THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND
-+ *     CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
-+ *     INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
-+ *     MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-+ *     DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
-+ *     CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-+ *     SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
-+ *     NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
-+ *     LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
-+ *     HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
-+ *     CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
-+ *     OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
-+ *     EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-+ */
-+
-+####################################################################################################
-\ No newline at end of file
-diff --git a/drivers/mtd/nandx/Nandx.config b/drivers/mtd/nandx/Nandx.config
-new file mode 100644
-index 0000000000..35705ee28d
---- /dev/null
-+++ b/drivers/mtd/nandx/Nandx.config
-@@ -0,0 +1,17 @@
-+NANDX_SIMULATOR_SUPPORT := n
-+NANDX_CTP_SUPPORT := n
-+NANDX_DA_SUPPORT := n
-+NANDX_PRELOADER_SUPPORT := n
-+NANDX_LK_SUPPORT := n
-+NANDX_KERNEL_SUPPORT := n
-+NANDX_BROM_SUPPORT := n
-+NANDX_UBOOT_SUPPORT := y
-+NANDX_BBT_SUPPORT := y
-+
-+NANDX_NAND_SPI := y
-+NANDX_NAND_SLC := n
-+NANDX_NAND_MLC := n
-+NANDX_NAND_TLC := n
-+NANDX_NFI_BASE := y
-+NANDX_NFI_ECC := y
-+NANDX_NFI_SPI := y
-diff --git a/drivers/mtd/nandx/Nandx.mk b/drivers/mtd/nandx/Nandx.mk
-new file mode 100644
-index 0000000000..f5a6f2a628
---- /dev/null
-+++ b/drivers/mtd/nandx/Nandx.mk
-@@ -0,0 +1,91 @@
-+#
-+# Copyright (C) 2017 MediaTek Inc.
-+# Licensed under either
-+#     BSD Licence, (see NOTICE for more details)
-+#     GNU General Public License, version 2.0, (see NOTICE for more details)
-+#
-+
-+nandx_dir := $(shell dirname $(lastword $(MAKEFILE_LIST)))
-+include $(nandx_dir)/Nandx.config
-+
-+ifeq ($(NANDX_SIMULATOR_SUPPORT), y)
-+sim-obj :=
-+sim-inc :=
-+nandx-obj := sim-obj
-+nandx-prefix := .
-+nandx-postfix := %.o
-+sim-inc += -I$(nandx-prefix)/include/internal
-+sim-inc += -I$(nandx-prefix)/include/simulator
-+endif
-+
-+ifeq ($(NANDX_CTP_SUPPORT), y)
-+nandx-obj := C_SRC_FILES
-+nandx-prefix := $(nandx_dir)
-+nandx-postfix := %.c
-+INC_DIRS += $(nandx_dir)/include/internal
-+INC_DIRS += $(nandx_dir)/include/ctp
-+endif
-+
-+ifeq ($(NANDX_DA_SUPPORT), y)
-+nandx-obj := obj-y
-+nandx-prefix := $(nandx_dir)
-+nandx-postfix := %.o
-+INCLUDE_PATH += $(TOPDIR)/platform/$(CODE_BASE)/dev/nand/nandx/include/internal
-+INCLUDE_PATH += $(TOPDIR)/platform/$(CODE_BASE)/dev/nand/nandx/include/da
-+endif
-+
-+ifeq ($(NANDX_PRELOADER_SUPPORT), y)
-+nandx-obj := MOD_SRC
-+nandx-prefix := $(nandx_dir)
-+nandx-postfix := %.c
-+C_OPTION += -I$(MTK_PATH_PLATFORM)/src/drivers/nandx/include/internal
-+C_OPTION += -I$(MTK_PATH_PLATFORM)/src/drivers/nandx/include/preloader
-+endif
-+
-+ifeq ($(NANDX_LK_SUPPORT), y)
-+nandx-obj := MODULE_SRCS
-+nandx-prefix := $(nandx_dir)
-+nandx-postfix := %.c
-+GLOBAL_INCLUDES += $(nandx_dir)/include/internal
-+GLOBAL_INCLUDES += $(nandx_dir)/include/lk
-+endif
-+
-+ifeq ($(NANDX_KERNEL_SUPPORT), y)
-+nandx-obj := obj-y
-+nandx-prefix := nandx
-+nandx-postfix := %.o
-+ccflags-y += -I$(nandx_dir)/include/internal
-+ccflags-y += -I$(nandx_dir)/include/kernel
-+endif
-+
-+ifeq ($(NANDX_UBOOT_SUPPORT), y)
-+nandx-obj := obj-y
-+nandx-prefix := nandx
-+nandx-postfix := %.o
-+ccflags-y += -I$(nandx_dir)/include/internal
-+ccflags-y += -I$(nandx_dir)/include/uboot
-+endif
-+
-+nandx-y :=
-+include $(nandx_dir)/core/Nandx.mk
-+nandx-target := $(nandx-prefix)/core/$(nandx-postfix)
-+$(nandx-obj) += $(patsubst %.c, $(nandx-target), $(nandx-y))
-+
-+
-+nandx-y :=
-+include $(nandx_dir)/driver/Nandx.mk
-+nandx-target := $(nandx-prefix)/driver/$(nandx-postfix)
-+$(nandx-obj) += $(patsubst %.c, $(nandx-target), $(nandx-y))
-+
-+ifeq ($(NANDX_SIMULATOR_SUPPORT), y)
-+cc := gcc
-+CFLAGS += $(sim-inc)
-+
-+.PHONY:nandx
-+nandx: $(sim-obj)
-+	$(cc)  $(sim-obj) -o nandx
-+
-+.PHONY:clean
-+clean:
-+	rm -rf $(sim-obj) nandx
-+endif
-diff --git a/drivers/mtd/nandx/README b/drivers/mtd/nandx/README
-new file mode 100644
-index 0000000000..0feaeaeb88
---- /dev/null
-+++ b/drivers/mtd/nandx/README
-@@ -0,0 +1,31 @@
-+
-+                          NAND2.0
-+                ===============================
-+
-+    NAND2.0 is a common nand driver which designed for accessing
-+different type of NANDs(SLC, SPI-NAND, MLC, TLC) on various OS. This
-+driver can work on mostly SoCs of Mediatek.
-+
-+    Although there already has a common nand driver, it doesn't cover
-+SPI-NAND, and not match our IC-Verification's reqirement. We need
-+a driver that can be exten or cut easily.
-+
-+    This driver is base on NANDX & SLC. We try to refactor structures,
-+and make them inheritable. We also refactor some operations' flow
-+principally for adding SPI-NAND support.
-+
-+    This driver's architecture is like:
-+
-+          Driver @LK/Uboot/DA...           |IC verify/other purposes
-+    ----------------------------------------------------------------
-+      partition       |        BBM         |
-+    -------------------------------------- |       extend_core
-+             nandx_core/core_io            |
-+    ----------------------------------------------------------------
-+             nand_chip/nand_base           |
-+    -------------------------------------- |        extend_nfi
-+      nand_device     |    nfi/nfi_base    |
-+
-+    Any block of above graph can be extended at your will, if you
-+want add new feature into this code, please make sure that your code
-+would follow the framework, and we will be appreciated about it.
-diff --git a/drivers/mtd/nandx/core/Nandx.mk b/drivers/mtd/nandx/core/Nandx.mk
-new file mode 100644
-index 0000000000..7a5661c044
---- /dev/null
-+++ b/drivers/mtd/nandx/core/Nandx.mk
-@@ -0,0 +1,38 @@
-+#
-+# Copyright (C) 2017 MediaTek Inc.
-+# Licensed under either
-+#     BSD Licence, (see NOTICE for more details)
-+#     GNU General Public License, version 2.0, (see NOTICE for more details)
-+#
-+
-+nandx-y += nand_device.c
-+nandx-y += nand_base.c
-+nandx-y += nand_chip.c
-+nandx-y += core_io.c
-+
-+nandx-header-y += nand_device.h
-+nandx-header-y += nand_base.h
-+nandx-header-y += nand_chip.h
-+nandx-header-y += core_io.h
-+nandx-header-y += nfi.h
-+
-+nandx-$(NANDX_NAND_SPI) += nand/device_spi.c
-+nandx-$(NANDX_NAND_SPI) += nand/nand_spi.c
-+nandx-$(NANDX_NAND_SLC) += nand/device_slc.c
-+nandx-$(NANDX_NAND_SLC) += nand/nand_slc.c
-+
-+nandx-header-$(NANDX_NAND_SPI) += nand/device_spi.h
-+nandx-header-$(NANDX_NAND_SPI) += nand/nand_spi.h
-+nandx-header-$(NANDX_NAND_SLC) += nand/device_slc.h
-+nandx-header-$(NANDX_NAND_SLC) += nand/nand_slc.h
-+
-+nandx-$(NANDX_NFI_BASE) += nfi/nfi_base.c
-+nandx-$(NANDX_NFI_ECC) += nfi/nfiecc.c
-+nandx-$(NANDX_NFI_SPI) += nfi/nfi_spi.c
-+
-+nandx-header-$(NANDX_NFI_BASE) += nfi/nfi_base.h
-+nandx-header-$(NANDX_NFI_BASE) += nfi/nfi_regs.h
-+nandx-header-$(NANDX_NFI_ECC) += nfi/nfiecc.h
-+nandx-header-$(NANDX_NFI_ECC) += nfi/nfiecc_regs.h
-+nandx-header-$(NANDX_NFI_SPI) += nfi/nfi_spi.h
-+nandx-header-$(NANDX_NFI_SPI) += nfi/nfi_spi_regs.h
-diff --git a/drivers/mtd/nandx/core/core_io.c b/drivers/mtd/nandx/core/core_io.c
-new file mode 100644
-index 0000000000..716eeed38d
---- /dev/null
-+++ b/drivers/mtd/nandx/core/core_io.c
-@@ -0,0 +1,735 @@
-+/*
-+ * Copyright (C) 2017 MediaTek Inc.
-+ * Licensed under either
-+ *     BSD Licence, (see NOTICE for more details)
-+ *     GNU General Public License, version 2.0, (see NOTICE for more details)
-+ */
-+
-+/*NOTE: switch cache/multi*/
-+#include "nandx_util.h"
-+#include "nandx_core.h"
-+#include "nand_chip.h"
-+#include "core_io.h"
-+
-+static struct nandx_desc *g_nandx;
-+
-+static inline bool is_sector_align(u64 val)
-+{
-+	return reminder(val, g_nandx->chip->sector_size) ? false : true;
-+}
-+
-+static inline bool is_page_align(u64 val)
-+{
-+	return reminder(val, g_nandx->chip->page_size) ? false : true;
-+}
-+
-+static inline bool is_block_align(u64 val)
-+{
-+	return reminder(val, g_nandx->chip->block_size) ? false : true;
-+}
-+
-+static inline u32 page_sectors(void)
-+{
-+	return div_down(g_nandx->chip->page_size, g_nandx->chip->sector_size);
-+}
-+
-+static inline u32 sector_oob(void)
-+{
-+	return div_down(g_nandx->chip->oob_size, page_sectors());
-+}
-+
-+static inline u32 sector_padded_size(void)
-+{
-+	return g_nandx->chip->sector_size + g_nandx->chip->sector_spare_size;
-+}
-+
-+static inline u32 page_padded_size(void)
-+{
-+	return page_sectors() * sector_padded_size();
-+}
-+
-+static inline u32 offset_to_padded_col(u64 offset)
-+{
-+	struct nandx_desc *nandx = g_nandx;
-+	u32 col, sectors;
-+
-+	col = reminder(offset, nandx->chip->page_size);
-+	sectors = div_down(col, nandx->chip->sector_size);
-+
-+	return col + sectors * nandx->chip->sector_spare_size;
-+}
-+
-+static inline u32 offset_to_row(u64 offset)
-+{
-+	return div_down(offset, g_nandx->chip->page_size);
-+}
-+
-+static inline u32 offset_to_col(u64 offset)
-+{
-+	return reminder(offset, g_nandx->chip->page_size);
-+}
-+
-+static inline u32 oob_upper_size(void)
-+{
-+	return g_nandx->ecc_en ? g_nandx->chip->oob_size :
-+	       g_nandx->chip->sector_spare_size * page_sectors();
-+}
-+
-+static inline bool is_upper_oob_align(u64 val)
-+{
-+	return reminder(val, oob_upper_size()) ? false : true;
-+}
-+
-+#define prepare_op(_op, _row, _col, _len, _data, _oob) \
-+	do { \
-+		(_op).row = (_row); \
-+		(_op).col = (_col); \
-+		(_op).len = (_len); \
-+		(_op).data = (_data); \
-+		(_op).oob = (_oob); \
-+	} while (0)
-+
-+static int operation_multi(enum nandx_op_mode mode, u8 *data, u8 *oob,
-+			   u64 offset, size_t len)
-+{
-+	struct nandx_desc *nandx = g_nandx;
-+	u32 row = offset_to_row(offset);
-+	u32 col = offset_to_padded_col(offset);
-+
-+	if (nandx->mode == NANDX_IDLE) {
-+		nandx->mode = mode;
-+		nandx->ops_current = 0;
-+	} else if (nandx->mode != mode) {
-+		pr_info("forbid mixed operations.\n");
-+		return -EOPNOTSUPP;
-+	}
-+
-+	prepare_op(nandx->ops[nandx->ops_current], row, col, len, data, oob);
-+	nandx->ops_current++;
-+
-+	if (nandx->ops_current == nandx->ops_multi_len)
-+		return nandx_sync();
-+
-+	return nandx->ops_multi_len - nandx->ops_current;
-+}
-+
-+static int operation_sequent(enum nandx_op_mode mode, u8 *data, u8 *oob,
-+			     u64 offset, size_t len)
-+{
-+	struct nandx_desc *nandx = g_nandx;
-+	struct nand_chip *chip = nandx->chip;
-+	u32 row = offset_to_row(offset);
-+	func_chip_ops chip_ops;
-+	u8 *ref_data = data, *ref_oob = oob;
-+	int align, ops, row_step;
-+	int i, rem;
-+
-+	align = data ? chip->page_size : oob_upper_size();
-+	ops = data ? div_down(len, align) : div_down(len, oob_upper_size());
-+	row_step = 1;
-+
-+	switch (mode) {
-+	case NANDX_ERASE:
-+		chip_ops = chip->erase_block;
-+		align = chip->block_size;
-+		ops = div_down(len, align);
-+		row_step = chip->block_pages;
-+		break;
-+
-+	case NANDX_READ:
-+		chip_ops = chip->read_page;
-+		break;
-+
-+	case NANDX_WRITE:
-+		chip_ops = chip->write_page;
-+		break;
-+
-+	default:
-+		return -EINVAL;
-+	}
-+
-+	if (!data) {
-+		ref_data = nandx->head_buf;
-+		memset(ref_data, 0xff, chip->page_size);
-+	}
-+
-+	if (!oob) {
-+		ref_oob = nandx->head_buf + chip->page_size;
-+		memset(ref_oob, 0xff, oob_upper_size());
-+	}
-+
-+	for (i = 0; i < ops; i++) {
-+		prepare_op(nandx->ops[nandx->ops_current],
-+			   row + i * row_step, 0, align, ref_data, ref_oob);
-+		nandx->ops_current++;
-+		/* if data or oob is null, nandx->head_buf or
-+		 * nandx->head_buf + chip->page_size should not been used
-+		 * so, here it is safe to use the buf.
-+		 */
-+		ref_data = data ? ref_data + chip->page_size : nandx->head_buf;
-+		ref_oob = oob ? ref_oob + oob_upper_size() :
-+			  nandx->head_buf + chip->page_size;
-+	}
-+
-+	if (nandx->mode == NANDX_WRITE) {
-+		rem = reminder(nandx->ops_current, nandx->min_write_pages);
-+		if (rem)
-+			return nandx->min_write_pages - rem;
-+	}
-+
-+	nandx->ops_current = 0;
-+	return chip_ops(chip, nandx->ops, ops);
-+}
-+
-+static int read_pages(u8 *data, u8 *oob, u64 offset, size_t len)
-+{
-+	struct nandx_desc *nandx = g_nandx;
-+	struct nand_chip *chip = nandx->chip;
-+	struct nandx_split64 split = {0};
-+	u8 *ref_data = data, *ref_oob;
-+	u32 row, col;
-+	int ret = 0, i, ops;
-+	u32 head_offset = 0;
-+	u64 val;
-+
-+	if (!data)
-+		return operation_sequent(NANDX_READ, NULL, oob, offset, len);
-+
-+	ref_oob = oob ? oob : nandx->head_buf + chip->page_size;
-+
-+	nandx_split(&split, offset, len, val, chip->page_size);
-+
-+	if (split.head_len) {
-+		row = offset_to_row(split.head);
-+		col = offset_to_col(split.head);
-+		prepare_op(nandx->ops[nandx->ops_current], row, 0,
-+			   chip->page_size,
-+			   nandx->head_buf, ref_oob);
-+		nandx->ops_current++;
-+
-+		head_offset = col;
-+
-+		ref_data += split.head_len;
-+		ref_oob = oob ? ref_oob + oob_upper_size() :
-+			  nandx->head_buf + chip->page_size;
-+	}
-+
-+	if (split.body_len) {
-+		ops = div_down(split.body_len, chip->page_size);
-+		row = offset_to_row(split.body);
-+		for (i = 0; i < ops; i++) {
-+			prepare_op(nandx->ops[nandx->ops_current],
-+				   row + i, 0, chip->page_size,
-+				   ref_data, ref_oob);
-+			nandx->ops_current++;
-+			ref_data += chip->page_size;
-+			ref_oob = oob ? ref_oob + oob_upper_size() :
-+				  nandx->head_buf + chip->page_size;
-+		}
-+	}
-+
-+	if (split.tail_len) {
-+		row = offset_to_row(split.tail);
-+		prepare_op(nandx->ops[nandx->ops_current], row, 0,
-+			   chip->page_size, nandx->tail_buf, ref_oob);
-+		nandx->ops_current++;
-+	}
-+
-+	ret = chip->read_page(chip, nandx->ops, nandx->ops_current);
-+
-+	if (split.head_len)
-+		memcpy(data, nandx->head_buf + head_offset, split.head_len);
-+	if (split.tail_len)
-+		memcpy(ref_data, nandx->tail_buf, split.tail_len);
-+
-+	nandx->ops_current = 0;
-+	return ret;
-+}
-+
-+int nandx_read(u8 *data, u8 *oob, u64 offset, size_t len)
-+{
-+	struct nandx_desc *nandx = g_nandx;
-+
-+	if (!len || len > nandx->info.total_size)
-+		return -EINVAL;
-+	if (div_up(len, nandx->chip->page_size) > nandx->ops_len)
-+		return -EINVAL;
-+	if (!data && !oob)
-+		return -EINVAL;
-+	/**
-+	 * as design, oob not support partial read
-+	 * and, the length of oob buf should be oob size aligned
-+	 */
-+	if (!data && !is_upper_oob_align(len))
-+		return -EINVAL;
-+
-+	if (g_nandx->multi_en) {
-+		/* as design, there only 2 buf for partial read,
-+		 * if partial read allowed for multi read,
-+		 * there are not enough buf
-+		 */
-+		if (!is_sector_align(offset))
-+			return -EINVAL;
-+		if (data && !is_sector_align(len))
-+			return -EINVAL;
-+		return operation_multi(NANDX_READ, data, oob, offset, len);
-+	}
-+
-+	nandx->ops_current = 0;
-+	nandx->mode = NANDX_IDLE;
-+	return read_pages(data, oob, offset, len);
-+}
-+
-+static int write_pages(u8 *data, u8 *oob, u64 offset, size_t len)
-+{
-+	struct nandx_desc *nandx = g_nandx;
-+	struct nand_chip *chip = nandx->chip;
-+	struct nandx_split64 split = {0};
-+	int ret, rem, i, ops;
-+	u32 row, col;
-+	u8 *ref_oob = oob;
-+	u64 val;
-+
-+	nandx->mode = NANDX_WRITE;
-+
-+	if (!data)
-+		return operation_sequent(NANDX_WRITE, NULL, oob, offset, len);
-+
-+	if (!oob) {
-+		ref_oob = nandx->head_buf + chip->page_size;
-+		memset(ref_oob, 0xff, oob_upper_size());
-+	}
-+
-+	nandx_split(&split, offset, len, val, chip->page_size);
-+
-+	/*NOTE: slc can support sector write, here copy too many data.*/
-+	if (split.head_len) {
-+		row = offset_to_row(split.head);
-+		col = offset_to_col(split.head);
-+		memset(nandx->head_buf, 0xff, page_padded_size());
-+		memcpy(nandx->head_buf + col, data, split.head_len);
-+		prepare_op(nandx->ops[nandx->ops_current], row, 0,
-+			   chip->page_size, nandx->head_buf, ref_oob);
-+		nandx->ops_current++;
-+
-+		data += split.head_len;
-+		ref_oob = oob ? ref_oob + oob_upper_size() :
-+			  nandx->head_buf + chip->page_size;
-+	}
-+
-+	if (split.body_len) {
-+		row = offset_to_row(split.body);
-+		ops = div_down(split.body_len, chip->page_size);
-+		for (i = 0; i < ops; i++) {
-+			prepare_op(nandx->ops[nandx->ops_current],
-+				   row + i, 0, chip->page_size, data, ref_oob);
-+			nandx->ops_current++;
-+			data += chip->page_size;
-+			ref_oob = oob ? ref_oob + oob_upper_size() :
-+				  nandx->head_buf + chip->page_size;
-+		}
-+	}
-+
-+	if (split.tail_len) {
-+		row = offset_to_row(split.tail);
-+		memset(nandx->tail_buf, 0xff, page_padded_size());
-+		memcpy(nandx->tail_buf, data, split.tail_len);
-+		prepare_op(nandx->ops[nandx->ops_current], row, 0,
-+			   chip->page_size, nandx->tail_buf, ref_oob);
-+		nandx->ops_current++;
-+	}
-+
-+	rem = reminder(nandx->ops_current, nandx->min_write_pages);
-+	if (rem)
-+		return nandx->min_write_pages - rem;
-+
-+	ret = chip->write_page(chip, nandx->ops, nandx->ops_current);
-+
-+	nandx->ops_current = 0;
-+	nandx->mode = NANDX_IDLE;
-+	return ret;
-+}
-+
-+int nandx_write(u8 *data, u8 *oob, u64 offset, size_t len)
-+{
-+	struct nandx_desc *nandx = g_nandx;
-+
-+	if (!len || len > nandx->info.total_size)
-+		return -EINVAL;
-+	if (div_up(len, nandx->chip->page_size) > nandx->ops_len)
-+		return -EINVAL;
-+	if (!data && !oob)
-+		return -EINVAL;
-+	if (!data && !is_upper_oob_align(len))
-+		return -EINVAL;
-+
-+	if (nandx->multi_en) {
-+		if (!is_page_align(offset))
-+			return -EINVAL;
-+		if (data && !is_page_align(len))
-+			return -EINVAL;
-+
-+		return operation_multi(NANDX_WRITE, data, oob, offset, len);
-+	}
-+
-+	return write_pages(data, oob, offset, len);
-+}
-+
-+int nandx_erase(u64 offset, size_t len)
-+{
-+	struct nandx_desc *nandx = g_nandx;
-+
-+	if (!len || len > nandx->info.total_size)
-+		return -EINVAL;
-+	if (div_down(len, nandx->chip->block_size) > nandx->ops_len)
-+		return -EINVAL;
-+	if (!is_block_align(offset) || !is_block_align(len))
-+		return -EINVAL;
-+
-+	if (g_nandx->multi_en)
-+		return operation_multi(NANDX_ERASE, NULL, NULL, offset, len);
-+
-+	nandx->ops_current = 0;
-+	nandx->mode = NANDX_IDLE;
-+	return operation_sequent(NANDX_ERASE, NULL, NULL, offset, len);
-+}
-+
-+int nandx_sync(void)
-+{
-+	struct nandx_desc *nandx = g_nandx;
-+	struct nand_chip *chip = nandx->chip;
-+	func_chip_ops chip_ops;
-+	int ret, i, rem;
-+
-+	if (!nandx->ops_current)
-+		return 0;
-+
-+	rem = reminder(nandx->ops_current, nandx->ops_multi_len);
-+	if (nandx->multi_en && rem) {
-+		ret = -EIO;
-+		goto error;
-+	}
-+
-+	switch (nandx->mode) {
-+	case NANDX_IDLE:
-+		return 0;
-+	case NANDX_ERASE:
-+		chip_ops = chip->erase_block;
-+		break;
-+	case NANDX_READ:
-+		chip_ops = chip->read_page;
-+		break;
-+	case NANDX_WRITE:
-+		chip_ops = chip->write_page;
-+		break;
-+	default:
-+		return -EINVAL;
-+	}
-+
-+	rem = reminder(nandx->ops_current, nandx->min_write_pages);
-+	if (!nandx->multi_en && nandx->mode == NANDX_WRITE && rem) {
-+		/* in one process of program, only allow 2 pages to do partial
-+		 * write, here we supposed 1st buf would be used, and 2nd
-+		 * buf should be not used.
-+		 */
-+		memset(nandx->tail_buf, 0xff,
-+		       chip->page_size + oob_upper_size());
-+		for (i = 0; i < rem; i++) {
-+			prepare_op(nandx->ops[nandx->ops_current],
-+				   nandx->ops[nandx->ops_current - 1].row + 1,
-+				   0, chip->page_size, nandx->tail_buf,
-+				   nandx->tail_buf + chip->page_size);
-+			nandx->ops_current++;
-+		}
-+	}
-+
-+	ret = chip_ops(nandx->chip, nandx->ops, nandx->ops_current);
-+
-+error:
-+	nandx->mode = NANDX_IDLE;
-+	nandx->ops_current = 0;
-+
-+	return ret;
-+}
-+
-+int nandx_ioctl(int cmd, void *arg)
-+{
-+	struct nandx_desc *nandx = g_nandx;
-+	struct nand_chip *chip = nandx->chip;
-+	int ret = 0;
-+
-+	switch (cmd) {
-+	case CORE_CTRL_NAND_INFO:
-+		*(struct nandx_info *)arg = nandx->info;
-+		break;
-+
-+	case CHIP_CTRL_OPS_MULTI:
-+		ret = chip->chip_ctrl(chip, cmd, arg);
-+		if (!ret)
-+			nandx->multi_en = *(bool *)arg;
-+		break;
-+
-+	case NFI_CTRL_ECC:
-+		ret = chip->chip_ctrl(chip, cmd, arg);
-+		if (!ret)
-+			nandx->ecc_en = *(bool *)arg;
-+		break;
-+
-+	default:
-+		ret = chip->chip_ctrl(chip, cmd, arg);
-+		break;
-+	}
-+
-+	return ret;
-+}
-+
-+bool nandx_is_bad_block(u64 offset)
-+{
-+	struct nandx_desc *nandx = g_nandx;
-+
-+	prepare_op(nandx->ops[0], offset_to_row(offset), 0,
-+		   nandx->chip->page_size, nandx->head_buf,
-+		   nandx->head_buf + nandx->chip->page_size);
-+
-+	return nandx->chip->is_bad_block(nandx->chip, nandx->ops, 1);
-+}
-+
-+int nandx_suspend(void)
-+{
-+	return g_nandx->chip->suspend(g_nandx->chip);
-+}
-+
-+int nandx_resume(void)
-+{
-+	return g_nandx->chip->resume(g_nandx->chip);
-+}
-+
-+int nandx_init(struct nfi_resource *res)
-+{
-+	struct nand_chip *chip;
-+	struct nandx_desc *nandx;
-+	int ret = 0;
-+
-+	if (!res)
-+		return -EINVAL;
-+
-+	chip = nand_chip_init(res);
-+	if (!chip) {
-+		pr_info("nand chip init fail.\n");
-+		return -EFAULT;
-+	}
-+
-+	nandx = (struct nandx_desc *)mem_alloc(1, sizeof(struct nandx_desc));
-+	if (!nandx)
-+		return -ENOMEM;
-+
-+	g_nandx = nandx;
-+
-+	nandx->chip = chip;
-+	nandx->min_write_pages = chip->min_program_pages;
-+	nandx->ops_multi_len = nandx->min_write_pages * chip->plane_num;
-+	nandx->ops_len = chip->block_pages * chip->plane_num;
-+	nandx->ops = mem_alloc(1, sizeof(struct nand_ops) * nandx->ops_len);
-+	if (!nandx->ops) {
-+		ret = -ENOMEM;
-+		goto ops_error;
-+	}
-+
-+#if NANDX_BULK_IO_USE_DRAM
-+	nandx->head_buf = NANDX_CORE_BUF_ADDR;
-+#else
-+	nandx->head_buf = mem_alloc(2, page_padded_size());
-+#endif
-+	if (!nandx->head_buf) {
-+		ret = -ENOMEM;
-+		goto buf_error;
-+	}
-+	nandx->tail_buf = nandx->head_buf + page_padded_size();
-+	memset(nandx->head_buf, 0xff, 2 * page_padded_size());
-+	nandx->multi_en = false;
-+	nandx->ecc_en = false;
-+	nandx->ops_current = 0;
-+	nandx->mode = NANDX_IDLE;
-+
-+	nandx->info.max_io_count = nandx->ops_len;
-+	nandx->info.min_write_pages = nandx->min_write_pages;
-+	nandx->info.plane_num = chip->plane_num;
-+	nandx->info.oob_size = chip->oob_size;
-+	nandx->info.page_parity_size = chip->sector_spare_size * page_sectors();
-+	nandx->info.page_size = chip->page_size;
-+	nandx->info.block_size = chip->block_size;
-+	nandx->info.total_size = chip->block_size * chip->block_num;
-+	nandx->info.fdm_ecc_size = chip->fdm_ecc_size;
-+	nandx->info.fdm_reg_size = chip->fdm_reg_size;
-+	nandx->info.ecc_strength = chip->ecc_strength;
-+	nandx->info.sector_size = chip->sector_size;
-+
-+	return 0;
-+
-+buf_error:
-+#if !NANDX_BULK_IO_USE_DRAM
-+	mem_free(nandx->head_buf);
-+#endif
-+ops_error:
-+	mem_free(nandx);
-+
-+	return ret;
-+}
-+
-+void nandx_exit(void)
-+{
-+	nand_chip_exit(g_nandx->chip);
-+#if !NANDX_BULK_IO_USE_DRAM
-+	mem_free(g_nandx->head_buf);
-+#endif
-+	mem_free(g_nandx->ops);
-+	mem_free(g_nandx);
-+}
-+
-+#ifdef NANDX_UNIT_TEST
-+static void dump_buf(u8 *buf, u32 len)
-+{
-+	u32 i;
-+
-+	pr_info("dump buf@0x%X start", (u32)buf);
-+	for (i = 0; i < len; i++) {
-+		if (!reminder(i, 16))
-+			pr_info("\n0x");
-+		pr_info("%x ", buf[i]);
-+	}
-+	pr_info("\ndump buf done.\n");
-+}
-+
-+int nandx_unit_test(u64 offset, size_t len)
-+{
-+	u8 *src_buf, *dst_buf;
-+	u32 i, j;
-+	int ret;
-+
-+	if (!len || len > g_nandx->chip->block_size)
-+		return -EINVAL;
-+
-+#if NANDX_BULK_IO_USE_DRAM
-+	src_buf = NANDX_UT_SRC_ADDR;
-+	dst_buf = NANDX_UT_DST_ADDR;
-+
-+#else
-+	src_buf = mem_alloc(1, g_nandx->chip->page_size);
-+	if (!src_buf)
-+		return -ENOMEM;
-+	dst_buf = mem_alloc(1, g_nandx->chip->page_size);
-+	if (!dst_buf) {
-+		mem_free(src_buf);
-+		return -ENOMEM;
-+	}
-+#endif
-+
-+	pr_info("%s: src_buf address 0x%x, dst_buf address 0x%x\n",
-+		 __func__, (int)((unsigned long)src_buf),
-+		 (int)((unsigned long)dst_buf));
-+
-+	memset(dst_buf, 0, g_nandx->chip->page_size);
-+	pr_info("read page 0 data...!\n");
-+	ret = nandx_read(dst_buf, NULL, 0, g_nandx->chip->page_size);
-+	if (ret < 0) {
-+		pr_info("read fail with ret %d\n", ret);
-+	} else {
-+		pr_info("read page success!\n");
-+	}
-+
-+	for (i = 0; i < g_nandx->chip->page_size; i++) {
-+		src_buf[i] = 0x5a;
-+	}
-+
-+	ret = nandx_erase(offset, g_nandx->chip->block_size);
-+	if (ret < 0) {
-+		pr_info("erase fail with ret %d\n", ret);
-+		goto error;
-+	}
-+
-+	for (j = 0; j < g_nandx->chip->block_pages; j++) {
-+		memset(dst_buf, 0, g_nandx->chip->page_size);
-+		pr_info("check data after erase...!\n");
-+		ret = nandx_read(dst_buf, NULL, offset, g_nandx->chip->page_size);
-+		if (ret < 0) {
-+			pr_info("read fail with ret %d\n", ret);
-+			goto error;
-+		}
-+
-+		for (i = 0; i < g_nandx->chip->page_size; i++) {
-+			if (dst_buf[i] != 0xff) {
-+				pr_info("read after erase, check fail @%d\n", i);
-+				pr_info("all data should be 0xff\n");
-+				ret = -ENANDERASE;
-+				dump_buf(dst_buf, 128);
-+				//goto error;
-+				break;
-+			}
-+		}
-+
-+		pr_info("write data...!\n");
-+		ret = nandx_write(src_buf, NULL, offset, g_nandx->chip->page_size);
-+		if (ret < 0) {
-+			pr_info("write fail with ret %d\n", ret);
-+			goto error;
-+		}
-+
-+		memset(dst_buf, 0, g_nandx->chip->page_size);
-+		pr_info("read data...!\n");
-+		ret = nandx_read(dst_buf, NULL, offset, g_nandx->chip->page_size);
-+		if (ret < 0) {
-+			pr_info("read fail with ret %d\n", ret);
-+			goto error;
-+		}
-+
-+		for (i = 0; i < g_nandx->chip->page_size; i++) {
-+			if (dst_buf[i] != src_buf[i]) {
-+				pr_info("read after write, check fail @%d\n", i);
-+				pr_info("dst_buf should be same as src_buf\n");
-+				ret = -EIO;
-+				dump_buf(src_buf + i, 128);
-+				dump_buf(dst_buf + i, 128);
-+				break;
-+			}
-+		}
-+
-+		pr_err("%s %d %s@%d\n", __func__, __LINE__, ret?"Failed":"OK", j);
-+		if (ret)
-+			break;
-+
-+		offset += g_nandx->chip->page_size;
-+	}
-+
-+	ret = nandx_erase(offset, g_nandx->chip->block_size);
-+	if (ret < 0) {
-+		pr_info("erase fail with ret %d\n", ret);
-+		goto error;
-+	}
-+
-+	memset(dst_buf, 0, g_nandx->chip->page_size);
-+	ret = nandx_read(dst_buf, NULL, offset, g_nandx->chip->page_size);
-+	if (ret < 0) {
-+		pr_info("read fail with ret %d\n", ret);
-+		goto error;
-+	}
-+
-+	for (i = 0; i < g_nandx->chip->page_size; i++) {
-+		if (dst_buf[i] != 0xff) {
-+			pr_info("read after erase, check fail\n");
-+			pr_info("all data should be 0xff\n");
-+			ret = -ENANDERASE;
-+			dump_buf(dst_buf, 128);
-+			goto error;
-+		}
-+	}
-+
-+	return 0;
-+
-+error:
-+#if !NANDX_BULK_IO_USE_DRAM
-+	mem_free(src_buf);
-+	mem_free(dst_buf);
-+#endif
-+	return ret;
-+}
-+#endif
-diff --git a/drivers/mtd/nandx/core/core_io.h b/drivers/mtd/nandx/core/core_io.h
-new file mode 100644
-index 0000000000..edcb60908a
---- /dev/null
-+++ b/drivers/mtd/nandx/core/core_io.h
-@@ -0,0 +1,39 @@
-+/*
-+ * Copyright (C) 2017 MediaTek Inc.
-+ * Licensed under either
-+ *     BSD Licence, (see NOTICE for more details)
-+ *     GNU General Public License, version 2.0, (see NOTICE for more details)
-+ */
-+
-+#ifndef __CORE_IO_H__
-+#define __CORE_IO_H__
-+
-+typedef int (*func_chip_ops)(struct nand_chip *, struct nand_ops *,
-+			     int);
-+
-+enum nandx_op_mode {
-+	NANDX_IDLE,
-+	NANDX_WRITE,
-+	NANDX_READ,
-+	NANDX_ERASE
-+};
-+
-+struct nandx_desc {
-+	struct nand_chip *chip;
-+	struct nandx_info info;
-+	enum nandx_op_mode mode;
-+
-+	bool multi_en;
-+	bool ecc_en;
-+
-+	struct nand_ops *ops;
-+	int ops_len;
-+	int ops_multi_len;
-+	int ops_current;
-+	int min_write_pages;
-+
-+	u8 *head_buf;
-+	u8 *tail_buf;
-+};
-+
-+#endif /* __CORE_IO_H__ */
-diff --git a/drivers/mtd/nandx/core/nand/device_spi.c b/drivers/mtd/nandx/core/nand/device_spi.c
-new file mode 100644
-index 0000000000..db338c28c2
---- /dev/null
-+++ b/drivers/mtd/nandx/core/nand/device_spi.c
-@@ -0,0 +1,200 @@
-+/*
-+ * Copyright (C) 2017 MediaTek Inc.
-+ * Licensed under either
-+ *     BSD Licence, (see NOTICE for more details)
-+ *     GNU General Public License, version 2.0, (see NOTICE for more details)
-+ */
-+
-+#include "nandx_util.h"
-+#include "../nand_device.h"
-+#include "device_spi.h"
-+
-+/* spi nand basic commands */
-+static struct nand_cmds spi_cmds = {
-+	.reset = 0xff,
-+	.read_id = 0x9f,
-+	.read_status = 0x0f,
-+	.read_param_page = 0x03,
-+	.set_feature = 0x1f,
-+	.get_feature = 0x0f,
-+	.read_1st = 0x13,
-+	.read_2nd = -1,
-+	.random_out_1st = 0x03,
-+	.random_out_2nd = -1,
-+	.program_1st = 0x02,
-+	.program_2nd = 0x10,
-+	.erase_1st = 0xd8,
-+	.erase_2nd = -1,
-+	.read_cache = 0x30,
-+	.read_cache_last = 0x3f,
-+	.program_cache = 0x02
-+};
-+
-+/* spi nand extend commands */
-+static struct spi_extend_cmds spi_extend_cmds = {
-+	.die_select = 0xc2,
-+	.write_enable = 0x06
-+};
-+
-+/* means the start bit of addressing type */
-+static struct nand_addressing spi_addressing = {
-+	.row_bit_start = 0,
-+	.block_bit_start = 0,
-+	.plane_bit_start = 12,
-+	.lun_bit_start = 0,
-+};
-+
-+/* spi nand endurance */
-+static struct nand_endurance spi_endurance = {
-+	.pe_cycle = 100000,
-+	.ecc_req = 1,
-+	.max_bitflips = 1
-+};
-+
-+/* array_busy, write_protect, erase_fail, program_fail */
-+static struct nand_status spi_status[] = {
-+	{.array_busy = BIT(0),
-+	.write_protect = BIT(1),
-+	.erase_fail = BIT(2),
-+	.program_fail = BIT(3)}
-+};
-+
-+/* measure time by the us */
-+static struct nand_array_timing spi_array_timing = {
-+	.tRST = 500,
-+	.tWHR = 1,
-+	.tR = 25,
-+	.tRCBSY = 25,
-+	.tFEAT = 1,
-+	.tPROG = 600,
-+	.tPCBSY = 600,
-+	.tBERS = 10000,
-+	.tDBSY = 1
-+};
-+
-+/* spi nand device table */
-+static struct device_spi spi_nand[] = {
-+	{
-+		NAND_DEVICE("W25N01GV",
-+			    NAND_PACK_ID(0xef, 0xaa, 0x21, 0, 0, 0, 0, 0),
-+			    3, 0, 3, 3,
-+			    1, 1, 1, 1024, KB(128), KB(2), 64, 1,
-+			    &spi_cmds, &spi_addressing, &spi_status[0],
-+			    &spi_endurance, &spi_array_timing),
-+		{
-+			NAND_SPI_PROTECT(0xa0, 1, 2, 6),
-+			NAND_SPI_CONFIG(0xb0, 4, 6, 0),
-+			NAND_SPI_STATUS(0xc0, 4, 5),
-+			NAND_SPI_CHARACTER(0xff, 0xff, 0xff, 0xff)
-+		},
-+		&spi_extend_cmds, 0xff, 0xff
-+	},
-+	{
-+		NAND_DEVICE("MX35LF1G",
-+			    NAND_PACK_ID(0xc2, 0x12, 0x21, 0, 0, 0, 0, 0),
-+			    2, 0, 3, 3,
-+			    1, 1, 1, 1024, KB(128), KB(2), 64, 1,
-+			    &spi_cmds, &spi_addressing, &spi_status[0],
-+			    &spi_endurance, &spi_array_timing),
-+		{
-+			NAND_SPI_PROTECT(0xa0, 1, 2, 6),
-+			NAND_SPI_CONFIG(0xb0, 4, 6, 1),
-+			NAND_SPI_STATUS(0xc0, 4, 5),
-+			NAND_SPI_CHARACTER(0xff, 0xff, 0xff, 0xff)
-+		},
-+		&spi_extend_cmds, 0xff, 0xff
-+	},
-+	{
-+		NAND_DEVICE("MT29F4G01ABAFDWB",
-+			    NAND_PACK_ID(0x2c, 0x34, 0, 0, 0, 0, 0, 0),
-+			    2, 0, 3, 3,
-+			    1, 1, 1, 2048, KB(256), KB(4), 256, 1,
-+			    &spi_cmds, &spi_addressing, &spi_status[0],
-+			    &spi_endurance, &spi_array_timing),
-+		{
-+			NAND_SPI_PROTECT(0xa0, 1, 2, 6),
-+			NAND_SPI_CONFIG(0xb0, 4, 6, 1),
-+			NAND_SPI_STATUS(0xc0, 4, 5),
-+			NAND_SPI_CHARACTER(0xff, 0xff, 0xff, 0xff)
-+		},
-+		&spi_extend_cmds, 0xff, 0xff
-+	},
-+	{
-+		NAND_DEVICE("GD5F4GQ4UB",
-+			    NAND_PACK_ID(0xc8, 0xd4, 0, 0, 0, 0, 0, 0),
-+			    2, 0, 3, 3,
-+			    1, 1, 1, 2048, KB(256), KB(4), 256, 1,
-+			    &spi_cmds, &spi_addressing, &spi_status[0],
-+			    &spi_endurance, &spi_array_timing),
-+		{
-+			NAND_SPI_PROTECT(0xa0, 1, 2, 6),
-+			NAND_SPI_CONFIG(0xb0, 4, 6, 1),
-+			NAND_SPI_STATUS(0xc0, 4, 5),
-+			NAND_SPI_CHARACTER(0xff, 0xff, 0xff, 0xff)
-+		},
-+		&spi_extend_cmds, 0xff, 0xff
-+	},
-+	{
-+		NAND_DEVICE("TC58CVG2S0HRAIJ",
-+			    NAND_PACK_ID(0x98, 0xED, 0x51, 0, 0, 0, 0, 0),
-+			    3, 0, 3, 3,
-+			    1, 1, 1, 2048, KB(256), KB(4), 256, 1,
-+			    &spi_cmds, &spi_addressing, &spi_status[0],
-+			    &spi_endurance, &spi_array_timing),
-+		{
-+			NAND_SPI_PROTECT(0xa0, 1, 2, 6),
-+			NAND_SPI_CONFIG(0xb0, 4, 6, 1),
-+			NAND_SPI_STATUS(0xc0, 4, 5),
-+			NAND_SPI_CHARACTER(0xff, 0xff, 0xff, 0xff)
-+		},
-+		&spi_extend_cmds, 0xff, 0xff
-+	},
-+	{
-+		NAND_DEVICE("NO-DEVICE",
-+			    NAND_PACK_ID(0, 0, 0, 0, 0, 0, 0, 0), 0, 0, 0, 0,
-+			    0, 0, 0, 0, 0, 0, 0, 1,
-+			    &spi_cmds, &spi_addressing, &spi_status[0],
-+			    &spi_endurance, &spi_array_timing),
-+		{
-+			NAND_SPI_PROTECT(0xa0, 1, 2, 6),
-+			NAND_SPI_CONFIG(0xb0, 4, 6, 0),
-+			NAND_SPI_STATUS(0xc0, 4, 5),
-+			NAND_SPI_CHARACTER(0xff, 0xff, 0xff, 0xff)
-+		},
-+		&spi_extend_cmds, 0xff, 0xff
-+	}
-+};
-+
-+u8 spi_replace_rx_cmds(u8 mode)
-+{
-+	u8 rx_replace_cmds[] = {0x03, 0x3b, 0x6b, 0xbb, 0xeb};
-+
-+	return rx_replace_cmds[mode];
-+}
-+
-+u8 spi_replace_tx_cmds(u8 mode)
-+{
-+	u8 tx_replace_cmds[] = {0x02, 0x32};
-+
-+	return tx_replace_cmds[mode];
-+}
-+
-+u8 spi_replace_rx_col_cycle(u8 mode)
-+{
-+	u8 rx_replace_col_cycle[] = {3, 3, 3, 3, 4};
-+
-+	return rx_replace_col_cycle[mode];
-+}
-+
-+u8 spi_replace_tx_col_cycle(u8 mode)
-+{
-+	u8 tx_replace_col_cycle[] = {2, 2};
-+
-+	return tx_replace_col_cycle[mode];
-+}
-+
-+struct nand_device *nand_get_device(int index)
-+{
-+	return &spi_nand[index].dev;
-+}
-+
-diff --git a/drivers/mtd/nandx/core/nand/device_spi.h b/drivers/mtd/nandx/core/nand/device_spi.h
-new file mode 100644
-index 0000000000..1676b61fc8
---- /dev/null
-+++ b/drivers/mtd/nandx/core/nand/device_spi.h
-@@ -0,0 +1,132 @@
-+/*
-+ * Copyright (C) 2017 MediaTek Inc.
-+ * Licensed under either
-+ *     BSD Licence, (see NOTICE for more details)
-+ *     GNU General Public License, version 2.0, (see NOTICE for more details)
-+ */
-+
-+#ifndef __DEVICE_SPI_H__
-+#define __DEVICE_SPI_H__
-+
-+/*
-+ * extend commands
-+ * @die_select: select nand device die command
-+ * @write_enable: enable write command before write data to spi nand
-+ *    spi nand device will auto to be disable after write done
-+ */
-+struct spi_extend_cmds {
-+	short die_select;
-+	short write_enable;
-+};
-+
-+/*
-+ * protection feature register
-+ * @addr: register address
-+ * @wp_en_bit: write protection enable bit
-+ * @bp_start_bit: block protection mask start bit
-+ * @bp_end_bit: block protection mask end bit
-+ */
-+struct feature_protect {
-+	u8 addr;
-+	u8 wp_en_bit;
-+	u8 bp_start_bit;
-+	u8 bp_end_bit;
-+};
-+
-+/*
-+ * configuration feature register
-+ * @addr: register address
-+ * @ecc_en_bit: in-die ecc enable bit
-+ * @otp_en_bit: enter otp access mode bit
-+ * @need_qe: quad io enable bit
-+ */
-+struct feature_config {
-+	u8 addr;
-+	u8 ecc_en_bit;
-+	u8 otp_en_bit;
-+	u8 need_qe;
-+};
-+
-+/*
-+ * status feature register
-+ * @addr: register address
-+ * @ecc_start_bit: ecc status mask start bit for error bits number
-+ * @ecc_end_bit: ecc status mask end bit for error bits number
-+ * note that:
-+ *   operations status (ex. array busy status) could see on struct nand_status
-+ */
-+struct feature_status {
-+	u8 addr;
-+	u8 ecc_start_bit;
-+	u8 ecc_end_bit;
-+};
-+
-+/*
-+ * character feature register
-+ * @addr: register address
-+ * @die_sel_bit: die select bit
-+ * @drive_start_bit: drive strength mask start bit
-+ * @drive_end_bit: drive strength mask end bit
-+ */
-+struct feature_character {
-+	u8 addr;
-+	u8 die_sel_bit;
-+	u8 drive_start_bit;
-+	u8 drive_end_bit;
-+};
-+
-+/*
-+ * spi features
-+ * @protect: protection feature register
-+ * @config: configuration feature register
-+ * @status: status feature register
-+ * @character: character feature register
-+ */
-+struct spi_features {
-+	struct feature_protect protect;
-+	struct feature_config config;
-+	struct feature_status status;
-+	struct feature_character character;
-+};
-+
-+/*
-+ * device_spi
-+ *    configurations of spi nand device table
-+ * @dev: base information of nand device
-+ * @feature: feature information for spi nand
-+ * @extend_cmds: extended the nand base commands
-+ * @tx_mode_mask: tx mode mask for chip read
-+ * @rx_mode_mask: rx mode mask for chip write
-+ */
-+struct device_spi {
-+	struct nand_device dev;
-+	struct spi_features feature;
-+	struct spi_extend_cmds *extend_cmds;
-+
-+	u8 tx_mode_mask;
-+	u8 rx_mode_mask;
-+};
-+
-+#define NAND_SPI_PROTECT(addr, wp_en_bit, bp_start_bit, bp_end_bit) \
-+	{addr, wp_en_bit, bp_start_bit, bp_end_bit}
-+
-+#define NAND_SPI_CONFIG(addr, ecc_en_bit, otp_en_bit, need_qe) \
-+	{addr, ecc_en_bit, otp_en_bit, need_qe}
-+
-+#define NAND_SPI_STATUS(addr, ecc_start_bit, ecc_end_bit) \
-+	{addr, ecc_start_bit, ecc_end_bit}
-+
-+#define NAND_SPI_CHARACTER(addr, die_sel_bit, drive_start_bit, drive_end_bit) \
-+	{addr, die_sel_bit, drive_start_bit, drive_end_bit}
-+
-+static inline struct device_spi *device_to_spi(struct nand_device *dev)
-+{
-+	return container_of(dev, struct device_spi, dev);
-+}
-+
-+u8 spi_replace_rx_cmds(u8 mode);
-+u8 spi_replace_tx_cmds(u8 mode);
-+u8 spi_replace_rx_col_cycle(u8 mode);
-+u8 spi_replace_tx_col_cycle(u8 mode);
-+
-+#endif /* __DEVICE_SPI_H__ */
-diff --git a/drivers/mtd/nandx/core/nand/nand_spi.c b/drivers/mtd/nandx/core/nand/nand_spi.c
-new file mode 100644
-index 0000000000..2ae03e1cf4
---- /dev/null
-+++ b/drivers/mtd/nandx/core/nand/nand_spi.c
-@@ -0,0 +1,526 @@
-+/*
-+ * Copyright (C) 2017 MediaTek Inc.
-+ * Licensed under either
-+ *     BSD Licence, (see NOTICE for more details)
-+ *     GNU General Public License, version 2.0, (see NOTICE for more details)
-+ */
-+
-+#include "nandx_util.h"
-+#include "nandx_core.h"
-+#include "../nand_chip.h"
-+#include "../nand_device.h"
-+#include "../nfi.h"
-+#include "../nand_base.h"
-+#include "device_spi.h"
-+#include "nand_spi.h"
-+
-+#define READY_TIMEOUT   500000 /* us */
-+
-+static int nand_spi_read_status(struct nand_base *nand)
-+{
-+	struct device_spi *dev = device_to_spi(nand->dev);
-+	u8 status;
-+
-+	nand->get_feature(nand, dev->feature.status.addr, &status, 1);
-+
-+	return status;
-+}
-+
-+static int nand_spi_wait_ready(struct nand_base *nand, u32 timeout)
-+{
-+	u64 now, end;
-+	int status;
-+
-+	end = get_current_time_us() + timeout;
-+
-+	do {
-+		status = nand_spi_read_status(nand);
-+		status &= nand->dev->status->array_busy;
-+		now = get_current_time_us();
-+
-+		if (now > end)
-+			break;
-+	} while (status);
-+
-+	return status ? -EBUSY : 0;
-+}
-+
-+static int nand_spi_set_op_mode(struct nand_base *nand, u8 mode)
-+{
-+	struct nand_spi *spi_nand = base_to_spi(nand);
-+	struct nfi *nfi = nand->nfi;
-+	int ret = 0;
-+
-+	if (spi_nand->op_mode != mode) {
-+		ret = nfi->nfi_ctrl(nfi, SNFI_CTRL_OP_MODE, (void *)&mode);
-+		spi_nand->op_mode = mode;
-+	}
-+
-+	return ret;
-+}
-+
-+static int nand_spi_set_config(struct nand_base *nand, u8 addr, u8 mask,
-+			       bool en)
-+{
-+	u8 configs = 0;
-+
-+	nand->get_feature(nand, addr, &configs, 1);
-+
-+	if (en)
-+		configs |= mask;
-+	else
-+		configs &= ~mask;
-+
-+	nand->set_feature(nand, addr, &configs, 1);
-+
-+	configs = 0;
-+	nand->get_feature(nand, addr, &configs, 1);
-+
-+	return (configs & mask) == en ? 0 : -EFAULT;
-+}
-+
-+static int nand_spi_die_select(struct nand_base *nand, int *row)
-+{
-+	struct device_spi *dev = device_to_spi(nand->dev);
-+	struct nfi *nfi = nand->nfi;
-+	int lun_blocks, block_pages, lun, blocks;
-+	int page = *row, ret = 0;
-+	u8 param = 0, die_sel;
-+
-+	if (nand->dev->lun_num < 2)
-+		return 0;
-+
-+	block_pages = nand_block_pages(nand->dev);
-+	lun_blocks = nand_lun_blocks(nand->dev);
-+	blocks = div_down(page, block_pages);
-+	lun = div_down(blocks, lun_blocks);
-+
-+	if (dev->extend_cmds->die_select == -1) {
-+		die_sel = (u8)(lun << dev->feature.character.die_sel_bit);
-+		nand->get_feature(nand, dev->feature.character.addr, &param, 1);
-+		param |= die_sel;
-+		nand->set_feature(nand, dev->feature.character.addr, &param, 1);
-+		param = 0;
-+		nand->get_feature(nand, dev->feature.character.addr, &param, 1);
-+		ret = (param & die_sel) ? 0 : -EFAULT;
-+	} else {
-+		nfi->reset(nfi);
-+		nfi->send_cmd(nfi, dev->extend_cmds->die_select);
-+		nfi->send_addr(nfi, lun, 0, 1, 0);
-+		nfi->trigger(nfi);
-+	}
-+
-+	*row =  page - (lun_blocks * block_pages) * lun;
-+
-+	return ret;
-+}
-+
-+static int nand_spi_select_device(struct nand_base *nand, int cs)
-+{
-+	struct nand_spi *spi = base_to_spi(nand);
-+	struct nand_base *parent = spi->parent;
-+
-+	nand_spi_set_op_mode(nand, SNFI_MAC_MODE);
-+
-+	return parent->select_device(nand, cs);
-+}
-+
-+static int nand_spi_reset(struct nand_base *nand)
-+{
-+	struct nand_spi *spi = base_to_spi(nand);
-+	struct nand_base *parent = spi->parent;
-+
-+	nand_spi_set_op_mode(nand, SNFI_MAC_MODE);
-+
-+	parent->reset(nand);
-+
-+	return nand_spi_wait_ready(nand, READY_TIMEOUT);
-+}
-+
-+static int nand_spi_read_id(struct nand_base *nand, u8 *id, int count)
-+{
-+	struct nand_spi *spi = base_to_spi(nand);
-+	struct nand_base *parent = spi->parent;
-+
-+	nand_spi_set_op_mode(nand, SNFI_MAC_MODE);
-+
-+	return parent->read_id(nand, id, count);
-+}
-+
-+static int nand_spi_read_param_page(struct nand_base *nand, u8 *data,
-+				    int count)
-+{
-+	struct device_spi *dev = device_to_spi(nand->dev);
-+	struct nand_spi *spi = base_to_spi(nand);
-+	struct nfi *nfi = nand->nfi;
-+	int sectors, value;
-+	u8 param = 0;
-+
-+	sectors = div_round_up(count, nfi->sector_size);
-+
-+	nand->get_feature(nand, dev->feature.config.addr, &param, 1);
-+	param |= BIT(dev->feature.config.otp_en_bit);
-+	nand->set_feature(nand, dev->feature.config.addr, &param, 1);
-+
-+	param = 0;
-+	nand->get_feature(nand, dev->feature.config.addr, &param, 1);
-+	if (param & BIT(dev->feature.config.otp_en_bit)) {
-+		value = 0;
-+		nfi->nfi_ctrl(nfi, NFI_CTRL_ECC, &value);
-+		nand->dev->col_cycle  = spi_replace_rx_col_cycle(spi->rx_mode);
-+		nand->read_page(nand, 0x01);
-+		nand->read_data(nand, 0x01, 0, sectors, data, NULL);
-+	}
-+
-+	param &= ~BIT(dev->feature.config.otp_en_bit);
-+	nand->set_feature(nand, dev->feature.config.addr, &param, 1);
-+
-+	return 0;
-+}
-+
-+static int nand_spi_set_feature(struct nand_base *nand, u8 addr,
-+				u8 *param,
-+				int count)
-+{
-+	struct nand_spi *spi = base_to_spi(nand);
-+	struct nand_base *parent = spi->parent;
-+
-+	nand->write_enable(nand);
-+
-+	nand_spi_set_op_mode(nand, SNFI_MAC_MODE);
-+
-+	return parent->set_feature(nand, addr, param, count);
-+}
-+
-+static int nand_spi_get_feature(struct nand_base *nand, u8 addr,
-+				u8 *param,
-+				int count)
-+{
-+	struct nand_spi *spi = base_to_spi(nand);
-+	struct nand_base *parent = spi->parent;
-+
-+	nand_spi_set_op_mode(nand, SNFI_MAC_MODE);
-+
-+	return parent->get_feature(nand, addr, param, count);
-+}
-+
-+static int nand_spi_addressing(struct nand_base *nand, int *row,
-+			       int *col)
-+{
-+	struct nand_device *dev = nand->dev;
-+	int plane, block, block_pages;
-+	int ret;
-+
-+	ret = nand_spi_die_select(nand, row);
-+	if (ret)
-+		return ret;
-+
-+	block_pages = nand_block_pages(dev);
-+	block = div_down(*row, block_pages);
-+
-+	plane = block % dev->plane_num;
-+	*col |= (plane << dev->addressing->plane_bit_start);
-+
-+	return 0;
-+}
-+
-+static int nand_spi_read_page(struct nand_base *nand, int row)
-+{
-+	struct nand_spi *spi = base_to_spi(nand);
-+	struct nand_base *parent = spi->parent;
-+
-+	if (spi->op_mode == SNFI_AUTO_MODE)
-+		nand_spi_set_op_mode(nand, SNFI_AUTO_MODE);
-+	else
-+		nand_spi_set_op_mode(nand, SNFI_MAC_MODE);
-+
-+	parent->read_page(nand, row);
-+
-+	return nand_spi_wait_ready(nand, READY_TIMEOUT);
-+}
-+
-+static int nand_spi_read_data(struct nand_base *nand, int row, int col,
-+			      int sectors, u8 *data, u8 *oob)
-+{
-+	struct device_spi *dev = device_to_spi(nand->dev);
-+	struct nand_spi *spi = base_to_spi(nand);
-+	struct nand_base *parent = spi->parent;
-+	int ret;
-+
-+	if ((spi->rx_mode == SNFI_RX_114 || spi->rx_mode == SNFI_RX_144) &&
-+	    dev->feature.config.need_qe)
-+		nand_spi_set_config(nand, dev->feature.config.addr,
-+				    BIT(0), true);
-+
-+	nand->dev->col_cycle  = spi_replace_rx_col_cycle(spi->rx_mode);
-+
-+	nand_spi_set_op_mode(nand, SNFI_CUSTOM_MODE);
-+
-+	ret = parent->read_data(nand, row, col, sectors, data, oob);
-+	if (ret)
-+		return -ENANDREAD;
-+
-+	if (spi->ondie_ecc) {
-+		ret = nand_spi_read_status(nand);
-+		ret &= GENMASK(dev->feature.status.ecc_end_bit,
-+			       dev->feature.status.ecc_start_bit);
-+		ret >>= dev->feature.status.ecc_start_bit;
-+		if (ret > nand->dev->endurance->ecc_req)
-+			return -ENANDREAD;
-+		else if (ret > nand->dev->endurance->max_bitflips)
-+			return -ENANDFLIPS;
-+	}
-+
-+	return 0;
-+}
-+
-+static int nand_spi_write_enable(struct nand_base *nand)
-+{
-+	struct device_spi *dev = device_to_spi(nand->dev);
-+	struct nfi *nfi = nand->nfi;
-+	int status;
-+
-+	nand_spi_set_op_mode(nand, SNFI_MAC_MODE);
-+
-+	nfi->reset(nfi);
-+	nfi->send_cmd(nfi, dev->extend_cmds->write_enable);
-+
-+	nfi->trigger(nfi);
-+
-+	status = nand_spi_read_status(nand);
-+	status &= nand->dev->status->write_protect;
-+
-+	return !status;
-+}
-+
-+static int nand_spi_program_data(struct nand_base *nand, int row,
-+				 int col,
-+				 u8 *data, u8 *oob)
-+{
-+	struct device_spi *dev = device_to_spi(nand->dev);
-+	struct nand_spi *spi = base_to_spi(nand);
-+
-+	if (spi->tx_mode == SNFI_TX_114 && dev->feature.config.need_qe)
-+		nand_spi_set_config(nand, dev->feature.config.addr,
-+				    BIT(0), true);
-+
-+	nand_spi_set_op_mode(nand, SNFI_CUSTOM_MODE);
-+
-+	nand->dev->col_cycle  = spi_replace_tx_col_cycle(spi->tx_mode);
-+
-+	return spi->parent->program_data(nand, row, col, data, oob);
-+}
-+
-+static int nand_spi_program_page(struct nand_base *nand, int row)
-+{
-+	struct nand_spi *spi = base_to_spi(nand);
-+	struct nand_device *dev = nand->dev;
-+	struct nfi *nfi = nand->nfi;
-+
-+	if (spi->op_mode == SNFI_AUTO_MODE)
-+		nand_spi_set_op_mode(nand, SNFI_AUTO_MODE);
-+	else
-+		nand_spi_set_op_mode(nand, SNFI_MAC_MODE);
-+
-+	nfi->reset(nfi);
-+	nfi->send_cmd(nfi, dev->cmds->program_2nd);
-+	nfi->send_addr(nfi, 0, row, dev->col_cycle, dev->row_cycle);
-+	nfi->trigger(nfi);
-+
-+	return nand_spi_wait_ready(nand, READY_TIMEOUT);
-+}
-+
-+static int nand_spi_erase_block(struct nand_base *nand, int row)
-+{
-+	struct nand_spi *spi = base_to_spi(nand);
-+	struct nand_base *parent = spi->parent;
-+
-+	nand_spi_set_op_mode(nand, SNFI_MAC_MODE);
-+
-+	parent->erase_block(nand, row);
-+
-+	return nand_spi_wait_ready(nand, READY_TIMEOUT);
-+}
-+
-+static int nand_chip_spi_ctrl(struct nand_chip *chip, int cmd,
-+			      void *args)
-+{
-+	struct nand_base *nand = chip->nand;
-+	struct device_spi *dev = device_to_spi(nand->dev);
-+	struct nand_spi *spi = base_to_spi(nand);
-+	struct nfi *nfi = nand->nfi;
-+	int ret = 0, value = *(int *)args;
-+
-+	switch (cmd) {
-+	case CHIP_CTRL_ONDIE_ECC:
-+		spi->ondie_ecc = (bool)value;
-+		ret = nand_spi_set_config(nand, dev->feature.config.addr,
-+					  BIT(dev->feature.config.ecc_en_bit),
-+					  spi->ondie_ecc);
-+		break;
-+
-+	case SNFI_CTRL_TX_MODE:
-+		if (value < 0 || value > SNFI_TX_114)
-+			return -EOPNOTSUPP;
-+
-+		if (dev->tx_mode_mask & BIT(value)) {
-+			spi->tx_mode = value;
-+			nand->dev->cmds->random_out_1st = spi_replace_tx_cmds(
-+								  spi->tx_mode);
-+			ret = nfi->nfi_ctrl(nfi, cmd, args);
-+		}
-+
-+		break;
-+
-+	case SNFI_CTRL_RX_MODE:
-+		if (value < 0 || value > SNFI_RX_144)
-+			return -EOPNOTSUPP;
-+
-+		if (dev->rx_mode_mask & BIT(value)) {
-+			spi->rx_mode = value;
-+			nand->dev->cmds->program_1st = spi_replace_rx_cmds(
-+							       spi->rx_mode);
-+			ret = nfi->nfi_ctrl(nfi, cmd, args);
-+		}
-+
-+		break;
-+
-+	case CHIP_CTRL_OPS_CACHE:
-+	case CHIP_CTRL_OPS_MULTI:
-+	case CHIP_CTRL_PSLC_MODE:
-+	case CHIP_CTRL_DDR_MODE:
-+	case CHIP_CTRL_DRIVE_STRENGTH:
-+	case CHIP_CTRL_TIMING_MODE:
-+		ret = -EOPNOTSUPP;
-+		break;
-+
-+	default:
-+		ret = nfi->nfi_ctrl(nfi, cmd, args);
-+		break;
-+	}
-+
-+	return ret;
-+}
-+
-+int nand_chip_spi_resume(struct nand_chip *chip)
-+{
-+	struct nand_base *nand = chip->nand;
-+	struct nand_spi *spi = base_to_spi(nand);
-+	struct device_spi *dev = device_to_spi(nand->dev);
-+	struct nfi *nfi = nand->nfi;
-+	struct nfi_format format;
-+	u8 mask;
-+
-+	nand->reset(nand);
-+
-+	mask = GENMASK(dev->feature.protect.bp_end_bit,
-+		       dev->feature.protect.bp_start_bit);
-+	nand_spi_set_config(nand, dev->feature.config.addr, mask, false);
-+	mask =  BIT(dev->feature.config.ecc_en_bit);
-+	nand_spi_set_config(nand, dev->feature.config.addr, mask,
-+			    spi->ondie_ecc);
-+
-+	format.page_size = nand->dev->page_size;
-+	format.spare_size = nand->dev->spare_size;
-+	format.ecc_req = nand->dev->endurance->ecc_req;
-+
-+	return nfi->set_format(nfi, &format);
-+}
-+
-+static int nand_spi_set_format(struct nand_base *nand)
-+{
-+	struct nfi_format format = {
-+		nand->dev->page_size,
-+		nand->dev->spare_size,
-+		nand->dev->endurance->ecc_req
-+	};
-+
-+	return nand->nfi->set_format(nand->nfi, &format);
-+}
-+
-+struct nand_base *nand_device_init(struct nand_chip *chip)
-+{
-+	struct nand_base *nand;
-+	struct nand_spi *spi;
-+	struct device_spi *dev;
-+	int ret;
-+	u8 mask;
-+
-+	spi = mem_alloc(1, sizeof(struct nand_spi));
-+	if (!spi) {
-+		pr_info("alloc nand_spi fail\n");
-+		return NULL;
-+	}
-+
-+	spi->ondie_ecc = false;
-+	spi->op_mode = SNFI_CUSTOM_MODE;
-+	spi->rx_mode = SNFI_RX_114;
-+	spi->tx_mode = SNFI_TX_114;
-+
-+	spi->parent = chip->nand;
-+	nand = &spi->base;
-+	nand->dev = spi->parent->dev;
-+	nand->nfi = spi->parent->nfi;
-+
-+	nand->select_device = nand_spi_select_device;
-+	nand->reset = nand_spi_reset;
-+	nand->read_id = nand_spi_read_id;
-+	nand->read_param_page = nand_spi_read_param_page;
-+	nand->set_feature = nand_spi_set_feature;
-+	nand->get_feature = nand_spi_get_feature;
-+	nand->read_status = nand_spi_read_status;
-+	nand->addressing = nand_spi_addressing;
-+	nand->read_page = nand_spi_read_page;
-+	nand->read_data = nand_spi_read_data;
-+	nand->write_enable = nand_spi_write_enable;
-+	nand->program_data = nand_spi_program_data;
-+	nand->program_page = nand_spi_program_page;
-+	nand->erase_block = nand_spi_erase_block;
-+
-+	chip->chip_ctrl = nand_chip_spi_ctrl;
-+	chip->nand_type = NAND_SPI;
-+	chip->resume = nand_chip_spi_resume;
-+
-+	ret = nand_detect_device(nand);
-+	if (ret)
-+		goto err;
-+
-+	nand->select_device(nand, 0);
-+
-+	ret = nand_spi_set_format(nand);
-+	if (ret)
-+		goto err;
-+
-+	dev = (struct device_spi *)nand->dev;
-+
-+	nand->dev->cmds->random_out_1st =
-+		spi_replace_rx_cmds(spi->rx_mode);
-+	nand->dev->cmds->program_1st =
-+		spi_replace_tx_cmds(spi->tx_mode);
-+
-+	mask = GENMASK(dev->feature.protect.bp_end_bit,
-+		       dev->feature.protect.bp_start_bit);
-+	ret = nand_spi_set_config(nand, dev->feature.protect.addr, mask, false);
-+	if (ret)
-+		goto err;
-+
-+	mask =  BIT(dev->feature.config.ecc_en_bit);
-+	ret = nand_spi_set_config(nand, dev->feature.config.addr, mask,
-+				  spi->ondie_ecc);
-+	if (ret)
-+		goto err;
-+
-+	return nand;
-+
-+err:
-+	mem_free(spi);
-+	return NULL;
-+}
-+
-+void nand_exit(struct nand_base *nand)
-+{
-+	struct nand_spi *spi = base_to_spi(nand);
-+
-+	nand_base_exit(spi->parent);
-+	mem_free(spi);
-+}
-diff --git a/drivers/mtd/nandx/core/nand/nand_spi.h b/drivers/mtd/nandx/core/nand/nand_spi.h
-new file mode 100644
-index 0000000000..e55e4de6f7
---- /dev/null
-+++ b/drivers/mtd/nandx/core/nand/nand_spi.h
-@@ -0,0 +1,35 @@
-+/*
-+ * Copyright (C) 2017 MediaTek Inc.
-+ * Licensed under either
-+ *     BSD Licence, (see NOTICE for more details)
-+ *     GNU General Public License, version 2.0, (see NOTICE for more details)
-+ */
-+
-+#ifndef __NAND_SPI_H__
-+#define __NAND_SPI_H__
-+
-+/*
-+ * spi nand handler
-+ * @base: spi nand base functions
-+ * @parent: common parent nand base functions
-+ * @tx_mode: spi bus width of transfer to device
-+ * @rx_mode: spi bus width of transfer from device
-+ * @op_mode: spi nand controller (NFI) operation mode
-+ * @ondie_ecc: spi nand on-die ecc flag
-+ */
-+
-+struct nand_spi {
-+	struct nand_base base;
-+	struct nand_base *parent;
-+	u8 tx_mode;
-+	u8 rx_mode;
-+	u8 op_mode;
-+	bool ondie_ecc;
-+};
-+
-+static inline struct nand_spi *base_to_spi(struct nand_base *base)
-+{
-+	return container_of(base, struct nand_spi, base);
-+}
-+
-+#endif /* __NAND_SPI_H__ */
-diff --git a/drivers/mtd/nandx/core/nand_base.c b/drivers/mtd/nandx/core/nand_base.c
-new file mode 100644
-index 0000000000..65998e5460
---- /dev/null
-+++ b/drivers/mtd/nandx/core/nand_base.c
-@@ -0,0 +1,304 @@
-+/*
-+ * Copyright (C) 2017 MediaTek Inc.
-+ * Licensed under either
-+ *     BSD Licence, (see NOTICE for more details)
-+ *     GNU General Public License, version 2.0, (see NOTICE for more details)
-+ */
-+
-+#include "nandx_util.h"
-+#include "nandx_core.h"
-+#include "nand_chip.h"
-+#include "nand_device.h"
-+#include "nfi.h"
-+#include "nand_base.h"
-+
-+static int nand_base_select_device(struct nand_base *nand, int cs)
-+{
-+	struct nfi *nfi = nand->nfi;
-+
-+	nfi->reset(nfi);
-+
-+	return nfi->select_chip(nfi, cs);
-+}
-+
-+static int nand_base_reset(struct nand_base *nand)
-+{
-+	struct nfi *nfi = nand->nfi;
-+	struct nand_device *dev = nand->dev;
-+
-+	nfi->reset(nfi);
-+	nfi->send_cmd(nfi, dev->cmds->reset);
-+	nfi->trigger(nfi);
-+
-+	return nfi->wait_ready(nfi, NAND_WAIT_POLLING, dev->array_timing->tRST);
-+}
-+
-+static int nand_base_read_id(struct nand_base *nand, u8 *id, int count)
-+{
-+	struct nfi *nfi = nand->nfi;
-+	struct nand_device *dev = nand->dev;
-+
-+	nfi->reset(nfi);
-+	nfi->send_cmd(nfi, dev->cmds->read_id);
-+	nfi->wait_ready(nfi, NAND_WAIT_POLLING, dev->array_timing->tWHR);
-+	nfi->send_addr(nfi, 0, 0, 1, 0);
-+
-+	return nfi->read_bytes(nfi, id, count);
-+}
-+
-+static int nand_base_read_param_page(struct nand_base *nand, u8 *data,
-+				     int count)
-+{
-+	struct nfi *nfi = nand->nfi;
-+	struct nand_device *dev = nand->dev;
-+
-+	nfi->reset(nfi);
-+	nfi->send_cmd(nfi, dev->cmds->read_param_page);
-+	nfi->send_addr(nfi, 0, 0, 1, 0);
-+
-+	nfi->wait_ready(nfi, NAND_WAIT_POLLING, dev->array_timing->tR);
-+
-+	return nfi->read_bytes(nfi, data, count);
-+}
-+
-+static int nand_base_set_feature(struct nand_base *nand, u8 addr,
-+				 u8 *param,
-+				 int count)
-+{
-+	struct nfi *nfi = nand->nfi;
-+	struct nand_device *dev = nand->dev;
-+
-+	nfi->reset(nfi);
-+	nfi->send_cmd(nfi, dev->cmds->set_feature);
-+	nfi->send_addr(nfi, addr, 0, 1, 0);
-+
-+	nfi->write_bytes(nfi, param, count);
-+
-+	return nfi->wait_ready(nfi, NAND_WAIT_POLLING,
-+			       dev->array_timing->tFEAT);
-+}
-+
-+static int nand_base_get_feature(struct nand_base *nand, u8 addr,
-+				 u8 *param,
-+				 int count)
-+{
-+	struct nfi *nfi = nand->nfi;
-+	struct nand_device *dev = nand->dev;
-+
-+	nfi->reset(nfi);
-+	nfi->send_cmd(nfi, dev->cmds->get_feature);
-+	nfi->send_addr(nfi, addr, 0, 1, 0);
-+	nfi->wait_ready(nfi, NAND_WAIT_POLLING, dev->array_timing->tFEAT);
-+
-+	return nfi->read_bytes(nfi, param, count);
-+}
-+
-+static int nand_base_read_status(struct nand_base *nand)
-+{
-+	struct nfi *nfi = nand->nfi;
-+	struct nand_device *dev = nand->dev;
-+	u8 status = 0;
-+
-+	nfi->reset(nfi);
-+	nfi->send_cmd(nfi, dev->cmds->read_status);
-+	nfi->wait_ready(nfi, NAND_WAIT_POLLING, dev->array_timing->tWHR);
-+	nfi->read_bytes(nfi, &status, 1);
-+
-+	return status;
-+}
-+
-+static int nand_base_addressing(struct nand_base *nand, int *row,
-+				int *col)
-+{
-+	struct nand_device *dev = nand->dev;
-+	int lun, plane, block, page, cs = 0;
-+	int block_pages, target_blocks, wl = 0;
-+	int icol = *col;
-+
-+	if (dev->target_num > 1) {
-+		block_pages = nand_block_pages(dev);
-+		target_blocks = nand_target_blocks(dev);
-+		cs = div_down(*row, block_pages * target_blocks);
-+		*row -= cs * block_pages * target_blocks;
-+	}
-+
-+	nand->select_device(nand, cs);
-+
-+	block_pages = nand_block_pages(dev);
-+	block = div_down(*row, block_pages);
-+	page = *row - block * block_pages;
-+	plane = reminder(block, dev->plane_num);
-+	lun = div_down(block, nand_lun_blocks(dev));
-+
-+	wl |= (page << dev->addressing->row_bit_start);
-+	wl |= (block << dev->addressing->block_bit_start);
-+	wl |= (plane << dev->addressing->plane_bit_start);
-+	wl |= (lun << dev->addressing->lun_bit_start);
-+
-+	*row = wl;
-+	*col = icol;
-+
-+	return 0;
-+}
-+
-+static int nand_base_read_page(struct nand_base *nand, int row)
-+{
-+	struct nfi *nfi = nand->nfi;
-+	struct nand_device *dev = nand->dev;
-+
-+	nfi->reset(nfi);
-+	nfi->send_cmd(nfi, dev->cmds->read_1st);
-+	nfi->send_addr(nfi, 0, row, dev->col_cycle, dev->row_cycle);
-+	nfi->send_cmd(nfi, dev->cmds->read_2nd);
-+	nfi->trigger(nfi);
-+
-+	return nfi->wait_ready(nfi, NAND_WAIT_POLLING, dev->array_timing->tR);
-+}
-+
-+static int nand_base_read_data(struct nand_base *nand, int row, int col,
-+			       int sectors, u8 *data, u8 *oob)
-+{
-+	struct nfi *nfi = nand->nfi;
-+	struct nand_device *dev = nand->dev;
-+
-+	nfi->reset(nfi);
-+	nfi->send_cmd(nfi, dev->cmds->random_out_1st);
-+	nfi->send_addr(nfi, col, row, dev->col_cycle, dev->row_cycle);
-+	nfi->send_cmd(nfi, dev->cmds->random_out_2nd);
-+	nfi->wait_ready(nfi, NAND_WAIT_POLLING, dev->array_timing->tRCBSY);
-+
-+	return nfi->read_sectors(nfi, data, oob, sectors);
-+}
-+
-+static int nand_base_write_enable(struct nand_base *nand)
-+{
-+	struct nand_device *dev = nand->dev;
-+	int status;
-+
-+	status = nand_base_read_status(nand);
-+	if (status & dev->status->write_protect)
-+		return 0;
-+
-+	return -ENANDWP;
-+}
-+
-+static int nand_base_program_data(struct nand_base *nand, int row,
-+				  int col,
-+				  u8 *data, u8 *oob)
-+{
-+	struct nfi *nfi = nand->nfi;
-+	struct nand_device *dev = nand->dev;
-+
-+	nfi->reset(nfi);
-+	nfi->send_cmd(nfi, dev->cmds->program_1st);
-+	nfi->send_addr(nfi, 0, row, dev->col_cycle, dev->row_cycle);
-+
-+	return nfi->write_page(nfi, data, oob);
-+}
-+
-+static int nand_base_program_page(struct nand_base *nand, int row)
-+{
-+	struct nfi *nfi = nand->nfi;
-+	struct nand_device *dev = nand->dev;
-+
-+	nfi->reset(nfi);
-+	nfi->send_cmd(nfi, dev->cmds->program_2nd);
-+	nfi->trigger(nfi);
-+
-+	return nfi->wait_ready(nfi, NAND_WAIT_POLLING,
-+			       dev->array_timing->tPROG);
-+}
-+
-+static int nand_base_erase_block(struct nand_base *nand, int row)
-+{
-+	struct nfi *nfi = nand->nfi;
-+	struct nand_device *dev = nand->dev;
-+
-+	nfi->reset(nfi);
-+	nfi->send_cmd(nfi, dev->cmds->erase_1st);
-+	nfi->send_addr(nfi, 0, row, 0, dev->row_cycle);
-+	nfi->send_cmd(nfi, dev->cmds->erase_2nd);
-+	nfi->trigger(nfi);
-+
-+	return nfi->wait_ready(nfi, NAND_WAIT_POLLING,
-+			       dev->array_timing->tBERS);
-+}
-+
-+static int nand_base_read_cache(struct nand_base *nand, int row)
-+{
-+	struct nfi *nfi = nand->nfi;
-+	struct nand_device *dev = nand->dev;
-+
-+	nfi->reset(nfi);
-+	nfi->send_cmd(nfi, dev->cmds->read_1st);
-+	nfi->send_addr(nfi, 0, row, dev->col_cycle, dev->row_cycle);
-+	nfi->send_cmd(nfi, dev->cmds->read_cache);
-+	nfi->trigger(nfi);
-+
-+	return nfi->wait_ready(nfi, NAND_WAIT_POLLING,
-+			       dev->array_timing->tRCBSY);
-+}
-+
-+static int nand_base_read_last(struct nand_base *nand)
-+{
-+	struct nfi *nfi = nand->nfi;
-+	struct nand_device *dev = nand->dev;
-+
-+	nfi->reset(nfi);
-+	nfi->send_cmd(nfi, dev->cmds->read_cache_last);
-+	nfi->trigger(nfi);
-+
-+	return nfi->wait_ready(nfi, NAND_WAIT_POLLING,
-+			       dev->array_timing->tRCBSY);
-+}
-+
-+static int nand_base_program_cache(struct nand_base *nand)
-+{
-+	struct nfi *nfi = nand->nfi;
-+	struct nand_device *dev = nand->dev;
-+
-+	nfi->reset(nfi);
-+	nfi->send_cmd(nfi, dev->cmds->program_cache);
-+	nfi->trigger(nfi);
-+
-+	return nfi->wait_ready(nfi, NAND_WAIT_POLLING,
-+			       dev->array_timing->tPCBSY);
-+}
-+
-+struct nand_base *nand_base_init(struct nand_device *dev,
-+				 struct nfi *nfi)
-+{
-+	struct nand_base *nand;
-+
-+	nand = mem_alloc(1, sizeof(struct nand_base));
-+	if (!nand)
-+		return NULL;
-+
-+	nand->dev = dev;
-+	nand->nfi = nfi;
-+	nand->select_device = nand_base_select_device;
-+	nand->reset = nand_base_reset;
-+	nand->read_id = nand_base_read_id;
-+	nand->read_param_page = nand_base_read_param_page;
-+	nand->set_feature = nand_base_set_feature;
-+	nand->get_feature = nand_base_get_feature;
-+	nand->read_status = nand_base_read_status;
-+	nand->addressing = nand_base_addressing;
-+	nand->read_page = nand_base_read_page;
-+	nand->read_data = nand_base_read_data;
-+	nand->read_cache = nand_base_read_cache;
-+	nand->read_last = nand_base_read_last;
-+	nand->write_enable = nand_base_write_enable;
-+	nand->program_data = nand_base_program_data;
-+	nand->program_page = nand_base_program_page;
-+	nand->program_cache = nand_base_program_cache;
-+	nand->erase_block = nand_base_erase_block;
-+
-+	return nand;
-+}
-+
-+void nand_base_exit(struct nand_base *base)
-+{
-+	nfi_exit(base->nfi);
-+	mem_free(base);
-+}
-diff --git a/drivers/mtd/nandx/core/nand_base.h b/drivers/mtd/nandx/core/nand_base.h
-new file mode 100644
-index 0000000000..13217978e5
---- /dev/null
-+++ b/drivers/mtd/nandx/core/nand_base.h
-@@ -0,0 +1,71 @@
-+/*
-+ * Copyright (C) 2017 MediaTek Inc.
-+ * Licensed under either
-+ *     BSD Licence, (see NOTICE for more details)
-+ *     GNU General Public License, version 2.0, (see NOTICE for more details)
-+ */
-+
-+#ifndef __NAND_BASE_H__
-+#define __NAND_BASE_H__
-+
-+/*
-+ * nand base functions
-+ * @dev: nand device infomations
-+ * @nfi: nand host controller
-+ * @select_device: select one nand device of multi nand on chip
-+ * @reset: reset current nand device
-+ * @read_id: read current nand id
-+ * @read_param_page: read current nand parameters page
-+ * @set_feature: configurate the nand device feature
-+ * @get_feature: get the nand device feature
-+ * @read_status: read nand device status
-+ * @addressing: addressing the address to nand device physical address
-+ * @read_page: read page data to device cache register
-+ * @read_data: read data from device cache register by bus protocol
-+ * @read_cache: nand cache read operation for data output
-+ * @read_last: nand cache read operation for last page output
-+ * @write_enable: enable program/erase for nand, especially spi nand
-+ * @program_data: program data to nand device cache register
-+ * @program_page: program page data from nand device cache register to array
-+ * @program_cache: nand cache program operation for data input
-+ * @erase_block: erase nand block operation
-+ */
-+struct nand_base {
-+	struct nand_device *dev;
-+	struct nfi *nfi;
-+	int (*select_device)(struct nand_base *nand, int cs);
-+	int (*reset)(struct nand_base *nand);
-+	int (*read_id)(struct nand_base *nand, u8 *id, int count);
-+	int (*read_param_page)(struct nand_base *nand, u8 *data, int count);
-+	int (*set_feature)(struct nand_base *nand, u8 addr, u8 *param,
-+			   int count);
-+	int (*get_feature)(struct nand_base *nand, u8 addr, u8 *param,
-+			   int count);
-+	int (*read_status)(struct nand_base *nand);
-+	int (*addressing)(struct nand_base *nand, int *row, int *col);
-+
-+	int (*read_page)(struct nand_base *nand, int row);
-+	int (*read_data)(struct nand_base *nand, int row, int col, int sectors,
-+			 u8 *data, u8 *oob);
-+	int (*read_cache)(struct nand_base *nand, int row);
-+	int (*read_last)(struct nand_base *nand);
-+
-+	int (*write_enable)(struct nand_base *nand);
-+	int (*program_data)(struct nand_base *nand, int row, int col, u8 *data,
-+			    u8 *oob);
-+	int (*program_page)(struct nand_base *nand, int row);
-+	int (*program_cache)(struct nand_base *nand);
-+
-+	int (*erase_block)(struct nand_base *nand, int row);
-+};
-+
-+struct nand_base *nand_base_init(struct nand_device *device,
-+				 struct nfi *nfi);
-+void nand_base_exit(struct nand_base *base);
-+
-+struct nand_base *nand_device_init(struct nand_chip *nand);
-+void nand_exit(struct nand_base *nand);
-+
-+int nand_detect_device(struct nand_base *nand);
-+
-+#endif /* __NAND_BASE_H__ */
-diff --git a/drivers/mtd/nandx/core/nand_chip.c b/drivers/mtd/nandx/core/nand_chip.c
-new file mode 100644
-index 0000000000..02adc6f52e
---- /dev/null
-+++ b/drivers/mtd/nandx/core/nand_chip.c
-@@ -0,0 +1,272 @@
-+/*
-+ * Copyright (C) 2017 MediaTek Inc.
-+ * Licensed under either
-+ *     BSD Licence, (see NOTICE for more details)
-+ *     GNU General Public License, version 2.0, (see NOTICE for more details)
-+ */
-+
-+#include "nandx_util.h"
-+#include "nandx_core.h"
-+#include "nand_chip.h"
-+#include "nand_device.h"
-+#include "nfi.h"
-+#include "nand_base.h"
-+
-+static int nand_chip_read_page(struct nand_chip *chip,
-+			       struct nand_ops *ops,
-+			       int count)
-+{
-+	struct nand_base *nand = chip->nand;
-+	struct nand_device *dev = nand->dev;
-+	int i, ret = 0;
-+	int row, col, sectors;
-+	u8 *data, *oob;
-+
-+	for (i = 0; i < count; i++) {
-+		row = ops[i].row;
-+		col = ops[i].col;
-+
-+		nand->addressing(nand, &row, &col);
-+		ops[i].status = nand->read_page(nand, row);
-+		if (ops[i].status < 0) {
-+			ret = ops[i].status;
-+			continue;
-+		}
-+
-+		data = ops[i].data;
-+		oob = ops[i].oob;
-+		sectors = ops[i].len / chip->sector_size;
-+		ops[i].status = nand->read_data(nand, row, col,
-+						sectors, data, oob);
-+		if (ops[i].status > 0)
-+			ops[i].status = ops[i].status >=
-+					dev->endurance->max_bitflips ?
-+					-ENANDFLIPS : 0;
-+
-+		ret = min_t(int, ret, ops[i].status);
-+	}
-+
-+	return ret;
-+}
-+
-+static int nand_chip_write_page(struct nand_chip *chip,
-+				struct nand_ops *ops,
-+				int count)
-+{
-+	struct nand_base *nand = chip->nand;
-+	struct nand_device *dev = nand->dev;
-+	int i, ret = 0;
-+	int row, col;
-+	u8 *data, *oob;
-+
-+	for (i = 0; i < count; i++) {
-+		row = ops[i].row;
-+		col = ops[i].col;
-+
-+		nand->addressing(nand, &row, &col);
-+
-+		ops[i].status = nand->write_enable(nand);
-+		if (ops[i].status) {
-+			pr_debug("Write Protect at %x!\n", row);
-+			ops[i].status = -ENANDWP;
-+			return -ENANDWP;
-+		}
-+
-+		data = ops[i].data;
-+		oob = ops[i].oob;
-+		ops[i].status = nand->program_data(nand, row, col, data, oob);
-+		if (ops[i].status < 0) {
-+			ret = ops[i].status;
-+			continue;
-+		}
-+
-+		ops[i].status = nand->program_page(nand, row);
-+		if (ops[i].status < 0) {
-+			ret = ops[i].status;
-+			continue;
-+		}
-+
-+		ops[i].status = nand->read_status(nand);
-+		if (ops[i].status & dev->status->program_fail)
-+			ops[i].status = -ENANDWRITE;
-+
-+		ret = min_t(int, ret, ops[i].status);
-+	}
-+
-+	return ret;
-+}
-+
-+static int nand_chip_erase_block(struct nand_chip *chip,
-+				 struct nand_ops *ops,
-+				 int count)
-+{
-+	struct nand_base *nand = chip->nand;
-+	struct nand_device *dev = nand->dev;
-+	int i, ret = 0;
-+	int row, col;
-+
-+	for (i = 0; i < count; i++) {
-+		row = ops[i].row;
-+		col = ops[i].col;
-+
-+		nand->addressing(nand, &row, &col);
-+
-+		ops[i].status = nand->write_enable(nand);
-+		if (ops[i].status) {
-+			pr_debug("Write Protect at %x!\n", row);
-+			ops[i].status = -ENANDWP;
-+			return -ENANDWP;
-+		}
-+
-+		ops[i].status = nand->erase_block(nand, row);
-+		if (ops[i].status < 0) {
-+			ret = ops[i].status;
-+			continue;
-+		}
-+
-+		ops[i].status = nand->read_status(nand);
-+		if (ops[i].status & dev->status->erase_fail)
-+			ops[i].status = -ENANDERASE;
-+
-+		ret = min_t(int, ret, ops[i].status);
-+	}
-+
-+	return ret;
-+}
-+
-+/* read first bad mark on spare */
-+static int nand_chip_is_bad_block(struct nand_chip *chip,
-+				  struct nand_ops *ops,
-+				  int count)
-+{
-+	int i, ret, value;
-+	int status = 0;
-+	u8 *data, *tmp_buf;
-+
-+	tmp_buf = mem_alloc(1, chip->page_size);
-+	if (!tmp_buf)
-+		return -ENOMEM;
-+
-+	memset(tmp_buf, 0x00, chip->page_size);
-+
-+	/* Disable ECC */
-+	value = 0;
-+	ret = chip->chip_ctrl(chip, NFI_CTRL_ECC, &value);
-+	if (ret)
-+		goto out;
-+
-+	ret = chip->read_page(chip, ops, count);
-+	if (ret)
-+		goto out;
-+
-+	for (i = 0; i < count; i++) {
-+		data = ops[i].data;
-+
-+		/* temp solution for mt7622, because of no bad mark swap */
-+		if (!memcmp(data, tmp_buf, chip->page_size)) {
-+			ops[i].status = -ENANDBAD;
-+			status = -ENANDBAD;
-+			
-+		} else {
-+			ops[i].status = 0;
-+		}
-+	}
-+
-+	/* Enable ECC */
-+	value = 1;
-+	ret = chip->chip_ctrl(chip, NFI_CTRL_ECC, &value);
-+	if (ret)
-+		goto out;
-+
-+	mem_free(tmp_buf);
-+	return status;
-+
-+out:
-+	mem_free(tmp_buf);
-+	return ret;
-+}
-+
-+static int nand_chip_ctrl(struct nand_chip *chip, int cmd, void *args)
-+{
-+	return -EOPNOTSUPP;
-+}
-+
-+static int nand_chip_suspend(struct nand_chip *chip)
-+{
-+	return 0;
-+}
-+
-+static int nand_chip_resume(struct nand_chip *chip)
-+{
-+	return 0;
-+}
-+
-+struct nand_chip *nand_chip_init(struct nfi_resource *res)
-+{
-+	struct nand_chip *chip;
-+	struct nand_base *nand;
-+	struct nfi *nfi;
-+
-+	chip = mem_alloc(1, sizeof(struct nand_chip));
-+	if (!chip) {
-+		pr_info("nand chip alloc fail!\n");
-+		return NULL;
-+	}
-+
-+	nfi = nfi_init(res);
-+	if (!nfi) {
-+		pr_info("nfi init fail!\n");
-+		goto nfi_err;
-+	}
-+
-+	nand = nand_base_init(NULL, nfi);
-+	if (!nand) {
-+		pr_info("nand base init fail!\n");
-+		goto base_err;
-+	}
-+
-+	chip->nand = (void *)nand;
-+	chip->read_page = nand_chip_read_page;
-+	chip->write_page = nand_chip_write_page;
-+	chip->erase_block = nand_chip_erase_block;
-+	chip->is_bad_block = nand_chip_is_bad_block;
-+	chip->chip_ctrl = nand_chip_ctrl;
-+	chip->suspend = nand_chip_suspend;
-+	chip->resume = nand_chip_resume;
-+
-+	nand = nand_device_init(chip);
-+	if (!nand)
-+		goto nand_err;
-+
-+	chip->nand = (void *)nand;
-+	chip->plane_num = nand->dev->plane_num;
-+	chip->block_num = nand_total_blocks(nand->dev);
-+	chip->block_size = nand->dev->block_size;
-+	chip->block_pages = nand_block_pages(nand->dev);
-+	chip->page_size = nand->dev->page_size;
-+	chip->oob_size = nfi->fdm_size * div_down(chip->page_size,
-+						  nfi->sector_size);
-+	chip->sector_size = nfi->sector_size;
-+	chip->sector_spare_size = nfi->sector_spare_size;
-+	chip->min_program_pages = nand->dev->min_program_pages;
-+	chip->ecc_strength = nfi->ecc_strength;
-+	chip->ecc_parity_size = nfi->ecc_parity_size;
-+	chip->fdm_ecc_size = nfi->fdm_ecc_size;
-+	chip->fdm_reg_size = nfi->fdm_size;
-+
-+	return chip;
-+
-+nand_err:
-+	mem_free(nand);
-+base_err:
-+	nfi_exit(nfi);
-+nfi_err:
-+	mem_free(chip);
-+	return NULL;
-+}
-+
-+void nand_chip_exit(struct nand_chip *chip)
-+{
-+	nand_exit(chip->nand);
-+	mem_free(chip);
-+}
-diff --git a/drivers/mtd/nandx/core/nand_chip.h b/drivers/mtd/nandx/core/nand_chip.h
-new file mode 100644
-index 0000000000..3e9c8e6ca3
---- /dev/null
-+++ b/drivers/mtd/nandx/core/nand_chip.h
-@@ -0,0 +1,103 @@
-+/*
-+ * Copyright (C) 2017 MediaTek Inc.
-+ * Licensed under either
-+ *     BSD Licence, (see NOTICE for more details)
-+ *     GNU General Public License, version 2.0, (see NOTICE for more details)
-+ */
-+
-+#ifndef __NAND_CHIP_H__
-+#define __NAND_CHIP_H__
-+
-+enum nand_type {
-+	NAND_SPI,
-+	NAND_SLC,
-+	NAND_MLC,
-+	NAND_TLC
-+};
-+
-+/*
-+ * nand chip operation unit
-+ *    one nand_ops indicates one row operation
-+ * @row: nand chip row address, like as nand row
-+ * @col: nand chip column address, like as nand column
-+ * @len: operate data length, min is sector_size,
-+ *    max is page_size and sector_size aligned
-+ * @status: one operation result status
-+ * @data: data buffer for operation
-+ * @oob: oob buffer for operation, like as nand spare area
-+ */
-+struct nand_ops {
-+	int row;
-+	int col;
-+	int len;
-+	int status;
-+	void *data;
-+	void *oob;
-+};
-+
-+/*
-+ * nand chip descriptions
-+ *    nand chip includes nand controller and the several same nand devices
-+ * @nand_type: the nand type on this chip,
-+ *    the chip maybe have several nand device and the type must be same
-+ * @plane_num: the whole plane number on the chip
-+ * @block_num: the whole block number on the chip
-+ * @block_size: nand device block size
-+ * @block_pages: nand device block has page number
-+ * @page_size: nand device page size
-+ * @oob_size: chip out of band size, like as nand spare szie,
-+ *    but restricts this:
-+ *    the size is provied by nand controller(NFI),
-+ *    because NFI would use some nand spare size
-+ * @min_program_pages: chip needs min pages per program operations
-+ *    one page as one nand_ops
-+ * @sector_size: chip min read size
-+ * @sector_spare_size: spare size for sector, is spare_size/page_sectors
-+ * @ecc_strength: ecc stregth per sector_size, it would be for calculated ecc
-+ * @ecc_parity_size: ecc parity size for one  sector_size data
-+ * @nand: pointer to inherited struct nand_base
-+ * @read_page: read %count pages on chip
-+ * @write_page: write %count pages on chip
-+ * @erase_block: erase %count blocks on chip, one block is one nand_ops
-+ *    it is better to set nand_ops.row to block start row
-+ * @is_bad_block: judge the %count blocks on chip if they are bad
-+ *    by vendor specification
-+ * @chip_ctrl: control the chip features by nandx_ctrl_cmd
-+ * @suspend: suspend nand chip
-+ * @resume: resume nand chip
-+ */
-+struct nand_chip {
-+	int nand_type;
-+	int plane_num;
-+	int block_num;
-+	int block_size;
-+	int block_pages;
-+	int page_size;
-+	int oob_size;
-+
-+	int min_program_pages;
-+	int sector_size;
-+	int sector_spare_size;
-+	int ecc_strength;
-+	int ecc_parity_size;
-+	u32 fdm_ecc_size;
-+	u32 fdm_reg_size;
-+
-+	void *nand;
-+
-+	int (*read_page)(struct nand_chip *chip, struct nand_ops *ops,
-+			 int count);
-+	int (*write_page)(struct nand_chip *chip, struct nand_ops *ops,
-+			  int count);
-+	int (*erase_block)(struct nand_chip *chip, struct nand_ops *ops,
-+			   int count);
-+	int (*is_bad_block)(struct nand_chip *chip, struct nand_ops *ops,
-+			    int count);
-+	int (*chip_ctrl)(struct nand_chip *chip, int cmd, void *args);
-+	int (*suspend)(struct nand_chip *chip);
-+	int (*resume)(struct nand_chip *chip);
-+};
-+
-+struct nand_chip *nand_chip_init(struct nfi_resource *res);
-+void nand_chip_exit(struct nand_chip *chip);
-+#endif /* __NAND_CHIP_H__ */
-diff --git a/drivers/mtd/nandx/core/nand_device.c b/drivers/mtd/nandx/core/nand_device.c
-new file mode 100644
-index 0000000000..9f6764d1bc
---- /dev/null
-+++ b/drivers/mtd/nandx/core/nand_device.c
-@@ -0,0 +1,285 @@
-+/*
-+ * Copyright (C) 2017 MediaTek Inc.
-+ * Licensed under either
-+ *     BSD Licence, (see NOTICE for more details)
-+ *     GNU General Public License, version 2.0, (see NOTICE for more details)
-+ */
-+
-+#include "nandx_util.h"
-+#include "nandx_core.h"
-+#include "nand_chip.h"
-+#include "nand_device.h"
-+#include "nand_base.h"
-+
-+#define MAX_CHIP_DEVICE 4
-+#define PARAM_PAGE_LEN  2048
-+#define ONFI_CRC_BASE   0x4f4e
-+
-+static u16 nand_onfi_crc16(u16 crc, u8 const *p, size_t len)
-+{
-+	int i;
-+
-+	while (len--) {
-+		crc ^= *p++ << 8;
-+
-+		for (i = 0; i < 8; i++)
-+			crc = (crc << 1) ^ ((crc & 0x8000) ? 0x8005 : 0);
-+	}
-+
-+	return crc;
-+}
-+
-+static inline void decode_addr_cycle(u8 addr_cycle, u8 *row_cycle,
-+				     u8 *col_cycle)
-+{
-+	*row_cycle = addr_cycle & 0xf;
-+	*col_cycle = (addr_cycle >> 4) & 0xf;
-+}
-+
-+static int detect_onfi(struct nand_device *dev,
-+		       struct nand_onfi_params *onfi)
-+{
-+	struct nand_endurance *endurance = dev->endurance;
-+	u16 size, i, crc16;
-+	u8 *id;
-+
-+	size = sizeof(struct nand_onfi_params) - sizeof(u16);
-+
-+	for (i = 0; i < 3; i++) {
-+		crc16 = nand_onfi_crc16(ONFI_CRC_BASE, (u8 *)&onfi[i], size);
-+
-+		if (onfi[i].signature[0] == 'O' &&
-+		    onfi[i].signature[1] == 'N' &&
-+		    onfi[i].signature[2] == 'F' &&
-+		    onfi[i].signature[3] == 'I' &&
-+		    onfi[i].crc16 == crc16)
-+			break;
-+
-+		/* in some spi nand, onfi signature maybe "NAND" */
-+		if (onfi[i].signature[0] == 'N' &&
-+		    onfi[i].signature[1] == 'A' &&
-+		    onfi[i].signature[2] == 'N' &&
-+		    onfi[i].signature[3] == 'D' &&
-+		    onfi[i].crc16 == crc16)
-+			break;
-+	}
-+
-+	if (i == 3)
-+		return -ENODEV;
-+
-+	memcpy(dev->name, onfi[i].model, 20);
-+	id = onfi[i].manufacturer;
-+	dev->id = NAND_PACK_ID(id[0], id[1], id[2], id[3], id[4], id[5], id[6],
-+			       id[7]);
-+	dev->id_len = MAX_ID_NUM;
-+	dev->io_width = (onfi[i].features & 1) ? NAND_IO16 : NAND_IO8;
-+	decode_addr_cycle(onfi[i].addr_cycle, &dev->row_cycle,
-+			  &dev->col_cycle);
-+	dev->target_num = 1;
-+	dev->lun_num = onfi[i].lun_num;
-+	dev->plane_num = BIT(onfi[i].plane_address_bits);
-+	dev->block_num = onfi[i].lun_blocks / dev->plane_num;
-+	dev->block_size = onfi[i].block_pages * onfi[i].page_size;
-+	dev->page_size = onfi[i].page_size;
-+	dev->spare_size = onfi[i].spare_size;
-+
-+	endurance->ecc_req = onfi[i].ecc_req;
-+	endurance->pe_cycle = onfi[i].valid_block_endurance;
-+	endurance->max_bitflips = endurance->ecc_req >> 1;
-+
-+	return 0;
-+}
-+
-+static int detect_jedec(struct nand_device *dev,
-+			struct nand_jedec_params *jedec)
-+{
-+	struct nand_endurance *endurance = dev->endurance;
-+	u16 size, i, crc16;
-+	u8 *id;
-+
-+	size = sizeof(struct nand_jedec_params) - sizeof(u16);
-+
-+	for (i = 0; i < 3; i++) {
-+		crc16 = nand_onfi_crc16(ONFI_CRC_BASE, (u8 *)&jedec[i], size);
-+
-+		if (jedec[i].signature[0] == 'J' &&
-+		    jedec[i].signature[1] == 'E' &&
-+		    jedec[i].signature[2] == 'S' &&
-+		    jedec[i].signature[3] == 'D' &&
-+		    jedec[i].crc16 == crc16)
-+			break;
-+	}
-+
-+	if (i == 3)
-+		return -ENODEV;
-+
-+	memcpy(dev->name, jedec[i].model, 20);
-+	id = jedec[i].manufacturer;
-+	dev->id = NAND_PACK_ID(id[0], id[1], id[2], id[3], id[4], id[5], id[6],
-+			       id[7]);
-+	dev->id_len = MAX_ID_NUM;
-+	dev->io_width = (jedec[i].features & 1) ? NAND_IO16 : NAND_IO8;
-+	decode_addr_cycle(jedec[i].addr_cycle, &dev->row_cycle,
-+			  &dev->col_cycle);
-+	dev->target_num = 1;
-+	dev->lun_num = jedec[i].lun_num;
-+	dev->plane_num = BIT(jedec[i].plane_address_bits);
-+	dev->block_num = jedec[i].lun_blocks / dev->plane_num;
-+	dev->block_size = jedec[i].block_pages * jedec[i].page_size;
-+	dev->page_size = jedec[i].page_size;
-+	dev->spare_size = jedec[i].spare_size;
-+
-+	endurance->ecc_req = jedec[i].endurance_block0[0];
-+	endurance->pe_cycle = jedec[i].valid_block_endurance;
-+	endurance->max_bitflips = endurance->ecc_req >> 1;
-+
-+	return 0;
-+}
-+
-+static struct nand_device *detect_parameters_page(struct nand_base
-+						  *nand)
-+{
-+	struct nand_device *dev = nand->dev;
-+	void *params;
-+	int ret;
-+
-+	params = mem_alloc(1, PARAM_PAGE_LEN);
-+	if (!params)
-+		return NULL;
-+
-+	memset(params, 0, PARAM_PAGE_LEN);
-+	ret = nand->read_param_page(nand, params, PARAM_PAGE_LEN);
-+	if (ret < 0) {
-+		pr_info("read parameters page fail!\n");
-+		goto error;
-+	}
-+
-+	ret = detect_onfi(dev, params);
-+	if (ret) {
-+		pr_info("detect onfi device fail! try to detect jedec\n");
-+		ret = detect_jedec(dev, params);
-+		if (ret) {
-+			pr_info("detect jedec device fail!\n");
-+			goto error;
-+		}
-+	}
-+
-+	mem_free(params);
-+	return dev;
-+
-+error:
-+	mem_free(params);
-+	return NULL;
-+}
-+
-+static int read_device_id(struct nand_base *nand, int cs, u8 *id)
-+{
-+	int i;
-+
-+	nand->select_device(nand, cs);
-+	nand->reset(nand);
-+	nand->read_id(nand, id, MAX_ID_NUM);
-+	pr_info("device %d ID: ", cs);
-+
-+	for (i = 0; i < MAX_ID_NUM; i++)
-+		pr_info("%x ", id[i]);
-+
-+	pr_info("\n");
-+
-+	return 0;
-+}
-+
-+static int detect_more_device(struct nand_base *nand, u8 *id)
-+{
-+	u8 id_ext[MAX_ID_NUM];
-+	int i, j, target_num = 0;
-+
-+	for (i = 1; i < MAX_CHIP_DEVICE; i++) {
-+		memset(id_ext, 0xff, MAX_ID_NUM);
-+		read_device_id(nand, i, id_ext);
-+
-+		for (j = 0; j < MAX_ID_NUM; j++) {
-+			if (id_ext[j] != id[j])
-+				goto out;
-+		}
-+
-+		target_num += 1;
-+	}
-+
-+out:
-+	return target_num;
-+}
-+
-+static struct nand_device *scan_device_table(const u8 *id, int id_len)
-+{
-+	struct nand_device *dev;
-+	int i = 0, j;
-+	u8 ids[MAX_ID_NUM] = {0};
-+
-+	while (1) {
-+		dev = nand_get_device(i);
-+
-+		if (!strcmp(dev->name, "NO-DEVICE"))
-+			break;
-+
-+		if (id_len < dev->id_len) {
-+			i += 1;
-+			continue;
-+		}
-+
-+		NAND_UNPACK_ID(dev->id, ids, MAX_ID_NUM);
-+		for (j = 0; j < dev->id_len; j++) {
-+			if (ids[j] != id[j])
-+				break;
-+		}
-+
-+		if (j == dev->id_len)
-+			break;
-+
-+		i += 1;
-+	}
-+
-+	return dev;
-+}
-+
-+int nand_detect_device(struct nand_base *nand)
-+{
-+	struct nand_device *dev;
-+	u8 id[MAX_ID_NUM] = { 0 };
-+	int target_num = 0;
-+
-+	/* Get nand device default setting for reset/read_id */
-+	nand->dev = scan_device_table(NULL, -1);
-+
-+	read_device_id(nand, 0, id);
-+	dev = scan_device_table(id, MAX_ID_NUM);
-+
-+	if (!strcmp(dev->name, "NO-DEVICE")) {
-+		pr_info("device scan fail\n");
-+		return -ENODEV;
-+	}
-+
-+	/* TobeFix: has null pointer issue in this funciton */
-+	if (!strcmp(dev->name, "NO-DEVICE")) {
-+		pr_info("device scan fail, detect parameters page\n");
-+		dev = detect_parameters_page(nand);
-+		if (!dev) {
-+			pr_info("detect parameters fail\n");
-+			return -ENODEV;
-+		}
-+	}
-+
-+	if (dev->target_num > 1)
-+		target_num = detect_more_device(nand, id);
-+
-+	target_num += 1;
-+	pr_debug("chip has target device num: %d\n", target_num);
-+
-+	if (dev->target_num != target_num)
-+		dev->target_num = target_num;
-+
-+	nand->dev = dev;
-+
-+	return 0;
-+}
-+
-diff --git a/drivers/mtd/nandx/core/nand_device.h b/drivers/mtd/nandx/core/nand_device.h
-new file mode 100644
-index 0000000000..e142cf529d
---- /dev/null
-+++ b/drivers/mtd/nandx/core/nand_device.h
-@@ -0,0 +1,608 @@
-+/*
-+ * Copyright (C) 2017 MediaTek Inc.
-+ * Licensed under either
-+ *     BSD Licence, (see NOTICE for more details)
-+ *     GNU General Public License, version 2.0, (see NOTICE for more details)
-+ */
-+
-+#ifndef __NAND_DEVICE_H__
-+#define __NAND_DEVICE_H__
-+
-+/* onfi 3.2 */
-+struct nand_onfi_params {
-+	/* Revision information and features block. 0 */
-+	/*
-+	 * Byte 0: 4Fh,
-+	 * Byte 1: 4Eh,
-+	 * Byte 2: 46h,
-+	 * Byte 3: 49h,
-+	 */
-+	u8 signature[4];
-+	/*
-+	 * 9-15 Reserved (0)
-+	 * 8 1 = supports ONFI version 3.2
-+	 * 7 1 = supports ONFI version 3.1
-+	 * 6 1 = supports ONFI version 3.0
-+	 * 5 1 = supports ONFI version 2.3
-+	 * 4 1 = supports ONFI version 2.2
-+	 * 3 1 = supports ONFI version 2.1
-+	 * 2 1 = supports ONFI version 2.0
-+	 * 1 1 = supports ONFI version 1.0
-+	 * 0 Reserved (0)
-+	 */
-+	u16 revision;
-+	/*
-+	 * 13-15 Reserved (0)
-+	 * 12 1 = supports external Vpp
-+	 * 11 1 = supports Volume addressing
-+	 * 10 1 = supports NV-DDR2
-+	 * 9 1 = supports EZ NAND
-+	 * 8 1 = supports program page register clear enhancement
-+	 * 7 1 = supports extended parameter page
-+	 * 6 1 = supports multi-plane read operations
-+	 * 5 1 = supports NV-DDR
-+	 * 4 1 = supports odd to even page Copyback
-+	 * 3 1 = supports multi-plane program and erase operations
-+	 * 2 1 = supports non-sequential page programming
-+	 * 1 1 = supports multiple LUN operations
-+	 * 0 1 = supports 16-bit data bus width
-+	 */
-+	u16 features;
-+	/*
-+	 * 13-15 Reserved (0)
-+	 * 12 1 = supports LUN Get and LUN Set Features
-+	 * 11 1 = supports ODT Configure
-+	 * 10 1 = supports Volume Select
-+	 * 9 1 = supports Reset LUN
-+	 * 8 1 = supports Small Data Move
-+	 * 7 1 = supports Change Row Address
-+	 * 6 1 = supports Change Read Column Enhanced
-+	 * 5 1 = supports Read Unique ID
-+	 * 4 1 = supports Copyback
-+	 * 3 1 = supports Read Status Enhanced
-+	 * 2 1 = supports Get Features and Set Features
-+	 * 1 1 = supports Read Cache commands
-+	 * 0 1 = supports Page Cache Program command
-+	 */
-+	u16 opt_cmds;
-+	/*
-+	 * 4-7 Reserved (0)
-+	 * 3 1 = supports Multi-plane Block Erase
-+	 * 2 1 = supports Multi-plane Copyback Program
-+	 * 1 1 = supports Multi-plane Page Program
-+	 * 0 1 = supports Random Data Out
-+	 */
-+	u8 advance_cmds;
-+	u8 reserved0[1];
-+	u16 extend_param_len;
-+	u8 param_page_num;
-+	u8 reserved1[17];
-+
-+	/* Manufacturer information block. 32 */
-+	u8 manufacturer[12];
-+	u8 model[20];
-+	u8 jedec_id;
-+	u16 data_code;
-+	u8 reserved2[13];
-+
-+	/* Memory organization block. 80 */
-+	u32 page_size;
-+	u16 spare_size;
-+	u32 partial_page_size; /* obsolete */
-+	u16 partial_spare_size; /* obsolete */
-+	u32 block_pages;
-+	u32 lun_blocks;
-+	u8 lun_num;
-+	/*
-+	 * 4-7 Column address cycles
-+	 * 0-3 Row address cycles
-+	 */
-+	u8 addr_cycle;
-+	u8 cell_bits;
-+	u16 lun_max_bad_blocks;
-+	u16 block_endurance;
-+	u8 target_begin_valid_blocks;
-+	u16 valid_block_endurance;
-+	u8 page_program_num;
-+	u8 partial_program_attr; /* obsolete */
-+	u8 ecc_req;
-+	/*
-+	 * 4-7 Reserved (0)
-+	 * 0-3 Number of plane address bits
-+	 */
-+	u8 plane_address_bits;
-+	/*
-+	 * 6-7 Reserved (0)
-+	 * 5 1 = lower bit XNOR block address restriction
-+	 * 4 1 = read cache supported
-+	 * 3 Address restrictions for cache operations
-+	 * 2 1 = program cache supported
-+	 * 1 1 = no block address restrictions
-+	 * 0 Overlapped / concurrent multi-plane support
-+	 */
-+	u8 multi_plane_attr;
-+	u8 ez_nand_support;
-+	u8 reserved3[12];
-+
-+	/* Electrical parameters block. 128 */
-+	u8 io_pin_max_capacitance;
-+	/*
-+	 * 6-15 Reserved (0)
-+	 * 5 1 = supports timing mode 5
-+	 * 4 1 = supports timing mode 4
-+	 * 3 1 = supports timing mode 3
-+	 * 2 1 = supports timing mode 2
-+	 * 1 1 = supports timing mode 1
-+	 * 0 1 = supports timing mode 0, shall be 1
-+	 */
-+	u16 sdr_timing_mode;
-+	u16 sdr_program_cache_timing_mode; /* obsolete */
-+	u16 tPROG;
-+	u16 tBERS;
-+	u16 tR;
-+	u16 tCCS;
-+	/*
-+	 * 7 Reserved (0)
-+	 * 6 1 = supports NV-DDR2 timing mode 8
-+	 * 5 1 = supports NV-DDR timing mode 5
-+	 * 4 1 = supports NV-DDR timing mode 4
-+	 * 3 1 = supports NV-DDR timing mode 3
-+	 * 2 1 = supports NV-DDR timing mode 2
-+	 * 1 1 = supports NV-DDR timing mode 1
-+	 * 0 1 = supports NV-DDR timing mode 0
-+	 */
-+	u8 nvddr_timing_mode;
-+	/*
-+	 * 7 1 = supports timing mode 7
-+	 * 6 1 = supports timing mode 6
-+	 * 5 1 = supports timing mode 5
-+	 * 4 1 = supports timing mode 4
-+	 * 3 1 = supports timing mode 3
-+	 * 2 1 = supports timing mode 2
-+	 * 1 1 = supports timing mode 1
-+	 * 0 1 = supports timing mode 0
-+	 */
-+	u8 nvddr2_timing_mode;
-+	/*
-+	 * 4-7 Reserved (0)
-+	 * 3 1 = device requires Vpp enablement sequence
-+	 * 2 1 = device supports CLK stopped for data input
-+	 * 1 1 = typical capacitance
-+	 * 0 tCAD value to use
-+	 */
-+	u8 nvddr_fetures;
-+	u16 clk_pin_capacitance;
-+	u16 io_pin_capacitance;
-+	u16 input_pin_capacitance;
-+	u8 input_pin_max_capacitance;
-+	/*
-+	 * 3-7 Reserved (0)
-+	 * 2 1 = supports 18 Ohm drive strength
-+	 * 1 1 = supports 25 Ohm drive strength
-+	 * 0 1 = supports driver strength settings
-+	 */
-+	u8 drive_strength;
-+	u16 tR_multi_plane;
-+	u16 tADL;
-+	u16 tR_ez_nand;
-+	/*
-+	 * 6-7 Reserved (0)
-+	 * 5 1 = external VREFQ required for >= 200 MT/s
-+	 * 4 1 = supports differential signaling for DQS
-+	 * 3 1 = supports differential signaling for RE_n
-+	 * 2 1 = supports ODT value of 30 Ohms
-+	 * 1 1 = supports matrix termination ODT
-+	 * 0 1 = supports self-termination ODT
-+	 */
-+	u8 nvddr2_features;
-+	u8 nvddr2_warmup_cycles;
-+	u8 reserved4[4];
-+
-+	/* vendor block. 164 */
-+	u16 vendor_revision;
-+	u8      vendor_spec[88];
-+
-+	/* CRC for Parameter Page. 254 */
-+	u16 crc16;
-+} __packed;
-+
-+/* JESD230-B */
-+struct nand_jedec_params {
-+	/* Revision information and features block. 0 */
-+	/*
-+	 * Byte 0:4Ah
-+	 * Byte 1:45h
-+	 * Byte 2:53h
-+	 * Byte 3:44h
-+	 */
-+	u8 signature[4];
-+	/*
-+	 * 3-15: Reserved (0)
-+	 * 2: 1 = supports parameter page revision 1.0 and standard revision 1.0
-+	 * 1: 1 = supports vendor specific parameter page
-+	 * 0: Reserved (0)
-+	 */
-+	u16 revision;
-+	/*
-+	 * 9-15 Reserved (0)
-+	 * 8: 1 = supports program page register clear enhancement
-+	 * 7: 1 = supports external Vpp
-+	 * 6: 1 = supports Toggle Mode DDR
-+	 * 5: 1 = supports Synchronous DDR
-+	 * 4: 1 = supports multi-plane read operations
-+	 * 3: 1 = supports multi-plane program and erase operations
-+	 * 2: 1 = supports non-sequential page programming
-+	 * 1: 1 = supports multiple LUN operations
-+	 * 0: 1 = supports 16-bit data bus width
-+	 */
-+	u16 features;
-+	/*
-+	 * 11-23: Reserved (0)
-+	 * 10: 1 = supports Synchronous Reset
-+	 * 9: 1 = supports Reset LUN (Primary)
-+	 * 8: 1 = supports Small Data Move
-+	 * 7: 1 = supports Multi-plane Copyback Program (Primary)
-+	 * 6: 1 = supports Random Data Out (Primary)
-+	 * 5: 1 = supports Read Unique ID
-+	 * 4: 1 = supports Copyback
-+	 * 3: 1 = supports Read Status Enhanced (Primary)
-+	 * 2: 1 = supports Get Features and Set Features
-+	 * 1: 1 = supports Read Cache commands
-+	 * 0: 1 = supports Page Cache Program command
-+	 */
-+	u8 opt_cmds[3];
-+	/*
-+	 * 8-15: Reserved (0)
-+	 * 7: 1 = supports secondary Read Status Enhanced
-+	 * 6: 1 = supports secondary Multi-plane Block Erase
-+	 * 5: 1 = supports secondary Multi-plane Copyback Program
-+	 * 4: 1 = supports secondary Multi-plane Program
-+	 * 3: 1 = supports secondary Random Data Out
-+	 * 2: 1 = supports secondary Multi-plane Copyback Read
-+	 * 1: 1 = supports secondary Multi-plane Read Cache Random
-+	 * 0: 1 = supports secondary Multi-plane Read
-+	 */
-+	u16 secondary_cmds;
-+	u8 param_page_num;
-+	u8 reserved0[18];
-+
-+	/* Manufacturer information block. 32*/
-+	u8 manufacturer[12];
-+	u8 model[20];
-+	u8 jedec_id[6];
-+	u8 reserved1[10];
-+
-+	/* Memory organization block. 80 */
-+	u32 page_size;
-+	u16 spare_size;
-+	u8 reserved2[6];
-+	u32 block_pages;
-+	u32 lun_blocks;
-+	u8 lun_num;
-+	/*
-+	 * 4-7 Column address cycles
-+	 * 0-3 Row address cycles
-+	 */
-+	u8 addr_cycle;
-+	u8 cell_bits;
-+	u8 page_program_num;
-+	/*
-+	 * 4-7 Reserved (0)
-+	 * 0-3 Number of plane address bits
-+	 */
-+	u8 plane_address_bits;
-+	/*
-+	 * 3-7: Reserved (0)
-+	 * 2: 1= read cache supported
-+	 * 1: 1 = program cache supported
-+	 * 0: 1= No multi-plane block address restrictions
-+	 */
-+	u8 multi_plane_attr;
-+	u8 reserved3[38];
-+
-+	/* Electrical parameters block. 144 */
-+	/*
-+	 * 6-15: Reserved (0)
-+	 * 5: 1 = supports 20 ns speed grade (50 MHz)
-+	 * 4: 1 = supports 25 ns speed grade (40 MHz)
-+	 * 3: 1 = supports 30 ns speed grade (~33 MHz)
-+	 * 2: 1 = supports 35 ns speed grade (~28 MHz)
-+	 * 1: 1 = supports 50 ns speed grade (20 MHz)
-+	 * 0: 1 = supports 100 ns speed grade (10 MHz)
-+	 */
-+	u16 sdr_speed;
-+	/*
-+	 * 8-15: Reserved (0)
-+	 * 7: 1 = supports 5 ns speed grade (200 MHz)
-+	 * 6: 1 = supports 6 ns speed grade (~166 MHz)
-+	 * 5: 1 = supports 7.5 ns speed grade (~133 MHz)
-+	 * 4: 1 = supports 10 ns speed grade (100 MHz)
-+	 * 3: 1 = supports 12 ns speed grade (~83 MHz)
-+	 * 2: 1 = supports 15 ns speed grade (~66 MHz)
-+	 * 1: 1 = supports 25 ns speed grade (40 MHz)
-+	 * 0: 1 = supports 30 ns speed grade (~33 MHz)
-+	 */
-+	u16 toggle_ddr_speed;
-+	/*
-+	 * 6-15: Reserved (0)
-+	 * 5: 1 = supports 10 ns speed grade (100 MHz)
-+	 * 4: 1 = supports 12 ns speed grade (~83 MHz)
-+	 * 3: 1 = supports 15 ns speed grade (~66 MHz)
-+	 * 2: 1 = supports 20 ns speed grade (50 MHz)
-+	 * 1: 1 = supports 30 ns speed grade (~33 MHz)
-+	 * 0: 1 = supports 50 ns speed grade (20 MHz)
-+	 */
-+	u16 sync_ddr_speed;
-+	u8 sdr_features;
-+	u8 toggle_ddr_features;
-+	/*
-+	 * 2-7: Reserved (0)
-+	 * 1: Device supports CK stopped for data input
-+	 * 0: tCAD value to use
-+	 */
-+	u8 sync_ddr_features;
-+	u16 tPROG;
-+	u16 tBERS;
-+	u16 tR;
-+	u16 tR_multi_plane;
-+	u16 tCCS;
-+	u16 io_pin_capacitance;
-+	u16 input_pin_capacitance;
-+	u16 ck_pin_capacitance;
-+	/*
-+	 * 3-7: Reserved (0)
-+	 * 2: 1 = supports 18 ohm drive strength
-+	 * 1: 1 = supports 25 ohm drive strength
-+	 * 0: 1 = supports 35ohm/50ohm drive strength
-+	 */
-+	u8 drive_strength;
-+	u16 tADL;
-+	u8 reserved4[36];
-+
-+	/* ECC and endurance block. 208 */
-+	u8 target_begin_valid_blocks;
-+	u16 valid_block_endurance;
-+	/*
-+	 * Byte 0: Number of bits ECC correctability
-+	 * Byte 1: Codeword size
-+	 * Byte 2-3: Bad blocks maximum per LUN
-+	 * Byte 4-5: Block endurance
-+	 * Byte 6-7: Reserved (0)
-+	 */
-+	u8 endurance_block0[8];
-+	u8 endurance_block1[8];
-+	u8 endurance_block2[8];
-+	u8 endurance_block3[8];
-+	u8 reserved5[29];
-+
-+	/* Reserved. 272 */
-+	u8 reserved6[148];
-+
-+	/* Vendor specific block. 420  */
-+	u16 vendor_revision;
-+	u8      vendor_spec[88];
-+
-+	/* CRC for Parameter Page. 510 */
-+	u16 crc16;
-+} __packed;
-+
-+/* parallel nand io width */
-+enum nand_io_width {
-+	NAND_IO8,
-+	NAND_IO16
-+};
-+
-+/* all supported nand timming type */
-+enum nand_timing_type {
-+	NAND_TIMING_SDR,
-+	NAND_TIMING_SYNC_DDR,
-+	NAND_TIMING_TOGGLE_DDR,
-+	NAND_TIMING_NVDDR2
-+};
-+
-+/* nand basic commands */
-+struct nand_cmds {
-+	short reset;
-+	short read_id;
-+	short read_status;
-+	short read_param_page;
-+	short set_feature;
-+	short get_feature;
-+	short read_1st;
-+	short read_2nd;
-+	short random_out_1st;
-+	short random_out_2nd;
-+	short program_1st;
-+	short program_2nd;
-+	short erase_1st;
-+	short erase_2nd;
-+	short read_cache;
-+	short read_cache_last;
-+	short program_cache;
-+};
-+
-+/*
-+ * addressing for nand physical address
-+ * @row_bit_start: row address start bit
-+ * @block_bit_start: block address start bit
-+ * @plane_bit_start: plane address start bit
-+ * @lun_bit_start: lun address start bit
-+ */
-+struct nand_addressing {
-+	u8 row_bit_start;
-+	u8 block_bit_start;
-+	u8 plane_bit_start;
-+	u8 lun_bit_start;
-+};
-+
-+/*
-+ * nand operations status
-+ * @array_busy: indicates device array operation busy
-+ * @write_protect: indicates the device cannot be wrote or erased
-+ * @erase_fail: indicates erase operation fail
-+ * @program_fail: indicates program operation fail
-+ */
-+struct nand_status {
-+	u8 array_busy;
-+	u8 write_protect;
-+	u8 erase_fail;
-+	u8 program_fail;
-+};
-+
-+/*
-+ * nand endurance information
-+ * @pe_cycle: max program/erase cycle for nand stored data stability
-+ * @ecc_req: ecc strength required for the nand, measured per 1KB
-+ * @max_bitflips: bitflips is ecc corrected bits,
-+ *    max_bitflips is the threshold for nand stored data stability
-+ *    if corrected bits is over max_bitflips, stored data must be moved
-+ *    to another good block
-+ */
-+struct nand_endurance {
-+	int pe_cycle;
-+	int ecc_req;
-+	int max_bitflips;
-+};
-+
-+/* wait for nand busy type */
-+enum nand_wait_type {
-+	NAND_WAIT_IRQ,
-+	NAND_WAIT_POLLING,
-+	NAND_WAIT_TWHR2,
-+};
-+
-+/* each nand array operations time */
-+struct nand_array_timing {
-+	u16 tRST;
-+	u16 tWHR;
-+	u16 tR;
-+	u16 tRCBSY;
-+	u16 tFEAT;
-+	u16 tPROG;
-+	u16 tPCBSY;
-+	u16 tBERS;
-+	u16 tDBSY;
-+};
-+
-+/* nand sdr interface timing required */
-+struct nand_sdr_timing {
-+	u16 tREA;
-+	u16 tREH;
-+	u16 tCR;
-+	u16 tRP;
-+	u16 tWP;
-+	u16 tWH;
-+	u16 tWHR;
-+	u16 tCLS;
-+	u16 tALS;
-+	u16 tCLH;
-+	u16 tALH;
-+	u16 tWC;
-+	u16 tRC;
-+};
-+
-+/* nand onfi ddr (nvddr) interface timing required */
-+struct nand_onfi_timing {
-+	u16 tCAD;
-+	u16 tWPRE;
-+	u16 tWPST;
-+	u16 tWRCK;
-+	u16 tDQSCK;
-+	u16 tWHR;
-+};
-+
-+/* nand toggle ddr (toggle 1.0) interface timing required */
-+struct nand_toggle_timing {
-+	u16 tCS;
-+	u16 tCH;
-+	u16 tCAS;
-+	u16 tCAH;
-+	u16 tCALS;
-+	u16 tCALH;
-+	u16 tWP;
-+	u16 tWPRE;
-+	u16 tWPST;
-+	u16 tWPSTH;
-+	u16 tCR;
-+	u16 tRPRE;
-+	u16 tRPST;
-+	u16 tRPSTH;
-+	u16 tCDQSS;
-+	u16 tWHR;
-+};
-+
-+/* nand basic device information */
-+struct nand_device {
-+	u8 *name;
-+	u64 id;
-+	u8 id_len;
-+	u8 io_width;
-+	u8 row_cycle;
-+	u8 col_cycle;
-+	u8 target_num;
-+	u8 lun_num;
-+	u8 plane_num;
-+	int block_num;
-+	int block_size;
-+	int page_size;
-+	int spare_size;
-+	int min_program_pages;
-+	struct nand_cmds *cmds;
-+	struct nand_addressing *addressing;
-+	struct nand_status *status;
-+	struct nand_endurance *endurance;
-+	struct nand_array_timing *array_timing;
-+};
-+
-+#define NAND_DEVICE(_name, _id, _id_len, _io_width, _row_cycle, \
-+		    _col_cycle, _target_num, _lun_num, _plane_num, \
-+		    _block_num, _block_size, _page_size, _spare_size, \
-+		    _min_program_pages, _cmds, _addressing, _status, \
-+		    _endurance, _array_timing) \
-+{ \
-+	_name, _id, _id_len, _io_width, _row_cycle, \
-+	_col_cycle, _target_num, _lun_num, _plane_num, \
-+	_block_num, _block_size, _page_size, _spare_size, \
-+	_min_program_pages, _cmds, _addressing, _status, \
-+	_endurance, _array_timing \
-+}
-+
-+#define MAX_ID_NUM      sizeof(u64)
-+
-+#define NAND_PACK_ID(id0, id1, id2, id3, id4, id5, id6, id7) \
-+	( \
-+	  id0 | id1 << 8 | id2 << 16 | id3 << 24 | \
-+	  (u64)id4 << 32 | (u64)id5 << 40 | \
-+	  (u64)id6 << 48 | (u64)id7 << 56 \
-+	)
-+
-+#define NAND_UNPACK_ID(id, ids, len) \
-+	do { \
-+		int _i; \
-+		for (_i = 0; _i < len; _i++) \
-+			ids[_i] = id >> (_i << 3) & 0xff; \
-+	} while (0)
-+
-+static inline int nand_block_pages(struct nand_device *device)
-+{
-+	return div_down(device->block_size, device->page_size);
-+}
-+
-+static inline int nand_lun_blocks(struct nand_device *device)
-+{
-+	return device->plane_num * device->block_num;
-+}
-+
-+static inline int nand_target_blocks(struct nand_device *device)
-+{
-+	return device->lun_num * device->plane_num * device->block_num;
-+}
-+
-+static inline int nand_total_blocks(struct nand_device *device)
-+{
-+	return device->target_num * device->lun_num * device->plane_num *
-+	       device->block_num;
-+}
-+
-+struct nand_device *nand_get_device(int index);
-+#endif /* __NAND_DEVICE_H__ */
-diff --git a/drivers/mtd/nandx/core/nfi.h b/drivers/mtd/nandx/core/nfi.h
-new file mode 100644
-index 0000000000..ba84e73ccc
---- /dev/null
-+++ b/drivers/mtd/nandx/core/nfi.h
-@@ -0,0 +1,51 @@
-+/*
-+ * Copyright (C) 2017 MediaTek Inc.
-+ * Licensed under either
-+ *     BSD Licence, (see NOTICE for more details)
-+ *     GNU General Public License, version 2.0, (see NOTICE for more details)
-+ */
-+
-+#ifndef __NFI_H__
-+#define __NFI_H__
-+
-+struct nfi_format {
-+	int page_size;
-+	int spare_size;
-+	int ecc_req;
-+};
-+
-+struct nfi {
-+	int sector_size;
-+	int sector_spare_size;
-+	int fdm_size; /*for sector*/
-+	int fdm_ecc_size;
-+	int ecc_strength;
-+	int ecc_parity_size; /*for sector*/
-+
-+	int (*select_chip)(struct nfi *nfi, int cs);
-+	int (*set_format)(struct nfi *nfi, struct nfi_format *format);
-+	int (*set_timing)(struct nfi *nfi, void *timing, int type);
-+	int (*nfi_ctrl)(struct nfi *nfi, int cmd, void *args);
-+
-+	int (*reset)(struct nfi *nfi);
-+	int (*send_cmd)(struct nfi *nfi, short cmd);
-+	int (*send_addr)(struct nfi *nfi, int col, int row,
-+			 int col_cycle, int row_cycle);
-+	int (*trigger)(struct nfi *nfi);
-+
-+	int (*write_page)(struct nfi *nfi, u8 *data, u8 *fdm);
-+	int (*write_bytes)(struct nfi *nfi, u8 *data, int count);
-+	int (*read_sectors)(struct nfi *nfi, u8 *data, u8 *fdm,
-+			    int sectors);
-+	int (*read_bytes)(struct nfi *nfi, u8 *data, int count);
-+
-+	int (*wait_ready)(struct nfi *nfi, int type, u32 timeout);
-+
-+	int (*enable_randomizer)(struct nfi *nfi, u32 row, bool encode);
-+	int (*disable_randomizer)(struct nfi *nfi);
-+};
-+
-+struct nfi *nfi_init(struct nfi_resource *res);
-+void nfi_exit(struct nfi *nfi);
-+
-+#endif /* __NFI_H__ */
-diff --git a/drivers/mtd/nandx/core/nfi/nfi_base.c b/drivers/mtd/nandx/core/nfi/nfi_base.c
-new file mode 100644
-index 0000000000..d8679d7aa3
---- /dev/null
-+++ b/drivers/mtd/nandx/core/nfi/nfi_base.c
-@@ -0,0 +1,1357 @@
-+/*
-+ * Copyright (C) 2017 MediaTek Inc.
-+ * Licensed under either
-+ *     BSD Licence, (see NOTICE for more details)
-+ *     GNU General Public License, version 2.0, (see NOTICE for more details)
-+ */
-+
-+/**
-+ * nfi_base.c - the base logic for nfi to access nand flash
-+ *
-+ * slc/mlc/tlc could use same code to access nand
-+ * of cause, there still some work need to do
-+ * even for spi nand, there should be a chance to integrate code together
-+ */
-+
-+#include "nandx_util.h"
-+#include "nandx_core.h"
-+#include "../nfi.h"
-+#include "../nand_device.h"
-+#include "nfi_regs.h"
-+#include "nfiecc.h"
-+#include "nfi_base.h"
-+
-+static const int spare_size_mt7622[] = {
-+	16, 26, 27, 28
-+};
-+
-+#define RAND_SEED_SHIFT(op) \
-+	((op) == RAND_ENCODE ? ENCODE_SEED_SHIFT : DECODE_SEED_SHIFT)
-+#define RAND_EN(op) \
-+	((op) == RAND_ENCODE ? RAN_ENCODE_EN : RAN_DECODE_EN)
-+
-+#define SS_SEED_NUM     128
-+static u16 ss_randomizer_seed[SS_SEED_NUM] = {
-+	0x576A, 0x05E8, 0x629D, 0x45A3, 0x649C, 0x4BF0, 0x2342, 0x272E,
-+	0x7358, 0x4FF3, 0x73EC, 0x5F70, 0x7A60, 0x1AD8, 0x3472, 0x3612,
-+	0x224F, 0x0454, 0x030E, 0x70A5, 0x7809, 0x2521, 0x484F, 0x5A2D,
-+	0x492A, 0x043D, 0x7F61, 0x3969, 0x517A, 0x3B42, 0x769D, 0x0647,
-+	0x7E2A, 0x1383, 0x49D9, 0x07B8, 0x2578, 0x4EEC, 0x4423, 0x352F,
-+	0x5B22, 0x72B9, 0x367B, 0x24B6, 0x7E8E, 0x2318, 0x6BD0, 0x5519,
-+	0x1783, 0x18A7, 0x7B6E, 0x7602, 0x4B7F, 0x3648, 0x2C53, 0x6B99,
-+	0x0C23, 0x67CF, 0x7E0E, 0x4D8C, 0x5079, 0x209D, 0x244A, 0x747B,
-+	0x350B, 0x0E4D, 0x7004, 0x6AC3, 0x7F3E, 0x21F5, 0x7A15, 0x2379,
-+	0x1517, 0x1ABA, 0x4E77, 0x15A1, 0x04FA, 0x2D61, 0x253A, 0x1302,
-+	0x1F63, 0x5AB3, 0x049A, 0x5AE8, 0x1CD7, 0x4A00, 0x30C8, 0x3247,
-+	0x729C, 0x5034, 0x2B0E, 0x57F2, 0x00E4, 0x575B, 0x6192, 0x38F8,
-+	0x2F6A, 0x0C14, 0x45FC, 0x41DF, 0x38DA, 0x7AE1, 0x7322, 0x62DF,
-+	0x5E39, 0x0E64, 0x6D85, 0x5951, 0x5937, 0x6281, 0x33A1, 0x6A32,
-+	0x3A5A, 0x2BAC, 0x743A, 0x5E74, 0x3B2E, 0x7EC7, 0x4FD2, 0x5D28,
-+	0x751F, 0x3EF8, 0x39B1, 0x4E49, 0x746B, 0x6EF6, 0x44BE, 0x6DB7
-+};
-+
-+#if 0
-+static void dump_register(void *regs)
-+{
-+	int i;
-+
-+	pr_info("registers:\n");
-+	for (i = 0; i < 0x600; i += 0x10) {
-+		pr_info("    address 0x%X : %X %X %X %X\n",
-+			(u32)((unsigned long)regs + i),
-+			(u32)readl(regs + i),
-+			(u32)readl(regs + i + 0x4),
-+			(u32)readl(regs + i + 0x8),
-+			(u32)readl(regs + i + 0xC));
-+	}
-+}
-+#endif
-+
-+static int nfi_enable_randomizer(struct nfi *nfi, u32 row, bool encode)
-+{
-+	struct nfi_base *nb = nfi_to_base(nfi);
-+	enum randomizer_op op = RAND_ENCODE;
-+	void *regs = nb->res.nfi_regs;
-+	u32 val;
-+
-+	if (!encode)
-+		op = RAND_DECODE;
-+
-+	/* randomizer type and reseed type setup */
-+	val = readl(regs + NFI_CNFG);
-+	val |= CNFG_RAND_SEL | CNFG_RESEED_SEC_EN;
-+	writel(val, regs + NFI_CNFG);
-+
-+	/* randomizer seed and type setup */
-+	val = ss_randomizer_seed[row % SS_SEED_NUM] & RAN_SEED_MASK;
-+	val <<= RAND_SEED_SHIFT(op);
-+	val |= RAND_EN(op);
-+	writel(val, regs + NFI_RANDOM_CNFG);
-+
-+	return 0;
-+}
-+
-+static int nfi_disable_randomizer(struct nfi *nfi)
-+{
-+	struct nfi_base *nb = nfi_to_base(nfi);
-+
-+	writel(0, nb->res.nfi_regs + NFI_RANDOM_CNFG);
-+
-+	return 0;
-+}
-+
-+static int nfi_irq_handler(int irq, void *data)
-+{
-+	struct nfi_base *nb = (struct nfi_base *) data;
-+	void *regs = nb->res.nfi_regs;
-+	u16 status, en;
-+
-+	status = readw(regs + NFI_INTR_STA);
-+	en = readw(regs + NFI_INTR_EN);
-+
-+	if (!(status & en))
-+		return NAND_IRQ_NONE;
-+
-+	writew(~status & en, regs + NFI_INTR_EN);
-+
-+	nandx_event_complete(nb->done);
-+
-+	return NAND_IRQ_HANDLED;
-+}
-+
-+static int nfi_select_chip(struct nfi *nfi, int cs)
-+{
-+	struct nfi_base *nb = nfi_to_base(nfi);
-+
-+	writel(cs, nb->res.nfi_regs + NFI_CSEL);
-+
-+	return 0;
-+}
-+
-+static inline void set_op_mode(void *regs, u32 mode)
-+{
-+	u32 val = readl(regs + NFI_CNFG);
-+
-+	val &= ~CNFG_OP_MODE_MASK;
-+	val |= mode;
-+
-+	writel(val, regs + NFI_CNFG);
-+}
-+
-+static int nfi_reset(struct nfi *nfi)
-+{
-+	struct nfi_base *nb = nfi_to_base(nfi);
-+	void *regs = nb->res.nfi_regs;
-+	int ret, val;
-+
-+	/* The NFI reset to reset all registers and force the NFI
-+	 * master be early terminated
-+	 */
-+	writel(CON_FIFO_FLUSH | CON_NFI_RST, regs + NFI_CON);
-+
-+	/* check state of NFI internal FSM and NAND interface FSM */
-+	ret = readl_poll_timeout_atomic(regs + NFI_MASTER_STA, val,
-+					!(val & MASTER_BUS_BUSY),
-+					10, NFI_TIMEOUT);
-+	if (ret)
-+		pr_info("nfi reset timeout...\n");
-+
-+	writel(CON_FIFO_FLUSH | CON_NFI_RST, regs + NFI_CON);
-+	writew(STAR_DE, regs + NFI_STRDATA);
-+
-+	return ret;
-+}
-+
-+static void bad_mark_swap(struct nfi *nfi, u8 *buf, u8 *fdm)
-+{
-+	struct nfi_base *nb = nfi_to_base(nfi);
-+	u32 start_sector = div_down(nb->col, nfi->sector_size);
-+	u32 data_mark_pos;
-+	u8 temp;
-+
-+	/* raw access, no need to do swap. */
-+	if (!nb->ecc_en)
-+		return;
-+
-+	if (!buf || !fdm)
-+		return;
-+
-+	if (nb->bad_mark_ctrl.sector < start_sector ||
-+	    nb->bad_mark_ctrl.sector > start_sector + nb->rw_sectors)
-+		return;
-+
-+	data_mark_pos = nb->bad_mark_ctrl.position +
-+			(nb->bad_mark_ctrl.sector - start_sector) *
-+			nfi->sector_size;
-+
-+	temp = *fdm;
-+	*fdm = *(buf + data_mark_pos);
-+	*(buf + data_mark_pos) = temp;
-+}
-+
-+static u8 *fdm_shift(struct nfi *nfi, u8 *fdm, int sector)
-+{
-+	struct nfi_base *nb = nfi_to_base(nfi);
-+	u8 *pos;
-+
-+	if (!fdm)
-+		return NULL;
-+
-+	/* map the sector's FDM data to free oob:
-+	 * the beginning of the oob area stores the FDM data of bad mark sectors
-+	 */
-+	if (sector < nb->bad_mark_ctrl.sector)
-+		pos = fdm + (sector + 1) * nfi->fdm_size;
-+	else if (sector == nb->bad_mark_ctrl.sector)
-+		pos = fdm;
-+	else
-+		pos = fdm + sector * nfi->fdm_size;
-+
-+	return pos;
-+
-+}
-+
-+static void set_bad_mark_ctrl(struct nfi_base *nb)
-+{
-+	int temp, page_size = nb->format.page_size;
-+
-+	nb->bad_mark_ctrl.bad_mark_swap = bad_mark_swap;
-+	nb->bad_mark_ctrl.fdm_shift = fdm_shift;
-+
-+	temp = nb->nfi.sector_size + nb->nfi.sector_spare_size;
-+	nb->bad_mark_ctrl.sector = div_down(page_size, temp);
-+	nb->bad_mark_ctrl.position = reminder(page_size, temp);
-+}
-+
-+/* NOTE: check if page_size valid future */
-+static int setup_format(struct nfi_base *nb, int spare_idx)
-+{
-+	struct nfi *nfi = &nb->nfi;
-+	u32 page_size = nb->format.page_size;
-+	u32 val;
-+
-+	switch (page_size) {
-+	case 512:
-+		val = PAGEFMT_512_2K | PAGEFMT_SEC_SEL_512;
-+		break;
-+
-+	case KB(2):
-+		if (nfi->sector_size == 512)
-+			val = PAGEFMT_2K_4K | PAGEFMT_SEC_SEL_512;
-+		else
-+			val = PAGEFMT_512_2K;
-+
-+		break;
-+
-+	case KB(4):
-+		if (nfi->sector_size == 512)
-+			val = PAGEFMT_4K_8K | PAGEFMT_SEC_SEL_512;
-+		else
-+			val = PAGEFMT_2K_4K;
-+
-+		break;
-+
-+	case KB(8):
-+		if (nfi->sector_size == 512)
-+			val = PAGEFMT_8K_16K | PAGEFMT_SEC_SEL_512;
-+		else
-+			val = PAGEFMT_4K_8K;
-+
-+		break;
-+
-+	case KB(16):
-+		val = PAGEFMT_8K_16K;
-+		break;
-+
-+	default:
-+		pr_info("invalid page len: %d\n", page_size);
-+		return -EINVAL;
-+	}
-+
-+	val |= spare_idx << PAGEFMT_SPARE_SHIFT;
-+	val |= nfi->fdm_size << PAGEFMT_FDM_SHIFT;
-+	val |= nfi->fdm_ecc_size << PAGEFMT_FDM_ECC_SHIFT;
-+	writel(val, nb->res.nfi_regs + NFI_PAGEFMT);
-+
-+	if (nb->custom_sector_en) {
-+		val = nfi->sector_spare_size + nfi->sector_size;
-+		val |= SECCUS_SIZE_EN;
-+		writel(val, nb->res.nfi_regs + NFI_SECCUS_SIZE);
-+	}
-+
-+	return 0;
-+}
-+
-+static int adjust_spare(struct nfi_base *nb, int *spare)
-+{
-+	int multi = nb->nfi.sector_size == 512 ? 1 : 2;
-+	int i, count = nb->caps->spare_size_num;
-+
-+	if (*spare >= nb->caps->spare_size[count - 1] * multi) {
-+		*spare = nb->caps->spare_size[count - 1] * multi;
-+		return count - 1;
-+	}
-+
-+	if (*spare < nb->caps->spare_size[0] * multi)
-+		return -EINVAL;
-+
-+	for (i = 1; i < count; i++) {
-+		if (*spare < nb->caps->spare_size[i] * multi) {
-+			*spare = nb->caps->spare_size[i - 1] * multi;
-+			return i - 1;
-+		}
-+	}
-+
-+	return -EINVAL;
-+}
-+
-+static int nfi_set_format(struct nfi *nfi, struct nfi_format *format)
-+{
-+	struct nfi_base *nb = nfi_to_base(nfi);
-+	struct nfiecc *ecc = nb->ecc;
-+	int ecc_strength = format->ecc_req;
-+	int min_fdm, min_ecc, max_ecc;
-+	u32 temp, page_sectors;
-+	int spare_idx = 0;
-+
-+	if (!nb->buf) {
-+#if NANDX_BULK_IO_USE_DRAM
-+		nb->buf = NANDX_NFI_BUF_ADDR;
-+#else
-+		nb->buf = mem_alloc(1, format->page_size + format->spare_size);
-+#endif
-+		if (!nb->buf)
-+			return -ENOMEM;
-+	}
-+
-+	nb->format = *format;
-+
-+	/* ToBeFixed: for spi nand, now sector size is 512,
-+	 * it should be same with slc.
-+	 */
-+	nfi->sector_size = 512;
-+	/* format->ecc_req is the requirement per 1KB */
-+	ecc_strength >>= 1;
-+
-+	page_sectors = div_down(format->page_size, nfi->sector_size);
-+	nfi->sector_spare_size = div_down(format->spare_size, page_sectors);
-+
-+	if (!nb->custom_sector_en) {
-+		spare_idx = adjust_spare(nb, &nfi->sector_spare_size);
-+		if (spare_idx < 0)
-+			return -EINVAL;
-+	}
-+
-+	/* calculate ecc strength and fdm size */
-+	temp = (nfi->sector_spare_size - nb->caps->max_fdm_size) * 8;
-+	min_ecc = div_down(temp, nb->caps->ecc_parity_bits);
-+	min_ecc = ecc->adjust_strength(ecc, min_ecc);
-+	if (min_ecc < 0)
-+		return -EINVAL;
-+
-+	temp = div_up(nb->res.min_oob_req, page_sectors);
-+	temp = (nfi->sector_spare_size - temp) * 8;
-+	max_ecc = div_down(temp, nb->caps->ecc_parity_bits);
-+	max_ecc = ecc->adjust_strength(ecc, max_ecc);
-+	if (max_ecc < 0)
-+		return -EINVAL;
-+
-+	temp = div_up(temp * nb->caps->ecc_parity_bits, 8);
-+	temp = nfi->sector_spare_size - temp;
-+	min_fdm = min_t(u32, temp, (u32)nb->caps->max_fdm_size);
-+
-+	if (ecc_strength > max_ecc) {
-+		pr_info("required ecc strength %d, max supported %d\n",
-+			ecc_strength, max_ecc);
-+		nfi->ecc_strength = max_ecc;
-+		nfi->fdm_size = min_fdm;
-+	} else if (format->ecc_req < min_ecc) {
-+		nfi->ecc_strength = min_ecc;
-+		nfi->fdm_size = nb->caps->max_fdm_size;
-+	} else {
-+		ecc_strength = ecc->adjust_strength(ecc, ecc_strength);
-+		if (ecc_strength < 0)
-+			return -EINVAL;
-+
-+		nfi->ecc_strength = ecc_strength;
-+		temp = div_up(ecc_strength * nb->caps->ecc_parity_bits, 8);
-+		nfi->fdm_size = nfi->sector_spare_size - temp;
-+	}
-+
-+	nb->page_sectors = div_down(format->page_size, nfi->sector_size);
-+
-+	/* some IC has fixed fdm_ecc_size, if not assigend, set to fdm_size */
-+	nfi->fdm_ecc_size = nb->caps->fdm_ecc_size ? : nfi->fdm_size;
-+
-+	nfi->ecc_parity_size = div_up(nfi->ecc_strength *
-+				      nb->caps->ecc_parity_bits,
-+				      8);
-+	set_bad_mark_ctrl(nb);
-+
-+	pr_debug("sector_size: %d\n", nfi->sector_size);
-+	pr_debug("sector_spare_size: %d\n", nfi->sector_spare_size);
-+	pr_debug("fdm_size: %d\n", nfi->fdm_size);
-+	pr_debug("fdm_ecc_size: %d\n", nfi->fdm_ecc_size);
-+	pr_debug("ecc_strength: %d\n", nfi->ecc_strength);
-+	pr_debug("ecc_parity_size: %d\n", nfi->ecc_parity_size);
-+
-+	return setup_format(nb, spare_idx);
-+}
-+
-+static int nfi_ctrl(struct nfi *nfi, int cmd, void *args)
-+{
-+	struct nfi_base *nb = nfi_to_base(nfi);
-+	int ret = 0;
-+
-+	switch (cmd) {
-+	case NFI_CTRL_DMA:
-+		nb->dma_en = *(bool *)args;
-+		break;
-+
-+	case NFI_CTRL_AUTOFORMAT:
-+		nb->auto_format = *(bool *)args;
-+		break;
-+
-+	case NFI_CTRL_NFI_IRQ:
-+		nb->nfi_irq_en = *(bool *)args;
-+		break;
-+
-+	case NFI_CTRL_PAGE_IRQ:
-+		nb->page_irq_en = *(bool *)args;
-+		break;
-+
-+	case NFI_CTRL_BAD_MARK_SWAP:
-+		nb->bad_mark_swap_en = *(bool *)args;
-+		break;
-+
-+	case NFI_CTRL_ECC:
-+		nb->ecc_en = *(bool *)args;
-+		break;
-+
-+	case NFI_CTRL_ECC_MODE:
-+		nb->ecc_mode = *(enum nfiecc_mode *)args;
-+		break;
-+
-+	case NFI_CTRL_ECC_CLOCK:
-+		/* NOTE: it seems that there's nothing need to do
-+		 * if new IC need, just add tht logic
-+		 */
-+		nb->ecc_clk_en = *(bool *)args;
-+		break;
-+
-+	case NFI_CTRL_ECC_IRQ:
-+		nb->ecc_irq_en = *(bool *)args;
-+		break;
-+
-+	case NFI_CTRL_ECC_DECODE_MODE:
-+		nb->ecc_deccon = *(enum nfiecc_deccon *)args;
-+		break;
-+
-+	default:
-+		pr_info("invalid arguments.\n");
-+		ret = -EOPNOTSUPP;
-+		break;
-+	}
-+
-+	pr_debug("%s: set cmd(%d) to %d\n", __func__, cmd, *(int *)args);
-+	return ret;
-+}
-+
-+static int nfi_send_cmd(struct nfi *nfi, short cmd)
-+{
-+	struct nfi_base *nb = nfi_to_base(nfi);
-+	void *regs = nb->res.nfi_regs;
-+	int ret;
-+	u32 val;
-+
-+	pr_debug("%s: cmd 0x%x\n", __func__, cmd);
-+
-+	if (cmd < 0)
-+		return -EINVAL;
-+
-+	set_op_mode(regs, nb->op_mode);
-+
-+	writel(cmd, regs + NFI_CMD);
-+
-+	ret = readl_poll_timeout_atomic(regs + NFI_STA,
-+					val, !(val & STA_CMD),
-+					5, NFI_TIMEOUT);
-+	if (ret)
-+		pr_info("send cmd 0x%x timeout\n", cmd);
-+
-+	return ret;
-+}
-+
-+static int nfi_send_addr(struct nfi *nfi, int col, int row,
-+			 int col_cycle, int row_cycle)
-+{
-+	struct nfi_base *nb = nfi_to_base(nfi);
-+	void *regs = nb->res.nfi_regs;
-+	int ret;
-+	u32 val;
-+
-+	pr_debug("%s: col 0x%x, row 0x%x, col_cycle 0x%x, row_cycle 0x%x\n",
-+		 __func__, col, row, col_cycle, row_cycle);
-+
-+	nb->col = col;
-+	nb->row = row;
-+
-+	writel(col, regs + NFI_COLADDR);
-+	writel(row, regs + NFI_ROWADDR);
-+	writel(col_cycle | (row_cycle << ROW_SHIFT), regs + NFI_ADDRNOB);
-+
-+	ret = readl_poll_timeout_atomic(regs + NFI_STA,
-+					val, !(val & STA_ADDR),
-+					5, NFI_TIMEOUT);
-+	if (ret)
-+		pr_info("send address timeout\n");
-+
-+	return ret;
-+}
-+
-+static int nfi_trigger(struct nfi *nfi)
-+{
-+	/* Nothing need to do. */
-+	return 0;
-+}
-+
-+static inline int wait_io_ready(void *regs)
-+{
-+	u32 val;
-+	int ret;
-+
-+	ret = readl_poll_timeout_atomic(regs + NFI_PIO_DIRDY,
-+					val, val & PIO_DI_RDY,
-+					2, NFI_TIMEOUT);
-+	if (ret)
-+		pr_info("wait io ready timeout\n");
-+
-+	return ret;
-+}
-+
-+static int wait_ready_irq(struct nfi_base *nb, u32 timeout)
-+{
-+	void *regs = nb->res.nfi_regs;
-+	int ret;
-+	u32 val;
-+
-+	writel(0xf1, regs + NFI_CNRNB);
-+	nandx_event_init(nb->done);
-+
-+	writel(INTR_BUSY_RETURN_EN, (void *)(regs + NFI_INTR_EN));
-+
-+	/**
-+	 * check if nand already bean ready,
-+	 * avoid issue that casued by missing irq-event.
-+	 */
-+	val = readl(regs + NFI_STA);
-+	if (val & STA_BUSY2READY) {
-+		readl(regs + NFI_INTR_STA);
-+		writel(0, (void *)(regs + NFI_INTR_EN));
-+		return 0;
-+	}
-+
-+	ret = nandx_event_wait_complete(nb->done, timeout);
-+
-+	writew(0, regs + NFI_CNRNB);
-+	return ret;
-+}
-+
-+static void wait_ready_twhr2(struct nfi_base *nb, u32 timeout)
-+{
-+	/* NOTE: this for tlc */
-+}
-+
-+static int wait_ready_poll(struct nfi_base *nb, u32 timeout)
-+{
-+	void *regs = nb->res.nfi_regs;
-+	int ret;
-+	u32 val;
-+
-+	writel(0x21, regs + NFI_CNRNB);
-+	ret = readl_poll_timeout_atomic(regs + NFI_STA, val,
-+					val & STA_BUSY2READY,
-+					2, timeout);
-+	writew(0, regs + NFI_CNRNB);
-+
-+	return ret;
-+}
-+
-+static int nfi_wait_ready(struct nfi *nfi, int type, u32 timeout)
-+{
-+	struct nfi_base *nb = nfi_to_base(nfi);
-+	int ret;
-+
-+	switch (type) {
-+	case NAND_WAIT_IRQ:
-+		if (nb->nfi_irq_en)
-+			ret = wait_ready_irq(nb, timeout);
-+		else
-+			ret = -EINVAL;
-+
-+		break;
-+
-+	case NAND_WAIT_POLLING:
-+		ret = wait_ready_poll(nb, timeout);
-+		break;
-+
-+	case NAND_WAIT_TWHR2:
-+		wait_ready_twhr2(nb, timeout);
-+		ret = 0;
-+		break;
-+
-+	default:
-+		ret = -EINVAL;
-+		break;
-+	}
-+
-+	if (ret)
-+		pr_info("%s: type 0x%x, timeout 0x%x\n",
-+		       __func__, type, timeout);
-+
-+	return ret;
-+}
-+
-+static int enable_ecc_decode(struct nfi_base *nb, int sectors)
-+{
-+	struct nfi *nfi = &nb->nfi;
-+	struct nfiecc *ecc = nb->ecc;
-+
-+	ecc->config.op = ECC_DECODE;
-+	ecc->config.mode = nb->ecc_mode;
-+	ecc->config.deccon = nb->ecc_deccon;
-+	ecc->config.sectors = sectors;
-+	ecc->config.len = nfi->sector_size + nfi->fdm_ecc_size;
-+	ecc->config.strength = nfi->ecc_strength;
-+
-+	return ecc->enable(ecc);
-+}
-+
-+static int enable_ecc_encode(struct nfi_base *nb)
-+{
-+	struct nfiecc *ecc = nb->ecc;
-+	struct nfi *nfi = &nb->nfi;
-+
-+	ecc->config.op = ECC_ENCODE;
-+	ecc->config.mode = nb->ecc_mode;
-+	ecc->config.len = nfi->sector_size + nfi->fdm_ecc_size;
-+	ecc->config.strength = nfi->ecc_strength;
-+
-+	return ecc->enable(ecc);
-+}
-+
-+static void read_fdm(struct nfi_base *nb, u8 *fdm, int start_sector,
-+		     int sectors)
-+{
-+	void *regs = nb->res.nfi_regs;
-+	int j, i = start_sector;
-+	u32 vall, valm;
-+	u8 *buf = fdm;
-+
-+	for (; i < start_sector + sectors; i++) {
-+		if (nb->bad_mark_swap_en)
-+			buf = nb->bad_mark_ctrl.fdm_shift(&nb->nfi, fdm, i);
-+
-+		vall = readl(regs + NFI_FDML(i));
-+		valm = readl(regs + NFI_FDMM(i));
-+
-+		for (j = 0; j < nb->nfi.fdm_size; j++)
-+			*buf++ = (j >= 4 ? valm : vall) >> ((j & 3) << 3);
-+	}
-+}
-+
-+static void write_fdm(struct nfi_base *nb, u8 *fdm)
-+{
-+	struct nfi *nfi = &nb->nfi;
-+	void *regs = nb->res.nfi_regs;
-+	u32 vall, valm;
-+	int i, j;
-+	u8 *buf = fdm;
-+
-+	for (i = 0; i < nb->page_sectors; i++) {
-+		if (nb->bad_mark_swap_en)
-+			buf = nb->bad_mark_ctrl.fdm_shift(nfi, fdm, i);
-+
-+		vall = 0;
-+		for (j = 0; j < 4; j++)
-+			vall |= (j < nfi->fdm_size ? *buf++ : 0xff) << (j * 8);
-+		writel(vall, regs + NFI_FDML(i));
-+
-+		valm = 0;
-+		for (j = 0; j < 4; j++)
-+			valm |= (j < nfi->fdm_size ? *buf++ : 0xff) << (j * 8);
-+		writel(valm, regs + NFI_FDMM(i));
-+	}
-+}
-+
-+/* NOTE: pio not use auto format */
-+static int pio_rx_data(struct nfi_base *nb, u8 *data, u8 *fdm,
-+		       int sectors)
-+{
-+	struct nfiecc_status ecc_status;
-+	struct nfi *nfi = &nb->nfi;
-+	void *regs = nb->res.nfi_regs;
-+	u32 val, bitflips = 0;
-+	int len, ret, i;
-+	u8 *buf;
-+
-+	val = readl(regs + NFI_CNFG) | CNFG_BYTE_RW;
-+	writel(val, regs + NFI_CNFG);
-+
-+	len = nfi->sector_size + nfi->sector_spare_size;
-+	len *= sectors;
-+
-+	for (i = 0; i < len; i++) {
-+		ret = wait_io_ready(regs);
-+		if (ret)
-+			return ret;
-+
-+		nb->buf[i] = readb(regs + NFI_DATAR);
-+	}
-+
-+	/* TODO: do error handle for autoformat setting of pio */
-+	if (nb->ecc_en) {
-+		for (i = 0; i < sectors; i++) {
-+			buf = nb->buf + i * (nfi->sector_size +
-+					     nfi->sector_spare_size);
-+			ret = nb->ecc->correct_data(nb->ecc, &ecc_status,
-+						    buf, i);
-+			if (data)
-+				memcpy(data + i * nfi->sector_size,
-+				       buf, nfi->sector_size);
-+			if (fdm)
-+				memcpy(fdm + i * nfi->fdm_size,
-+				       buf + nfi->sector_size, nfi->fdm_size);
-+			if (ret) {
-+				ret = nb->ecc->decode_status(nb->ecc, i, 1);
-+				if (ret < 0)
-+					return ret;
-+
-+				bitflips = max_t(int, (int)bitflips, ret);
-+			}
-+		}
-+
-+		return bitflips;
-+	}
-+
-+	/* raw read, only data not null, and its length should be $len */
-+	if (data)
-+		memcpy(data, nb->buf, len);
-+
-+	return 0;
-+}
-+
-+static int pio_tx_data(struct nfi_base *nb, u8 *data, u8 *fdm,
-+		       int sectors)
-+{
-+	struct nfi *nfi = &nb->nfi;
-+	void *regs = nb->res.nfi_regs;
-+	u32 i, val;
-+	int len, ret;
-+
-+	val = readw(regs + NFI_CNFG) | CNFG_BYTE_RW;
-+	writew(val, regs + NFI_CNFG);
-+
-+	len = nb->ecc_en ? nfi->sector_size :
-+	      nfi->sector_size + nfi->sector_spare_size;
-+	len *= sectors;
-+
-+	/* data shouldn't null,
-+	 * and if ecc enable ,fdm been written in prepare process
-+	 */
-+	for (i = 0; i < len; i++) {
-+		ret = wait_io_ready(regs);
-+		if (ret)
-+			return ret;
-+		writeb(data[i], regs + NFI_DATAW);
-+	}
-+
-+	return 0;
-+}
-+
-+static bool is_page_empty(struct nfi_base *nb, u8 *data, u8 *fdm,
-+			  int sectors)
-+{
-+	u32 empty = readl(nb->res.nfi_regs + NFI_STA) & STA_EMP_PAGE;
-+
-+	if (empty) {
-+		pr_info("empty page!\n");
-+		return true;
-+	}
-+
-+	return false;
-+}
-+
-+static int rw_prepare(struct nfi_base *nb, int sectors, u8 *data,
-+		      u8 *fdm, bool read)
-+{
-+	void *regs = nb->res.nfi_regs;
-+	u32 len = nb->nfi.sector_size * sectors;
-+	bool irq_en = nb->dma_en && nb->nfi_irq_en;
-+	void *dma_addr;
-+	u32 val;
-+	int ret;
-+
-+	nb->rw_sectors = sectors;
-+
-+	if (irq_en) {
-+		nandx_event_init(nb->done);
-+		writel(INTR_AHB_DONE_EN, regs + NFI_INTR_EN);
-+	}
-+
-+	val = readw(regs + NFI_CNFG);
-+	if (read)
-+		val |= CNFG_READ_EN;
-+	else
-+		val &= ~CNFG_READ_EN;
-+
-+	/* as design, now, auto format enabled when ecc enabled */
-+	if (nb->ecc_en) {
-+		val |= CNFG_HW_ECC_EN | CNFG_AUTO_FMT_EN;
-+
-+		if (read)
-+			ret = enable_ecc_decode(nb, sectors);
-+		else
-+			ret = enable_ecc_encode(nb);
-+
-+		if (ret) {
-+			pr_info("%s: ecc enable %s fail!\n", __func__,
-+			       read ? "decode" : "encode");
-+			return ret;
-+		}
-+	} else {
-+		val &= ~(CNFG_HW_ECC_EN | CNFG_AUTO_FMT_EN);
-+	}
-+
-+	if (!read && nb->bad_mark_swap_en)
-+		nb->bad_mark_ctrl.bad_mark_swap(&nb->nfi, data, fdm);
-+
-+	if (!nb->ecc_en && read)
-+		len += sectors * nb->nfi.sector_spare_size;
-+
-+	if (nb->dma_en) {
-+		val |= CNFG_DMA_BURST_EN | CNFG_AHB;
-+
-+		if (read) {
-+			dma_addr = (void *)(unsigned long)nandx_dma_map(
-+						nb->res.dev, nb->buf,
-+						(u64)len, NDMA_FROM_DEV);
-+		} else {
-+			memcpy(nb->buf, data, len);
-+			dma_addr = (void *)(unsigned long)nandx_dma_map(
-+						nb->res.dev, nb->buf,
-+						(u64)len, NDMA_TO_DEV);
-+		}
-+
-+		writel((unsigned long)dma_addr, (void *)regs + NFI_STRADDR);
-+
-+		nb->access_len = len;
-+		nb->dma_addr = dma_addr;
-+	}
-+
-+	if (nb->ecc_en && !read && fdm)
-+		write_fdm(nb, fdm);
-+
-+	writew(val, regs + NFI_CNFG);
-+	/* setup R/W sector number */
-+	writel(sectors << CON_SEC_SHIFT, regs + NFI_CON);
-+
-+	return 0;
-+}
-+
-+static void rw_trigger(struct nfi_base *nb, bool read)
-+{
-+	void *regs = nb->res.nfi_regs;
-+	u32 val;
-+
-+	val = read ? CON_BRD : CON_BWR;
-+	val |= readl(regs + NFI_CON);
-+	writel(val, regs + NFI_CON);
-+
-+	writel(STAR_EN, regs + NFI_STRDATA);
-+}
-+
-+static int rw_wait_done(struct nfi_base *nb, int sectors, bool read)
-+{
-+	void *regs = nb->res.nfi_regs;
-+	bool irq_en = nb->dma_en && nb->nfi_irq_en;
-+	int ret;
-+	u32 val;
-+
-+	if (irq_en) {
-+		ret = nandx_event_wait_complete(nb->done, NFI_TIMEOUT);
-+		if (!ret) {
-+			writew(0, regs + NFI_INTR_EN);
-+			return ret;
-+		}
-+	}
-+
-+	if (read) {
-+		ret = readl_poll_timeout_atomic(regs + NFI_BYTELEN, val,
-+						ADDRCNTR_SEC(val) >=
-+						(u32)sectors,
-+						2, NFI_TIMEOUT);
-+		/* HW issue: if not wait ahb done, need polling bus busy */
-+		if (!ret && !irq_en)
-+			ret = readl_poll_timeout_atomic(regs + NFI_MASTER_STA,
-+							val,
-+							!(val &
-+							  MASTER_BUS_BUSY),
-+							2, NFI_TIMEOUT);
-+	} else {
-+		ret = readl_poll_timeout_atomic(regs + NFI_ADDRCNTR, val,
-+						ADDRCNTR_SEC(val) >=
-+						(u32)sectors,
-+						2, NFI_TIMEOUT);
-+	}
-+
-+	if (ret) {
-+		pr_info("do page %s timeout\n", read ? "read" : "write");
-+		return ret;
-+	}
-+
-+	if (read && nb->ecc_en) {
-+		ret = nb->ecc->wait_done(nb->ecc);
-+		if (ret)
-+			return ret;
-+
-+		return nb->ecc->decode_status(nb->ecc, 0, sectors);
-+	}
-+
-+	return 0;
-+}
-+
-+static int rw_data(struct nfi_base *nb, u8 *data, u8 *fdm, int sectors,
-+		   bool read)
-+{
-+	if (read && nb->dma_en && nb->ecc_en && fdm)
-+		read_fdm(nb, fdm, 0, sectors);
-+
-+	if (!nb->dma_en) {
-+		if (read)
-+			return pio_rx_data(nb, data, fdm, sectors);
-+
-+		return pio_tx_data(nb, data, fdm, sectors);
-+	}
-+
-+	return 0;
-+}
-+
-+static void rw_complete(struct nfi_base *nb, u8 *data, u8 *fdm,
-+			bool read)
-+{
-+	int data_len = 0;
-+	bool is_empty;
-+
-+	if (nb->dma_en) {
-+		if (read) {
-+			nandx_dma_unmap(nb->res.dev, nb->buf, nb->dma_addr,
-+					(u64)nb->access_len, NDMA_FROM_DEV);
-+
-+			if (data) {
-+				data_len = nb->rw_sectors * nb->nfi.sector_size;
-+				memcpy(data, nb->buf, data_len);
-+			}
-+
-+			if (fdm)
-+				memcpy(fdm, nb->buf + data_len,
-+				       nb->access_len - data_len);
-+
-+			if (nb->read_status == -ENANDREAD) {
-+				is_empty = nb->is_page_empty(nb, data, fdm,
-+							nb->rw_sectors);
-+				if (is_empty)
-+					nb->read_status = 0;
-+			}
-+		} else {
-+			nandx_dma_unmap(nb->res.dev, nb->buf, nb->dma_addr,
-+					(u64)nb->access_len, NDMA_TO_DEV);
-+		}
-+	}
-+
-+	/* whether it's reading or writing, we all check if nee swap
-+	 * for write, we need to restore data
-+	 */
-+	if (nb->bad_mark_swap_en)
-+		nb->bad_mark_ctrl.bad_mark_swap(&nb->nfi, data, fdm);
-+
-+	if (nb->ecc_en)
-+		nb->ecc->disable(nb->ecc);
-+
-+	writel(0, nb->res.nfi_regs + NFI_CNFG);
-+	writel(0, nb->res.nfi_regs + NFI_CON);
-+}
-+
-+static int nfi_read_sectors(struct nfi *nfi, u8 *data, u8 *fdm,
-+			    int sectors)
-+{
-+	struct nfi_base *nb = nfi_to_base(nfi);
-+	int bitflips = 0, ret;
-+
-+	pr_debug("%s: read page#%d\n", __func__, nb->row);
-+	pr_debug("%s: data address 0x%x, fdm address 0x%x, sectors 0x%x\n",
-+		 __func__, (u32)((unsigned long)data),
-+		 (u32)((unsigned long)fdm), sectors);
-+
-+	nb->read_status = 0;
-+
-+	ret = nb->rw_prepare(nb, sectors, data, fdm, true);
-+	if (ret)
-+		return ret;
-+
-+	nb->rw_trigger(nb, true);
-+
-+	if (nb->dma_en) {
-+		ret = nb->rw_wait_done(nb, sectors, true);
-+		if (ret > 0)
-+			bitflips = ret;
-+		else if (ret == -ENANDREAD)
-+			nb->read_status = -ENANDREAD;
-+		else if (ret < 0)
-+			goto complete;
-+
-+	}
-+
-+	ret = nb->rw_data(nb, data, fdm, sectors, true);
-+	if (ret > 0)
-+		ret = max_t(int, ret, bitflips);
-+
-+complete:
-+	nb->rw_complete(nb, data, fdm, true);
-+
-+	if (nb->read_status == -ENANDREAD)
-+		return -ENANDREAD;
-+
-+	return ret;
-+}
-+
-+int nfi_write_page(struct nfi *nfi, u8 *data, u8 *fdm)
-+{
-+	struct nfi_base *nb = nfi_to_base(nfi);
-+	u32 sectors = div_down(nb->format.page_size, nfi->sector_size);
-+	int ret;
-+
-+	pr_debug("%s: data address 0x%x, fdm address 0x%x\n",
-+		 __func__, (int)((unsigned long)data),
-+		 (int)((unsigned long)fdm));
-+
-+	ret = nb->rw_prepare(nb, sectors, data, fdm, false);
-+	if (ret)
-+		return ret;
-+
-+	nb->rw_trigger(nb, false);
-+
-+	ret = nb->rw_data(nb, data, fdm, sectors, false);
-+	if (ret)
-+		return ret;
-+
-+	ret = nb->rw_wait_done(nb, sectors, false);
-+
-+	nb->rw_complete(nb, data, fdm, false);
-+
-+	return ret;
-+}
-+
-+static int nfi_rw_bytes(struct nfi *nfi, u8 *data, int count, bool read)
-+{
-+	struct nfi_base *nb = nfi_to_base(nfi);
-+	void *regs = nb->res.nfi_regs;
-+	int i, ret;
-+	u32 val;
-+
-+	for (i = 0; i < count; i++) {
-+		val = readl(regs + NFI_STA) & NFI_FSM_MASK;
-+		if (val != NFI_FSM_CUSTDATA) {
-+			val = readw(regs + NFI_CNFG) | CNFG_BYTE_RW;
-+			if (read)
-+				val |= CNFG_READ_EN;
-+			writew(val, regs + NFI_CNFG);
-+
-+			val = div_up(count, nfi->sector_size);
-+			val = (val << CON_SEC_SHIFT) | CON_BRD | CON_BWR;
-+			writel(val, regs + NFI_CON);
-+
-+			writew(STAR_EN, regs + NFI_STRDATA);
-+		}
-+
-+		ret = wait_io_ready(regs);
-+		if (ret)
-+			return ret;
-+
-+		if (read)
-+			data[i] = readb(regs + NFI_DATAR);
-+		else
-+			writeb(data[i], regs + NFI_DATAW);
-+	}
-+
-+	writel(0, nb->res.nfi_regs + NFI_CNFG);
-+
-+	return 0;
-+}
-+
-+static int nfi_read_bytes(struct nfi *nfi, u8 *data, int count)
-+{
-+	return nfi_rw_bytes(nfi, data, count, true);
-+}
-+
-+static int nfi_write_bytes(struct nfi *nfi, u8 *data, int count)
-+{
-+	return nfi_rw_bytes(nfi, data, count, false);
-+}
-+
-+/* As register map says, only when flash macro is idle,
-+ * sw reset or nand interface change can be issued
-+ */
-+static inline int wait_flash_macro_idle(void *regs)
-+{
-+	u32 val;
-+
-+	return readl_poll_timeout_atomic(regs + NFI_STA, val,
-+					 val & FLASH_MACRO_IDLE, 2,
-+					 NFI_TIMEOUT);
-+}
-+
-+#define ACCTIMING(tpoecs, tprecs, tc2r, tw2r, twh, twst, trlt) \
-+	((tpoecs) << 28 | (tprecs) << 22 | (tc2r) << 16 | \
-+	 (tw2r) << 12 | (twh) << 8 | (twst) << 4 | (trlt))
-+
-+static int nfi_set_sdr_timing(struct nfi *nfi, void *timing, u8 type)
-+{
-+	struct nand_sdr_timing *sdr = (struct nand_sdr_timing *) timing;
-+	struct nfi_base *nb = nfi_to_base(nfi);
-+	void *regs = nb->res.nfi_regs;
-+	u32 tpoecs, tprecs, tc2r, tw2r, twh, twst, trlt, tstrobe;
-+	u32 rate, val;
-+	int ret;
-+
-+	ret = wait_flash_macro_idle(regs);
-+	if (ret)
-+		return ret;
-+
-+	/* turn clock rate into KHZ */
-+	rate = nb->res.clock_1x / 1000;
-+
-+	tpoecs = max_t(u16, sdr->tALH, sdr->tCLH);
-+	tpoecs = div_up(tpoecs * rate, 1000000);
-+	tpoecs &= 0xf;
-+
-+	tprecs = max_t(u16, sdr->tCLS, sdr->tALS);
-+	tprecs = div_up(tprecs * rate, 1000000);
-+	tprecs &= 0x3f;
-+
-+	/* tc2r is in unit of 2T */
-+	tc2r = div_up(sdr->tCR * rate, 1000000);
-+	tc2r = div_down(tc2r, 2);
-+	tc2r &= 0x3f;
-+
-+	tw2r = div_up(sdr->tWHR * rate, 1000000);
-+	tw2r = div_down(tw2r, 2);
-+	tw2r &= 0xf;
-+
-+	twh = max_t(u16, sdr->tREH, sdr->tWH);
-+	twh = div_up(twh * rate, 1000000) - 1;
-+	twh &= 0xf;
-+
-+	twst = div_up(sdr->tWP * rate, 1000000) - 1;
-+	twst &= 0xf;
-+
-+	trlt = div_up(sdr->tRP * rate, 1000000) - 1;
-+	trlt &= 0xf;
-+
-+	/* If tREA is bigger than tRP, setup strobe sel here */
-+	if ((trlt + 1) * 1000000 / rate < sdr->tREA) {
-+		tstrobe = sdr->tREA - (trlt + 1) * 1000000 / rate;
-+		tstrobe = div_up(tstrobe * rate, 1000000);
-+		val = readl(regs + NFI_DEBUG_CON1);
-+		val &= ~STROBE_MASK;
-+		val |= tstrobe << STROBE_SHIFT;
-+		writel(val, regs + NFI_DEBUG_CON1);
-+	}
-+
-+	/*
-+	 * ACCON: access timing control register
-+	 * -------------------------------------
-+	 * 31:28: tpoecs, minimum required time for CS post pulling down after
-+	 *        accessing the device
-+	 * 27:22: tprecs, minimum required time for CS pre pulling down before
-+	 *        accessing the device
-+	 * 21:16: tc2r, minimum required time from NCEB low to NREB low
-+	 * 15:12: tw2r, minimum required time from NWEB high to NREB low.
-+	 * 11:08: twh, write enable hold time
-+	 * 07:04: twst, write wait states
-+	 * 03:00: trlt, read wait states
-+	 */
-+	val = ACCTIMING(tpoecs, tprecs, tc2r, tw2r, twh, twst, trlt);
-+	pr_info("acctiming: 0x%x\n", val);
-+	writel(val, regs + NFI_ACCCON);
-+
-+	/* set NAND type */
-+	writel(NAND_TYPE_ASYNC, regs + NFI_NAND_TYPE_CNFG);
-+
-+	return ret;
-+}
-+
-+static int nfi_set_timing(struct nfi *nfi, void *timing, int type)
-+{
-+	switch (type) {
-+	case NAND_TIMING_SDR:
-+		return nfi_set_sdr_timing(nfi, timing, type);
-+
-+	/* NOTE: for mlc/tlc */
-+	case NAND_TIMING_SYNC_DDR:
-+	case NAND_TIMING_TOGGLE_DDR:
-+	case NAND_TIMING_NVDDR2:
-+	default:
-+		return -EINVAL;
-+	}
-+
-+	return 0;
-+}
-+
-+static void set_nfi_funcs(struct nfi *nfi)
-+{
-+	nfi->select_chip = nfi_select_chip;
-+	nfi->set_format = nfi_set_format;
-+	nfi->nfi_ctrl = nfi_ctrl;
-+	nfi->set_timing = nfi_set_timing;
-+
-+	nfi->reset = nfi_reset;
-+	nfi->send_cmd = nfi_send_cmd;
-+	nfi->send_addr = nfi_send_addr;
-+	nfi->trigger = nfi_trigger;
-+
-+	nfi->write_page = nfi_write_page;
-+	nfi->write_bytes = nfi_write_bytes;
-+	nfi->read_sectors = nfi_read_sectors;
-+	nfi->read_bytes = nfi_read_bytes;
-+
-+	nfi->wait_ready = nfi_wait_ready;
-+
-+	nfi->enable_randomizer = nfi_enable_randomizer;
-+	nfi->disable_randomizer = nfi_disable_randomizer;
-+}
-+
-+static struct nfi_caps nfi_caps_mt7622 = {
-+	.max_fdm_size = 8,
-+	.fdm_ecc_size = 1,
-+	.ecc_parity_bits = 13,
-+	.spare_size = spare_size_mt7622,
-+	.spare_size_num = 4,
-+};
-+
-+static struct nfi_caps *nfi_get_match_data(enum mtk_ic_version ic)
-+{
-+	/* NOTE: add other IC's data */
-+	return &nfi_caps_mt7622;
-+}
-+
-+static void set_nfi_base_params(struct nfi_base *nb)
-+{
-+	nb->ecc_en = false;
-+	nb->dma_en = false;
-+	nb->nfi_irq_en = false;
-+	nb->ecc_irq_en = false;
-+	nb->page_irq_en = false;
-+	nb->ecc_clk_en = false;
-+	nb->randomize_en = false;
-+	nb->custom_sector_en = false;
-+	nb->bad_mark_swap_en = false;
-+
-+	nb->op_mode = CNFG_CUSTOM_MODE;
-+	nb->ecc_deccon = ECC_DEC_CORRECT;
-+	nb->ecc_mode = ECC_NFI_MODE;
-+
-+	nb->done = nandx_event_create();
-+	nb->caps = nfi_get_match_data(nb->res.ic_ver);
-+
-+	nb->set_op_mode = set_op_mode;
-+	nb->is_page_empty = is_page_empty;
-+
-+	nb->rw_prepare = rw_prepare;
-+	nb->rw_trigger = rw_trigger;
-+	nb->rw_wait_done = rw_wait_done;
-+	nb->rw_data = rw_data;
-+	nb->rw_complete = rw_complete;
-+}
-+
-+struct nfi *__weak nfi_extend_init(struct nfi_base *nb)
-+{
-+	return &nb->nfi;
-+}
-+
-+void __weak nfi_extend_exit(struct nfi_base *nb)
-+{
-+	mem_free(nb);
-+}
-+
-+struct nfi *nfi_init(struct nfi_resource *res)
-+{
-+	struct nfiecc_resource ecc_res;
-+	struct nfi_base *nb;
-+	struct nfiecc *ecc;
-+	struct nfi *nfi;
-+	int ret;
-+
-+	nb = mem_alloc(1, sizeof(struct nfi_base));
-+	if (!nb) {
-+		pr_info("nfi alloc memory fail @%s.\n", __func__);
-+		return NULL;
-+	}
-+
-+	nb->res = *res;
-+
-+	ret = nandx_irq_register(res->dev, res->nfi_irq_id, nfi_irq_handler,
-+				 "mtk_nand", nb);
-+	if (ret) {
-+		pr_info("nfi irq register failed!\n");
-+		goto error;
-+	}
-+
-+	/* fill ecc paras and init ecc */
-+	ecc_res.ic_ver = nb->res.ic_ver;
-+	ecc_res.dev = nb->res.dev;
-+	ecc_res.irq_id = nb->res.ecc_irq_id;
-+	ecc_res.regs = nb->res.ecc_regs;
-+	ecc = nfiecc_init(&ecc_res);
-+	if (!ecc) {
-+		pr_info("nfiecc init fail.\n");
-+		return NULL;
-+	}
-+
-+	nb->ecc = ecc;
-+
-+	set_nfi_base_params(nb);
-+	set_nfi_funcs(&nb->nfi);
-+
-+	/* Assign a temp sector size for reading ID & para page.
-+	 * We may assign new value later.
-+	 */
-+	nb->nfi.sector_size = 512;
-+
-+	/* give a default timing, and as discuss
-+	 * this is the only thing what we need do for nfi init
-+	 * if need do more, then we can add a function
-+	 */
-+	writel(0x30C77FFF, nb->res.nfi_regs + NFI_ACCCON);
-+
-+	nfi = nfi_extend_init(nb);
-+	if (nfi)
-+		return nfi;
-+
-+error:
-+	mem_free(nb);
-+	return NULL;
-+}
-+
-+void nfi_exit(struct nfi *nfi)
-+{
-+	struct nfi_base *nb = nfi_to_base(nfi);
-+
-+	nandx_event_destroy(nb->done);
-+	nfiecc_exit(nb->ecc);
-+#if !NANDX_BULK_IO_USE_DRAM
-+	mem_free(nb->buf);
-+#endif
-+	nfi_extend_exit(nb);
-+}
-+
-diff --git a/drivers/mtd/nandx/core/nfi/nfi_base.h b/drivers/mtd/nandx/core/nfi/nfi_base.h
-new file mode 100644
-index 0000000000..ae894eaa31
---- /dev/null
-+++ b/drivers/mtd/nandx/core/nfi/nfi_base.h
-@@ -0,0 +1,95 @@
-+/*
-+ * Copyright (C) 2017 MediaTek Inc.
-+ * Licensed under either
-+ *     BSD Licence, (see NOTICE for more details)
-+ *     GNU General Public License, version 2.0, (see NOTICE for more details)
-+ */
-+
-+#ifndef __NFI_BASE_H__
-+#define __NFI_BASE_H__
-+
-+#define NFI_TIMEOUT             1000000
-+
-+enum randomizer_op {
-+	RAND_ENCODE,
-+	RAND_DECODE
-+};
-+
-+struct bad_mark_ctrl {
-+	void (*bad_mark_swap)(struct nfi *nfi, u8 *buf, u8 *fdm);
-+	u8 *(*fdm_shift)(struct nfi *nfi, u8 *fdm, int sector);
-+	u32 sector;
-+	u32 position;
-+};
-+
-+struct nfi_caps {
-+	u8 max_fdm_size;
-+	u8 fdm_ecc_size;
-+	u8 ecc_parity_bits;
-+	const int *spare_size;
-+	u32 spare_size_num;
-+};
-+
-+struct nfi_base {
-+	struct nfi nfi;
-+	struct nfi_resource res;
-+	struct nfiecc *ecc;
-+	struct nfi_format format;
-+	struct nfi_caps *caps;
-+	struct bad_mark_ctrl bad_mark_ctrl;
-+
-+	/* page_size + spare_size */
-+	u8 *buf;
-+
-+	/* used for spi nand */
-+	u8 cmd_mode;
-+	u32 op_mode;
-+
-+	int page_sectors;
-+
-+	void *done;
-+
-+	/* for read/write */
-+	int col;
-+	int row;
-+	int access_len;
-+	int rw_sectors;
-+	void *dma_addr;
-+	int read_status;
-+
-+	bool dma_en;
-+	bool nfi_irq_en;
-+	bool page_irq_en;
-+	bool auto_format;
-+	bool ecc_en;
-+	bool ecc_irq_en;
-+	bool ecc_clk_en;
-+	bool randomize_en;
-+	bool custom_sector_en;
-+	bool bad_mark_swap_en;
-+
-+	enum nfiecc_deccon ecc_deccon;
-+	enum nfiecc_mode ecc_mode;
-+
-+	void (*set_op_mode)(void *regs, u32 mode);
-+	bool (*is_page_empty)(struct nfi_base *nb, u8 *data, u8 *fdm,
-+			      int sectors);
-+
-+	int (*rw_prepare)(struct nfi_base *nb, int sectors, u8 *data, u8 *fdm,
-+			  bool read);
-+	void (*rw_trigger)(struct nfi_base *nb, bool read);
-+	int (*rw_wait_done)(struct nfi_base *nb, int sectors, bool read);
-+	int (*rw_data)(struct nfi_base *nb, u8 *data, u8 *fdm, int sectors,
-+		       bool read);
-+	void (*rw_complete)(struct nfi_base *nb, u8 *data, u8 *fdm, bool read);
-+};
-+
-+static inline struct nfi_base *nfi_to_base(struct nfi *nfi)
-+{
-+	return container_of(nfi, struct nfi_base, nfi);
-+}
-+
-+struct nfi *nfi_extend_init(struct nfi_base *nb);
-+void nfi_extend_exit(struct nfi_base *nb);
-+
-+#endif /* __NFI_BASE_H__ */
-diff --git a/drivers/mtd/nandx/core/nfi/nfi_regs.h b/drivers/mtd/nandx/core/nfi/nfi_regs.h
-new file mode 100644
-index 0000000000..ba4868acc8
---- /dev/null
-+++ b/drivers/mtd/nandx/core/nfi/nfi_regs.h
-@@ -0,0 +1,114 @@
-+/*
-+ * Copyright (C) 2017 MediaTek Inc.
-+ * Licensed under either
-+ *     BSD Licence, (see NOTICE for more details)
-+ *     GNU General Public License, version 2.0, (see NOTICE for more details)
-+ */
-+
-+#ifndef __NFI_REGS_H__
-+#define __NFI_REGS_H__
-+
-+#define NFI_CNFG                0x000
-+#define         CNFG_AHB                BIT(0)
-+#define         CNFG_READ_EN            BIT(1)
-+#define         CNFG_DMA_BURST_EN       BIT(2)
-+#define         CNFG_RESEED_SEC_EN      BIT(4)
-+#define         CNFG_RAND_SEL           BIT(5)
-+#define         CNFG_BYTE_RW            BIT(6)
-+#define         CNFG_HW_ECC_EN          BIT(8)
-+#define         CNFG_AUTO_FMT_EN        BIT(9)
-+#define         CNFG_RAND_MASK          GENMASK(5, 4)
-+#define         CNFG_OP_MODE_MASK       GENMASK(14, 12)
-+#define         CNFG_IDLE_MOD           0
-+#define         CNFG_READ_MODE          (1 << 12)
-+#define         CNFG_SINGLE_READ_MODE   (2 << 12)
-+#define         CNFG_PROGRAM_MODE       (3 << 12)
-+#define         CNFG_ERASE_MODE         (4 << 12)
-+#define         CNFG_RESET_MODE         (5 << 12)
-+#define         CNFG_CUSTOM_MODE        (6 << 12)
-+#define NFI_PAGEFMT             0x004
-+#define         PAGEFMT_SPARE_SHIFT     4
-+#define         PAGEFMT_FDM_ECC_SHIFT   12
-+#define         PAGEFMT_FDM_SHIFT       8
-+#define         PAGEFMT_SEC_SEL_512     BIT(2)
-+#define         PAGEFMT_512_2K          0
-+#define         PAGEFMT_2K_4K           1
-+#define         PAGEFMT_4K_8K           2
-+#define         PAGEFMT_8K_16K          3
-+#define NFI_CON                 0x008
-+#define         CON_FIFO_FLUSH          BIT(0)
-+#define         CON_NFI_RST             BIT(1)
-+#define         CON_BRD                 BIT(8)
-+#define         CON_BWR                 BIT(9)
-+#define         CON_SEC_SHIFT           12
-+#define NFI_ACCCON              0x00c
-+#define NFI_INTR_EN             0x010
-+#define         INTR_BUSY_RETURN_EN     BIT(4)
-+#define         INTR_AHB_DONE_EN        BIT(6)
-+#define NFI_INTR_STA            0x014
-+#define NFI_CMD                 0x020
-+#define NFI_ADDRNOB             0x030
-+#define         ROW_SHIFT               4
-+#define NFI_COLADDR             0x034
-+#define NFI_ROWADDR             0x038
-+#define NFI_STRDATA             0x040
-+#define         STAR_EN                 1
-+#define         STAR_DE                 0
-+#define NFI_CNRNB               0x044
-+#define NFI_DATAW               0x050
-+#define NFI_DATAR               0x054
-+#define NFI_PIO_DIRDY           0x058
-+#define         PIO_DI_RDY              1
-+#define NFI_STA                 0x060
-+#define         STA_CMD                 BIT(0)
-+#define         STA_ADDR                BIT(1)
-+#define         FLASH_MACRO_IDLE        BIT(5)
-+#define         STA_BUSY                BIT(8)
-+#define         STA_BUSY2READY          BIT(9)
-+#define         STA_EMP_PAGE            BIT(12)
-+#define         NFI_FSM_CUSTDATA        (0xe << 16)
-+#define         NFI_FSM_MASK            GENMASK(19, 16)
-+#define         NAND_FSM_MASK           GENMASK(29, 23)
-+#define NFI_ADDRCNTR            0x070
-+#define         CNTR_VALID_MASK         GENMASK(16, 0)
-+#define         CNTR_MASK               GENMASK(15, 12)
-+#define         ADDRCNTR_SEC_SHIFT      12
-+#define         ADDRCNTR_SEC(val) \
-+	(((val) & CNTR_MASK) >> ADDRCNTR_SEC_SHIFT)
-+#define NFI_STRADDR             0x080
-+#define NFI_BYTELEN             0x084
-+#define NFI_CSEL                0x090
-+#define NFI_FDML(x)             (0x0a0 + (x) * 8)
-+#define NFI_FDMM(x)             (0x0a4 + (x) * 8)
-+#define NFI_DEBUG_CON1          0x220
-+#define         STROBE_MASK             GENMASK(4, 3)
-+#define         STROBE_SHIFT            3
-+#define         ECC_CLK_EN              BIT(11)
-+#define         AUTOC_SRAM_MODE         BIT(12)
-+#define         BYPASS_MASTER_EN        BIT(15)
-+#define NFI_MASTER_STA          0x224
-+#define         MASTER_BUS_BUSY         0x3
-+#define NFI_SECCUS_SIZE         0x22c
-+#define         SECCUS_SIZE_EN          BIT(17)
-+#define NFI_RANDOM_CNFG         0x238
-+#define         RAN_ENCODE_EN           BIT(0)
-+#define         ENCODE_SEED_SHIFT       1
-+#define         RAN_DECODE_EN           BIT(16)
-+#define         DECODE_SEED_SHIFT       17
-+#define         RAN_SEED_MASK           0x7fff
-+#define NFI_EMPTY_THRESH        0x23c
-+#define NFI_NAND_TYPE_CNFG      0x240
-+#define         NAND_TYPE_ASYNC         0
-+#define         NAND_TYPE_TOGGLE        1
-+#define         NAND_TYPE_SYNC          2
-+#define NFI_ACCCON1             0x244
-+#define NFI_DELAY_CTRL          0x248
-+#define NFI_TLC_RD_WHR2         0x300
-+#define         TLC_RD_WHR2_EN          BIT(12)
-+#define         TLC_RD_WHR2_MASK        GENMASK(11, 0)
-+#define SNF_SNF_CNFG            0x55c
-+#define         SPI_MODE_EN             1
-+#define         SPI_MODE_DIS            0
-+
-+#endif /* __NFI_REGS_H__ */
-+
-diff --git a/drivers/mtd/nandx/core/nfi/nfi_spi.c b/drivers/mtd/nandx/core/nfi/nfi_spi.c
-new file mode 100644
-index 0000000000..67cd0aaad9
---- /dev/null
-+++ b/drivers/mtd/nandx/core/nfi/nfi_spi.c
-@@ -0,0 +1,689 @@
-+/*
-+ * Copyright (C) 2017 MediaTek Inc.
-+ * Licensed under either
-+ *     BSD Licence, (see NOTICE for more details)
-+ *     GNU General Public License, version 2.0, (see NOTICE for more details)
-+ */
-+
-+#include "nandx_util.h"
-+#include "nandx_core.h"
-+#include "../nfi.h"
-+#include "nfiecc.h"
-+#include "nfi_regs.h"
-+#include "nfi_base.h"
-+#include "nfi_spi_regs.h"
-+#include "nfi_spi.h"
-+
-+#define NFI_CMD_DUMMY_RD 0x00
-+#define NFI_CMD_DUMMY_WR 0x80
-+
-+static struct nfi_spi_delay spi_delay[SPI_NAND_MAX_DELAY] = {
-+	/*
-+	 * tCLK_SAM_DLY, tCLK_OUT_DLY, tCS_DLY, tWR_EN_DLY,
-+	 * tIO_IN_DLY[4], tIO_OUT_DLY[4], tREAD_LATCH_LATENCY
-+	 */
-+	{0, 0, 0, 0, {0, 0, 0, 0}, {0, 0, 0, 0}, 0},
-+	{21, 0, 0, 0, {0, 0, 0, 0}, {0, 0, 0, 0}, 0},
-+	{63, 0, 0, 0, {0, 0, 0, 0}, {0, 0, 0, 0}, 0},
-+	{0, 0, 0, 0, {0, 0, 0, 0}, {0, 0, 0, 0}, 1},
-+	{21, 0, 0, 0, {0, 0, 0, 0}, {0, 0, 0, 0}, 1},
-+	{63, 0, 0, 0, {0, 0, 0, 0}, {0, 0, 0, 0}, 1}
-+};
-+
-+static inline struct nfi_spi *base_to_snfi(struct nfi_base *nb)
-+{
-+	return container_of(nb, struct nfi_spi, base);
-+}
-+
-+static void snfi_mac_enable(struct nfi_base *nb)
-+{
-+	void *regs = nb->res.nfi_regs;
-+	u32 val;
-+
-+	val = readl(regs + SNF_MAC_CTL);
-+	val &= ~MAC_XIO_SEL;
-+	val |= SF_MAC_EN;
-+
-+	writel(val, regs + SNF_MAC_CTL);
-+}
-+
-+static void snfi_mac_disable(struct nfi_base *nb)
-+{
-+	void *regs = nb->res.nfi_regs;
-+	u32 val;
-+
-+	val = readl(regs + SNF_MAC_CTL);
-+	val &= ~(SF_TRIG | SF_MAC_EN);
-+	writel(val, regs + SNF_MAC_CTL);
-+}
-+
-+static int snfi_mac_trigger(struct nfi_base *nb)
-+{
-+	void *regs = nb->res.nfi_regs;
-+	int ret;
-+	u32 val;
-+
-+	val = readl(regs + SNF_MAC_CTL);
-+	val |= SF_TRIG;
-+	writel(val, regs + SNF_MAC_CTL);
-+
-+	ret = readl_poll_timeout_atomic(regs + SNF_MAC_CTL, val,
-+					val & WIP_READY, 10,
-+					NFI_TIMEOUT);
-+	if (ret) {
-+		pr_info("polling wip ready for read timeout\n");
-+		return ret;
-+	}
-+
-+	return readl_poll_timeout_atomic(regs + SNF_MAC_CTL, val,
-+					 !(val & WIP), 10,
-+					 NFI_TIMEOUT);
-+}
-+
-+static int snfi_mac_op(struct nfi_base *nb)
-+{
-+	int ret;
-+
-+	snfi_mac_enable(nb);
-+	ret = snfi_mac_trigger(nb);
-+	snfi_mac_disable(nb);
-+
-+	return ret;
-+}
-+
-+static void snfi_write_mac(struct nfi_spi *nfi_spi, u8 *data, int count)
-+{
-+	struct nandx_split32 split = {0};
-+	u32 reg_offset = round_down(nfi_spi->tx_count, 4);
-+	void *regs = nfi_spi->base.res.nfi_regs;
-+	u32 data_offset = 0, i, val;
-+	u8 *p_val = (u8 *)(&val);
-+
-+	nandx_split(&split, nfi_spi->tx_count, count, val, 4);
-+
-+	if (split.head_len) {
-+		val = readl(regs + SPI_GPRAM_ADDR + reg_offset);
-+
-+		for (i = 0; i < split.head_len; i++)
-+			p_val[split.head + i] = data[i];
-+
-+		writel(val, regs + SPI_GPRAM_ADDR + reg_offset);
-+	}
-+
-+	if (split.body_len) {
-+		reg_offset = split.body;
-+		data_offset = split.head_len;
-+
-+		for (i = 0; i < split.body_len; i++) {
-+			p_val[i & 3] = data[data_offset + i];
-+
-+			if ((i & 3) == 3) {
-+				writel(val, regs + SPI_GPRAM_ADDR + reg_offset);
-+				reg_offset += 4;
-+			}
-+		}
-+	}
-+
-+	if (split.tail_len) {
-+		reg_offset = split.tail;
-+		data_offset += split.body_len;
-+
-+		for (i = 0; i < split.tail_len; i++) {
-+			p_val[i] = data[data_offset + i];
-+
-+			if (i == split.tail_len - 1)
-+				writel(val, regs + SPI_GPRAM_ADDR + reg_offset);
-+		}
-+	}
-+}
-+
-+static void snfi_read_mac(struct nfi_spi *nfi_spi, u8 *data, int count)
-+{
-+	void *regs = nfi_spi->base.res.nfi_regs;
-+	u32 reg_offset = round_down(nfi_spi->tx_count, 4);
-+	struct nandx_split32 split = {0};
-+	u32 data_offset = 0, i, val;
-+	u8 *p_val = (u8 *)&val;
-+
-+	nandx_split(&split, nfi_spi->tx_count, count, val, 4);
-+
-+	if (split.head_len) {
-+		val = readl(regs + SPI_GPRAM_ADDR + reg_offset);
-+
-+		for (i = 0; i < split.head_len; i++)
-+			data[data_offset + i] = p_val[split.head + i];
-+	}
-+
-+	if (split.body_len) {
-+		reg_offset = split.body;
-+		data_offset = split.head_len;
-+
-+		for (i = 0; i < split.body_len; i++) {
-+			if ((i & 3) == 0) {
-+				val = readl(regs + SPI_GPRAM_ADDR + reg_offset);
-+				reg_offset += 4;
-+			}
-+
-+			data[data_offset + i] = p_val[i % 4];
-+		}
-+	}
-+
-+	if (split.tail_len) {
-+		reg_offset = split.tail;
-+		data_offset += split.body_len;
-+		val = readl(regs + SPI_GPRAM_ADDR + reg_offset);
-+
-+		for (i = 0; i < split.tail_len; i++)
-+			data[data_offset + i] = p_val[i];
-+	}
-+}
-+
-+static int snfi_send_command(struct nfi *nfi, short cmd)
-+{
-+	struct nfi_base *nb = nfi_to_base(nfi);
-+	struct nfi_spi *nfi_spi = base_to_snfi(nb);
-+
-+	if (cmd == -1)
-+		return 0;
-+
-+	if (nfi_spi->snfi_mode == SNFI_MAC_MODE) {
-+		snfi_write_mac(nfi_spi, (u8 *)&cmd, 1);
-+		nfi_spi->tx_count++;
-+		return 0;
-+	}
-+
-+	nfi_spi->cmd[nfi_spi->cur_cmd_idx++] = cmd;
-+	return 0;
-+}
-+
-+static int snfi_send_address(struct nfi *nfi, int col, int row,
-+			     int col_cycle,
-+			     int row_cycle)
-+{
-+	struct nfi_base *nb = nfi_to_base(nfi);
-+	struct nfi_spi *nfi_spi = base_to_snfi(nb);
-+	u32 addr, cycle, temp;
-+
-+	nb->col = col;
-+	nb->row = row;
-+
-+	if (nfi_spi->snfi_mode == SNFI_MAC_MODE) {
-+		addr = row;
-+		cycle = row_cycle;
-+
-+		if (!row_cycle) {
-+			addr = col;
-+			cycle = col_cycle;
-+		}
-+
-+		temp = nandx_cpu_to_be32(addr) >> ((4 - cycle) << 3);
-+		snfi_write_mac(nfi_spi, (u8 *)&temp, cycle);
-+		nfi_spi->tx_count += cycle;
-+	}  else {
-+		nfi_spi->row_addr[nfi_spi->cur_addr_idx++] = row;
-+		nfi_spi->col_addr[nfi_spi->cur_addr_idx++] = col;
-+	}
-+
-+	return 0;
-+}
-+
-+static int snfi_trigger(struct nfi *nfi)
-+{
-+	struct nfi_base *nb = nfi_to_base(nfi);
-+	struct nfi_spi *nfi_spi = base_to_snfi(nb);
-+	void *regs = nb->res.nfi_regs;
-+
-+	writel(nfi_spi->tx_count, regs + SNF_MAC_OUTL);
-+	writel(0, regs + SNF_MAC_INL);
-+
-+	nfi_spi->tx_count = 0;
-+	nfi_spi->cur_cmd_idx = 0;
-+	nfi_spi->cur_addr_idx = 0;
-+
-+	return snfi_mac_op(nb);
-+}
-+
-+static int snfi_select_chip(struct nfi *nfi, int cs)
-+{
-+	struct nfi_base *nb = nfi_to_base(nfi);
-+	void *regs = nb->res.nfi_regs;
-+	u32 val;
-+
-+	val = readl(regs + SNF_MISC_CTL);
-+
-+	if (cs == 0) {
-+		val &= ~SF2CS_SEL;
-+		val &= ~SF2CS_EN;
-+	} else if (cs == 1) {
-+		val |= SF2CS_SEL;
-+		val |= SF2CS_EN;
-+	} else {
-+		return -EIO;
-+	}
-+
-+	writel(val, regs + SNF_MISC_CTL);
-+
-+	return 0;
-+}
-+
-+static int snfi_set_delay(struct nfi_base *nb, u8 delay_mode)
-+{
-+	void *regs = nb->res.nfi_regs;
-+	struct nfi_spi_delay *delay;
-+	u32 val;
-+
-+	if (delay_mode < 0 || delay_mode > SPI_NAND_MAX_DELAY)
-+		return -EINVAL;
-+
-+	delay = &spi_delay[delay_mode];
-+
-+	val = delay->tIO_OUT_DLY[0] | delay->tIO_OUT_DLY[1] << 8 |
-+	      delay->tIO_OUT_DLY[2] << 16 |
-+	      delay->tIO_OUT_DLY[3] << 24;
-+	writel(val, regs + SNF_DLY_CTL1);
-+
-+	val = delay->tIO_IN_DLY[0] | (delay->tIO_IN_DLY[1] << 8) |
-+	      delay->tIO_IN_DLY[2] << 16 |
-+	      delay->tIO_IN_DLY[3] << 24;
-+	writel(val, regs + SNF_DLY_CTL2);
-+
-+	val = delay->tCLK_SAM_DLY | delay->tCLK_OUT_DLY << 8 |
-+	      delay->tCS_DLY << 16 |
-+	      delay->tWR_EN_DLY << 24;
-+	writel(val, regs + SNF_DLY_CTL3);
-+
-+	writel(delay->tCS_DLY, regs + SNF_DLY_CTL4);
-+
-+	val = readl(regs + SNF_MISC_CTL);
-+	val |= (delay->tREAD_LATCH_LATENCY) <<
-+	       LATCH_LAT_SHIFT;
-+	writel(val, regs + SNF_MISC_CTL);
-+
-+	return 0;
-+}
-+
-+static int snfi_set_timing(struct nfi *nfi, void *timing, int type)
-+{
-+	/* Nothing need to do. */
-+	return 0;
-+}
-+
-+static int snfi_wait_ready(struct nfi *nfi, int type, u32 timeout)
-+{
-+	/* Nothing need to do. */
-+	return 0;
-+}
-+
-+static int snfi_ctrl(struct nfi *nfi, int cmd, void *args)
-+{
-+	struct nfi_base *nb = nfi_to_base(nfi);
-+	struct nfi_spi *nfi_spi = base_to_snfi(nb);
-+	int ret = 0;
-+
-+	if (!args)
-+		return -EINVAL;
-+
-+	switch (cmd) {
-+	case NFI_CTRL_DMA:
-+		nb->dma_en = *(bool *)args;
-+		break;
-+
-+	case NFI_CTRL_NFI_IRQ:
-+		nb->nfi_irq_en = *(bool *)args;
-+		break;
-+
-+	case NFI_CTRL_ECC_IRQ:
-+		nb->ecc_irq_en = *(bool *)args;
-+		break;
-+
-+	case NFI_CTRL_PAGE_IRQ:
-+		nb->page_irq_en = *(bool *)args;
-+		break;
-+
-+	case NFI_CTRL_ECC:
-+		nb->ecc_en = *(bool *)args;
-+		break;
-+
-+	case NFI_CTRL_BAD_MARK_SWAP:
-+		nb->bad_mark_swap_en = *(bool *)args;
-+		break;
-+
-+	case NFI_CTRL_ECC_CLOCK:
-+		nb->ecc_clk_en = *(bool *)args;
-+		break;
-+
-+	case SNFI_CTRL_OP_MODE:
-+		nfi_spi->snfi_mode = *(u8 *)args;
-+		break;
-+
-+	case SNFI_CTRL_RX_MODE:
-+		nfi_spi->read_cache_mode = *(u8 *)args;
-+		break;
-+
-+	case SNFI_CTRL_TX_MODE:
-+		nfi_spi->write_cache_mode = *(u8 *)args;
-+		break;
-+
-+	case SNFI_CTRL_DELAY_MODE:
-+		ret = snfi_set_delay(nb, *(u8 *)args);
-+		break;
-+
-+	default:
-+		pr_info("operation not support.\n");
-+		ret = -EOPNOTSUPP;
-+		break;
-+	}
-+
-+	return ret;
-+}
-+
-+static int snfi_read_bytes(struct nfi *nfi, u8 *data, int count)
-+{
-+	struct nfi_base *nb = nfi_to_base(nfi);
-+	struct nfi_spi *nfi_spi = base_to_snfi(nb);
-+	void *regs = nb->res.nfi_regs;
-+	int ret;
-+
-+	writel(nfi_spi->tx_count, regs + SNF_MAC_OUTL);
-+	writel(count, regs + SNF_MAC_INL);
-+
-+	ret = snfi_mac_op(nb);
-+	if (ret)
-+		return ret;
-+
-+	snfi_read_mac(nfi_spi, data, count);
-+
-+	nfi_spi->tx_count = 0;
-+
-+	return 0;
-+}
-+
-+static int snfi_write_bytes(struct nfi *nfi, u8 *data, int count)
-+{
-+	struct nfi_base *nb = nfi_to_base(nfi);
-+	struct nfi_spi *nfi_spi = base_to_snfi(nb);
-+	void *regs = nb->res.nfi_regs;
-+
-+	snfi_write_mac(nfi_spi, data, count);
-+	nfi_spi->tx_count += count;
-+
-+	writel(0, regs + SNF_MAC_INL);
-+	writel(nfi_spi->tx_count, regs + SNF_MAC_OUTL);
-+
-+	nfi_spi->tx_count = 0;
-+
-+	return snfi_mac_op(nb);
-+}
-+
-+static int snfi_reset(struct nfi *nfi)
-+{
-+	struct nfi_base *nb = nfi_to_base(nfi);
-+	struct nfi_spi *nfi_spi = base_to_snfi(nb);
-+	void *regs = nb->res.nfi_regs;
-+	u32 val;
-+	int ret;
-+
-+	ret = nfi_spi->parent->nfi.reset(nfi);
-+	if (ret)
-+		return ret;
-+
-+	val = readl(regs + SNF_MISC_CTL);
-+	val |= SW_RST;
-+	writel(val, regs + SNF_MISC_CTL);
-+
-+	ret = readx_poll_timeout_atomic(readw, regs + SNF_STA_CTL1, val,
-+					!(val & SPI_STATE), 50,
-+					NFI_TIMEOUT);
-+	if (ret) {
-+		pr_info("spi state active in reset [0x%x] = 0x%x\n",
-+			SNF_STA_CTL1, val);
-+		return ret;
-+	}
-+
-+	val = readl(regs + SNF_MISC_CTL);
-+	val &= ~SW_RST;
-+	writel(val, regs + SNF_MISC_CTL);
-+
-+	return 0;
-+}
-+
-+static int snfi_config_for_write(struct nfi_base *nb, int count)
-+{
-+	struct nfi_spi *nfi_spi = base_to_snfi(nb);
-+	void *regs = nb->res.nfi_regs;
-+	u32 val;
-+
-+	nb->set_op_mode(regs, CNFG_CUSTOM_MODE);
-+
-+	val = readl(regs + SNF_MISC_CTL);
-+
-+	if (nfi_spi->write_cache_mode == SNFI_TX_114)
-+		val |= PG_LOAD_X4_EN;
-+
-+	if (nfi_spi->snfi_mode == SNFI_CUSTOM_MODE)
-+		val |= PG_LOAD_CUSTOM_EN;
-+
-+	writel(val, regs + SNF_MISC_CTL);
-+
-+	val = count * (nb->nfi.sector_size + nb->nfi.sector_spare_size);
-+	writel(val << PG_LOAD_SHIFT, regs + SNF_MISC_CTL2);
-+
-+	val = readl(regs + SNF_PG_CTL1);
-+
-+	if (nfi_spi->snfi_mode == SNFI_CUSTOM_MODE)
-+		val |= nfi_spi->cmd[0] << PG_LOAD_CMD_SHIFT;
-+	else {
-+		val |= nfi_spi->cmd[0] | nfi_spi->cmd[1] << PG_LOAD_CMD_SHIFT |
-+		       nfi_spi->cmd[2] << PG_EXE_CMD_SHIFT;
-+
-+		writel(nfi_spi->row_addr[1], regs + SNF_PG_CTL3);
-+		writel(nfi_spi->cmd[3] << GF_CMD_SHIFT | nfi_spi->col_addr[2] <<
-+		       GF_ADDR_SHIFT, regs + SNF_GF_CTL1);
-+	}
-+
-+	writel(val, regs + SNF_PG_CTL1);
-+	writel(nfi_spi->col_addr[1], regs + SNF_PG_CTL2);
-+
-+	writel(NFI_CMD_DUMMY_WR, regs + NFI_CMD);
-+
-+	return 0;
-+}
-+
-+static int snfi_config_for_read(struct nfi_base *nb, int count)
-+{
-+	struct nfi_spi *nfi_spi = base_to_snfi(nb);
-+	void *regs = nb->res.nfi_regs;
-+	u32 val;
-+	int ret = 0;
-+
-+	nb->set_op_mode(regs, CNFG_CUSTOM_MODE);
-+
-+	val = readl(regs + SNF_MISC_CTL);
-+	val &= ~DARA_READ_MODE_MASK;
-+
-+	switch (nfi_spi->read_cache_mode) {
-+
-+	case SNFI_RX_111:
-+		break;
-+
-+	case SNFI_RX_112:
-+		val |= X2_DATA_MODE << READ_MODE_SHIFT;
-+		break;
-+
-+	case SNFI_RX_114:
-+		val |= X4_DATA_MODE << READ_MODE_SHIFT;
-+		break;
-+
-+	case SNFI_RX_122:
-+		val |= DUAL_IO_MODE << READ_MODE_SHIFT;
-+		break;
-+
-+	case SNFI_RX_144:
-+		val |= QUAD_IO_MODE << READ_MODE_SHIFT;
-+		break;
-+
-+	default:
-+		pr_info("Not support this read operarion: %d!\n",
-+		       nfi_spi->read_cache_mode);
-+		ret = -EINVAL;
-+		break;
-+	}
-+
-+	if (nfi_spi->snfi_mode == SNFI_CUSTOM_MODE)
-+		val |= DATARD_CUSTOM_EN;
-+
-+	writel(val, regs + SNF_MISC_CTL);
-+
-+	val = count * (nb->nfi.sector_size + nb->nfi.sector_spare_size);
-+	writel(val, regs + SNF_MISC_CTL2);
-+
-+	val = readl(regs + SNF_RD_CTL2);
-+
-+	if (nfi_spi->snfi_mode == SNFI_CUSTOM_MODE) {
-+		val |= nfi_spi->cmd[0];
-+		writel(nfi_spi->col_addr[1], regs + SNF_RD_CTL3);
-+	} else {
-+		val |= nfi_spi->cmd[2];
-+		writel(nfi_spi->cmd[0] << PAGE_READ_CMD_SHIFT |
-+		       nfi_spi->row_addr[0], regs + SNF_RD_CTL1);
-+		writel(nfi_spi->cmd[1] << GF_CMD_SHIFT |
-+		       nfi_spi->col_addr[1] << GF_ADDR_SHIFT,
-+		       regs + SNF_GF_CTL1);
-+		writel(nfi_spi->col_addr[2], regs + SNF_RD_CTL3);
-+	}
-+
-+	writel(val, regs + SNF_RD_CTL2);
-+
-+	writel(NFI_CMD_DUMMY_RD, regs + NFI_CMD);
-+
-+	return ret;
-+}
-+
-+static bool is_page_empty(struct nfi_base *nb, u8 *data, u8 *fdm,
-+			  int sectors)
-+{
-+	u32 *data32 = (u32 *)data;
-+	u32 *fdm32 = (u32 *)fdm;
-+	u32 i, count = 0;
-+
-+	for (i = 0; i < nb->format.page_size >> 2; i++) {
-+		if (data32[i] != 0xffff) {
-+			count += zero_popcount(data32[i]);
-+			if (count > 10) {
-+				pr_info("%s %d %d count:%d\n",
-+					__func__, __LINE__, i, count);
-+				return false;
-+			}
-+		}
-+	}
-+
-+	if (fdm) {
-+		for (i = 0; i < (nb->nfi.fdm_size * sectors >> 2); i++)
-+		if (fdm32[i] != 0xffff) {
-+			count += zero_popcount(fdm32[i]);
-+			if (count > 10) {
-+				pr_info("%s %d %d count:%d\n",
-+					__func__, __LINE__, i, count);
-+				return false;
-+			}
-+		}
-+	}
-+
-+	return true;
-+}
-+
-+static int rw_prepare(struct nfi_base *nb, int sectors, u8 *data,
-+		      u8 *fdm,
-+		      bool read)
-+{
-+	struct nfi_spi *nfi_spi = base_to_snfi(nb);
-+	int ret;
-+
-+	ret = nfi_spi->parent->rw_prepare(nb, sectors, data, fdm, read);
-+	if (ret)
-+		return ret;
-+
-+	if (read)
-+		ret = snfi_config_for_read(nb, sectors);
-+	else
-+		ret = snfi_config_for_write(nb, sectors);
-+
-+	return ret;
-+}
-+
-+static void rw_complete(struct nfi_base *nb, u8 *data, u8 *fdm,
-+			bool read)
-+{
-+	struct nfi_spi *nfi_spi = base_to_snfi(nb);
-+	void *regs = nb->res.nfi_regs;
-+	u32 val;
-+
-+	nfi_spi->parent->rw_complete(nb, data, fdm, read);
-+
-+	val = readl(regs + SNF_MISC_CTL);
-+
-+	if (read)
-+		val &= ~DATARD_CUSTOM_EN;
-+	else
-+		val &= ~PG_LOAD_CUSTOM_EN;
-+
-+	writel(val, regs + SNF_MISC_CTL);
-+
-+	nfi_spi->tx_count = 0;
-+	nfi_spi->cur_cmd_idx = 0;
-+	nfi_spi->cur_addr_idx = 0;
-+}
-+
-+static void set_nfi_base_funcs(struct nfi_base *nb)
-+{
-+	nb->nfi.reset = snfi_reset;
-+	nb->nfi.set_timing = snfi_set_timing;
-+	nb->nfi.wait_ready = snfi_wait_ready;
-+
-+	nb->nfi.send_cmd = snfi_send_command;
-+	nb->nfi.send_addr = snfi_send_address;
-+	nb->nfi.trigger = snfi_trigger;
-+	nb->nfi.nfi_ctrl = snfi_ctrl;
-+	nb->nfi.select_chip = snfi_select_chip;
-+
-+	nb->nfi.read_bytes = snfi_read_bytes;
-+	nb->nfi.write_bytes = snfi_write_bytes;
-+
-+	nb->rw_prepare = rw_prepare;
-+	nb->rw_complete = rw_complete;
-+	nb->is_page_empty = is_page_empty;
-+
-+}
-+
-+struct nfi *nfi_extend_init(struct nfi_base *nb)
-+{
-+	struct nfi_spi *nfi_spi;
-+
-+	nfi_spi = mem_alloc(1, sizeof(struct nfi_spi));
-+	if (!nfi_spi) {
-+		pr_info("snfi alloc memory fail @%s.\n", __func__);
-+		return NULL;
-+	}
-+
-+	memcpy(&nfi_spi->base, nb, sizeof(struct nfi_base));
-+	nfi_spi->parent = nb;
-+
-+	nfi_spi->read_cache_mode = SNFI_RX_114;
-+	nfi_spi->write_cache_mode = SNFI_TX_114;
-+
-+	set_nfi_base_funcs(&nfi_spi->base);
-+
-+	/* Change nfi to spi mode */
-+	writel(SPI_MODE, nb->res.nfi_regs + SNF_SNF_CNFG);
-+
-+	return &(nfi_spi->base.nfi);
-+}
-+
-+void nfi_extend_exit(struct nfi_base *nb)
-+{
-+	struct nfi_spi *nfi_spi = base_to_snfi(nb);
-+
-+	mem_free(nfi_spi->parent);
-+	mem_free(nfi_spi);
-+}
-+
-diff --git a/drivers/mtd/nandx/core/nfi/nfi_spi.h b/drivers/mtd/nandx/core/nfi/nfi_spi.h
-new file mode 100644
-index 0000000000..a52255663a
---- /dev/null
-+++ b/drivers/mtd/nandx/core/nfi/nfi_spi.h
-@@ -0,0 +1,44 @@
-+/*
-+ * Copyright (C) 2017 MediaTek Inc.
-+ * Licensed under either
-+ *     BSD Licence, (see NOTICE for more details)
-+ *     GNU General Public License, version 2.0, (see NOTICE for more details)
-+ */
-+
-+#ifndef __NFI_SPI_H__
-+#define __NFI_SPI_H__
-+
-+#define SPI_NAND_MAX_DELAY      6
-+#define SPI_NAND_MAX_OP         4
-+
-+/*TODO - add comments */
-+struct nfi_spi_delay {
-+	u8 tCLK_SAM_DLY;
-+	u8 tCLK_OUT_DLY;
-+	u8 tCS_DLY;
-+	u8 tWR_EN_DLY;
-+	u8 tIO_IN_DLY[4];
-+	u8 tIO_OUT_DLY[4];
-+	u8 tREAD_LATCH_LATENCY;
-+};
-+
-+/* SPI Nand structure */
-+struct nfi_spi {
-+	struct nfi_base base;
-+	struct nfi_base *parent;
-+
-+	u8 snfi_mode;
-+	u8 tx_count;
-+
-+	u8 cmd[SPI_NAND_MAX_OP];
-+	u8 cur_cmd_idx;
-+
-+	u32 row_addr[SPI_NAND_MAX_OP];
-+	u32 col_addr[SPI_NAND_MAX_OP];
-+	u8 cur_addr_idx;
-+
-+	u8 read_cache_mode;
-+	u8 write_cache_mode;
-+};
-+
-+#endif /* __NFI_SPI_H__ */
-diff --git a/drivers/mtd/nandx/core/nfi/nfi_spi_regs.h b/drivers/mtd/nandx/core/nfi/nfi_spi_regs.h
-new file mode 100644
-index 0000000000..77adf46782
---- /dev/null
-+++ b/drivers/mtd/nandx/core/nfi/nfi_spi_regs.h
-@@ -0,0 +1,64 @@
-+/*
-+ * Copyright (C) 2017 MediaTek Inc.
-+ * Licensed under either
-+ *     BSD Licence, (see NOTICE for more details)
-+ *     GNU General Public License, version 2.0, (see NOTICE for more details)
-+ */
-+
-+#ifndef __NFI_SPI_REGS_H__
-+#define __NFI_SPI_REGS_H__
-+
-+#define SNF_MAC_CTL             0x500
-+#define         WIP                     BIT(0)
-+#define         WIP_READY               BIT(1)
-+#define         SF_TRIG                 BIT(2)
-+#define         SF_MAC_EN               BIT(3)
-+#define         MAC_XIO_SEL             BIT(4)
-+#define SNF_MAC_OUTL            0x504
-+#define SNF_MAC_INL             0x508
-+#define SNF_RD_CTL1             0x50c
-+#define         PAGE_READ_CMD_SHIFT     24
-+#define SNF_RD_CTL2             0x510
-+#define SNF_RD_CTL3             0x514
-+#define SNF_GF_CTL1             0x518
-+#define         GF_ADDR_SHIFT           16
-+#define         GF_CMD_SHIFT            24
-+#define SNF_GF_CTL3             0x520
-+#define SNF_PG_CTL1             0x524
-+#define         PG_EXE_CMD_SHIFT        16
-+#define         PG_LOAD_CMD_SHIFT       8
-+#define SNF_PG_CTL2             0x528
-+#define SNF_PG_CTL3             0x52c
-+#define SNF_ER_CTL              0x530
-+#define SNF_ER_CTL2             0x534
-+#define SNF_MISC_CTL            0x538
-+#define         SW_RST                  BIT(28)
-+#define         PG_LOAD_X4_EN           BIT(20)
-+#define         X2_DATA_MODE            1
-+#define         X4_DATA_MODE            2
-+#define         DUAL_IO_MODE            5
-+#define         QUAD_IO_MODE            6
-+#define         READ_MODE_SHIFT         16
-+#define         LATCH_LAT_SHIFT         8
-+#define         LATCH_LAT_MASK          GENMASK(9, 8)
-+#define         DARA_READ_MODE_MASK     GENMASK(18, 16)
-+#define         SF2CS_SEL               BIT(13)
-+#define         SF2CS_EN                BIT(12)
-+#define         PG_LOAD_CUSTOM_EN       BIT(7)
-+#define         DATARD_CUSTOM_EN        BIT(6)
-+#define SNF_MISC_CTL2           0x53c
-+#define         PG_LOAD_SHIFT           16
-+#define SNF_DLY_CTL1            0x540
-+#define SNF_DLY_CTL2            0x544
-+#define SNF_DLY_CTL3            0x548
-+#define SNF_DLY_CTL4            0x54c
-+#define SNF_STA_CTL1            0x550
-+#define         SPI_STATE               GENMASK(3, 0)
-+#define SNF_STA_CTL2            0x554
-+#define SNF_STA_CTL3            0x558
-+#define SNF_SNF_CNFG            0x55c
-+#define         SPI_MODE                BIT(0)
-+#define SNF_DEBUG_SEL           0x560
-+#define SPI_GPRAM_ADDR          0x800
-+
-+#endif /* __NFI_SPI_REGS_H__ */
-diff --git a/drivers/mtd/nandx/core/nfi/nfiecc.c b/drivers/mtd/nandx/core/nfi/nfiecc.c
-new file mode 100644
-index 0000000000..14246fbc3e
---- /dev/null
-+++ b/drivers/mtd/nandx/core/nfi/nfiecc.c
-@@ -0,0 +1,510 @@
-+/*
-+ * Copyright (C) 2017 MediaTek Inc.
-+ * Licensed under either
-+ *     BSD Licence, (see NOTICE for more details)
-+ *     GNU General Public License, version 2.0, (see NOTICE for more details)
-+ */
-+
-+#include "nandx_util.h"
-+#include "nandx_core.h"
-+#include "nfiecc_regs.h"
-+#include "nfiecc.h"
-+
-+#define NFIECC_IDLE_REG(op) \
-+	((op) == ECC_ENCODE ? NFIECC_ENCIDLE : NFIECC_DECIDLE)
-+#define         IDLE_MASK       1
-+#define NFIECC_CTL_REG(op) \
-+	((op) == ECC_ENCODE ? NFIECC_ENCCON : NFIECC_DECCON)
-+#define NFIECC_IRQ_REG(op) \
-+	((op) == ECC_ENCODE ? NFIECC_ENCIRQEN : NFIECC_DECIRQEN)
-+#define NFIECC_ADDR(op) \
-+	((op) == ECC_ENCODE ? NFIECC_ENCDIADDR : NFIECC_DECDIADDR)
-+
-+#define ECC_TIMEOUT     500000
-+
-+/* ecc strength that each IP supports */
-+static const int ecc_strength_mt7622[] = {
-+	4, 6, 8, 10, 12, 14, 16
-+};
-+
-+static int nfiecc_irq_handler(void *data)
-+{
-+	struct nfiecc *ecc = data;
-+	void *regs = ecc->res.regs;
-+	u32 status;
-+
-+	status = readl(regs + NFIECC_DECIRQSTA) & DEC_IRQSTA_GEN;
-+	if (status) {
-+		status = readl(regs + NFIECC_DECDONE);
-+		if (!(status & ecc->config.sectors))
-+			return NAND_IRQ_NONE;
-+
-+		/*
-+		 * Clear decode IRQ status once again to ensure that
-+		 * there will be no extra IRQ.
-+		 */
-+		readl(regs + NFIECC_DECIRQSTA);
-+		ecc->config.sectors = 0;
-+		nandx_event_complete(ecc->done);
-+	} else {
-+		status = readl(regs + NFIECC_ENCIRQSTA) & ENC_IRQSTA_GEN;
-+		if (!status)
-+			return NAND_IRQ_NONE;
-+
-+		nandx_event_complete(ecc->done);
-+	}
-+
-+	return NAND_IRQ_HANDLED;
-+}
-+
-+static inline int nfiecc_wait_idle(struct nfiecc *ecc)
-+{
-+	int op = ecc->config.op;
-+	int ret, val;
-+
-+	ret = readl_poll_timeout_atomic(ecc->res.regs + NFIECC_IDLE_REG(op),
-+					val, val & IDLE_MASK,
-+					10, ECC_TIMEOUT);
-+	if (ret)
-+		pr_info("%s not idle\n",
-+			op == ECC_ENCODE ? "encoder" : "decoder");
-+
-+	return ret;
-+}
-+
-+static int nfiecc_wait_encode_done(struct nfiecc *ecc)
-+{
-+	int ret, val;
-+
-+	if (ecc->ecc_irq_en) {
-+		/* poll one time to avoid missing irq event */
-+		ret = readl_poll_timeout_atomic(ecc->res.regs + NFIECC_ENCSTA,
-+						val, val & ENC_FSM_IDLE, 1, 1);
-+		if (!ret)
-+			return 0;
-+
-+		/* irq done, if not, we can go on to poll status for a while */
-+		ret = nandx_event_wait_complete(ecc->done, ECC_TIMEOUT);
-+		if (ret)
-+			return 0;
-+	}
-+
-+	ret = readl_poll_timeout_atomic(ecc->res.regs + NFIECC_ENCSTA,
-+					val, val & ENC_FSM_IDLE,
-+					10, ECC_TIMEOUT);
-+	if (ret)
-+		pr_info("encode timeout\n");
-+
-+	return ret;
-+
-+}
-+
-+static int nfiecc_wait_decode_done(struct nfiecc *ecc)
-+{
-+	u32 secbit = BIT(ecc->config.sectors - 1);
-+	void *regs = ecc->res.regs;
-+	int ret, val;
-+
-+	if (ecc->ecc_irq_en) {
-+		ret = readl_poll_timeout_atomic(regs + NFIECC_DECDONE,
-+						val, val & secbit, 1, 1);
-+		if (!ret)
-+			return 0;
-+
-+		ret = nandx_event_wait_complete(ecc->done, ECC_TIMEOUT);
-+		if (ret)
-+			return 0;
-+	}
-+
-+	ret = readl_poll_timeout_atomic(regs + NFIECC_DECDONE,
-+					val, val & secbit,
-+					10, ECC_TIMEOUT);
-+	if (ret) {
-+		pr_info("decode timeout\n");
-+		return ret;
-+	}
-+
-+	/* decode done does not stands for ecc all work done.
-+	 * we need check syn, bma, chien, autoc all idle.
-+	 * just check it when ECC_DECCNFG[13:12] is 3,
-+	 * which means auto correct.
-+	 */
-+	ret = readl_poll_timeout_atomic(regs + NFIECC_DECFSM,
-+					val, (val & FSM_MASK) == FSM_IDLE,
-+					10, ECC_TIMEOUT);
-+	if (ret)
-+		pr_info("decode fsm(0x%x) is not idle\n",
-+		       readl(regs + NFIECC_DECFSM));
-+
-+	return ret;
-+}
-+
-+static int nfiecc_wait_done(struct nfiecc *ecc)
-+{
-+	if (ecc->config.op == ECC_ENCODE)
-+		return nfiecc_wait_encode_done(ecc);
-+
-+	return nfiecc_wait_decode_done(ecc);
-+}
-+
-+static void nfiecc_encode_config(struct nfiecc *ecc, u32 ecc_idx)
-+{
-+	struct nfiecc_config *config = &ecc->config;
-+	u32 val;
-+
-+	val = ecc_idx | (config->mode << ecc->caps->ecc_mode_shift);
-+
-+	if (config->mode == ECC_DMA_MODE)
-+		val |= ENC_BURST_EN;
-+
-+	val |= (config->len << 3) << ENCCNFG_MS_SHIFT;
-+	writel(val, ecc->res.regs + NFIECC_ENCCNFG);
-+}
-+
-+static void nfiecc_decode_config(struct nfiecc *ecc, u32 ecc_idx)
-+{
-+	struct nfiecc_config *config = &ecc->config;
-+	u32 dec_sz = (config->len << 3) +
-+		     config->strength * ecc->caps->parity_bits;
-+	u32 val;
-+
-+	val = ecc_idx | (config->mode << ecc->caps->ecc_mode_shift);
-+
-+	if (config->mode == ECC_DMA_MODE)
-+		val |= DEC_BURST_EN;
-+
-+	val |= (dec_sz << DECCNFG_MS_SHIFT) |
-+	       (config->deccon << DEC_CON_SHIFT);
-+	val |= DEC_EMPTY_EN;
-+	writel(val, ecc->res.regs + NFIECC_DECCNFG);
-+}
-+
-+static void nfiecc_config(struct nfiecc *ecc)
-+{
-+	u32 idx;
-+
-+	for (idx = 0; idx < ecc->caps->ecc_strength_num; idx++) {
-+		if (ecc->config.strength == ecc->caps->ecc_strength[idx])
-+			break;
-+	}
-+
-+	if (ecc->config.op == ECC_ENCODE)
-+		nfiecc_encode_config(ecc, idx);
-+	else
-+		nfiecc_decode_config(ecc, idx);
-+}
-+
-+static int nfiecc_enable(struct nfiecc *ecc)
-+{
-+	enum nfiecc_operation op = ecc->config.op;
-+	void *regs = ecc->res.regs;
-+
-+	nfiecc_config(ecc);
-+
-+	writel(ECC_OP_EN, regs + NFIECC_CTL_REG(op));
-+
-+	if (ecc->ecc_irq_en) {
-+		writel(ECC_IRQEN, regs + NFIECC_IRQ_REG(op));
-+
-+		if (ecc->page_irq_en)
-+			writel(ECC_IRQEN | ECC_PG_IRQ_SEL,
-+			       regs + NFIECC_IRQ_REG(op));
-+
-+		nandx_event_init(ecc->done);
-+	}
-+
-+	return 0;
-+}
-+
-+static int nfiecc_disable(struct nfiecc *ecc)
-+{
-+	enum nfiecc_operation op = ecc->config.op;
-+	void *regs = ecc->res.regs;
-+
-+	nfiecc_wait_idle(ecc);
-+
-+	writel(0, regs + NFIECC_IRQ_REG(op));
-+	writel(~ECC_OP_EN, regs + NFIECC_CTL_REG(op));
-+
-+	return 0;
-+}
-+
-+static int nfiecc_correct_data(struct nfiecc *ecc,
-+			       struct nfiecc_status *status,
-+			       u8 *data, u32 sector)
-+{
-+	u32 err, offset, i;
-+	u32 loc, byteloc, bitloc;
-+
-+	status->corrected = 0;
-+	status->failed = 0;
-+
-+	offset = (sector >> 2);
-+	err = readl(ecc->res.regs + NFIECC_DECENUM(offset));
-+	err >>= (sector % 4) * 8;
-+	err &= ecc->caps->err_mask;
-+
-+	if (err == ecc->caps->err_mask) {
-+		status->failed++;
-+		return -ENANDREAD;
-+	}
-+
-+	status->corrected += err;
-+	status->bitflips = max_t(u32, status->bitflips, err);
-+
-+	for (i = 0; i < err; i++) {
-+		loc = readl(ecc->res.regs + NFIECC_DECEL(i >> 1));
-+		loc >>= ((i & 0x1) << 4);
-+		byteloc = loc >> 3;
-+		bitloc = loc & 0x7;
-+		data[byteloc] ^= (1 << bitloc);
-+	}
-+
-+	return 0;
-+}
-+
-+static int nfiecc_fill_data(struct nfiecc *ecc, u8 *data)
-+{
-+	struct nfiecc_config *config = &ecc->config;
-+	void *regs = ecc->res.regs;
-+	int size, ret, i;
-+	u32 val;
-+
-+	if (config->mode == ECC_DMA_MODE) {
-+		if ((unsigned long)config->dma_addr & 0x3)
-+			pr_info("encode address is not 4B aligned: 0x%x\n",
-+			       (u32)(unsigned long)config->dma_addr);
-+
-+		writel((unsigned long)config->dma_addr,
-+		       regs + NFIECC_ADDR(config->op));
-+	} else if (config->mode == ECC_PIO_MODE) {
-+		if (config->op == ECC_ENCODE) {
-+			size = (config->len + 3) >> 2;
-+		} else {
-+			size = config->strength * ecc->caps->parity_bits;
-+			size = (size + 7) >> 3;
-+			size += config->len;
-+			size >>= 2;
-+		}
-+
-+		for (i = 0; i < size; i++) {
-+			ret = readl_poll_timeout_atomic(regs + NFIECC_PIO_DIRDY,
-+							val, val & PIO_DI_RDY,
-+							10, ECC_TIMEOUT);
-+			if (ret)
-+				return ret;
-+
-+			writel(*((u32 *)data + i), regs + NFIECC_PIO_DI);
-+		}
-+	}
-+
-+	return 0;
-+}
-+
-+static int nfiecc_encode(struct nfiecc *ecc, u8 *data)
-+{
-+	struct nfiecc_config *config = &ecc->config;
-+	u32 len, i, val = 0;
-+	u8 *p;
-+	int ret;
-+
-+	/* Under NFI mode, nothing need to do */
-+	if (config->mode == ECC_NFI_MODE)
-+		return 0;
-+
-+	ret = nfiecc_fill_data(ecc, data);
-+	if (ret)
-+		return ret;
-+
-+	ret = nfiecc_wait_encode_done(ecc);
-+	if (ret)
-+		return ret;
-+
-+	ret = nfiecc_wait_idle(ecc);
-+	if (ret)
-+		return ret;
-+
-+	/* Program ECC bytes to OOB: per sector oob = FDM + ECC + SPARE */
-+	len = (config->strength * ecc->caps->parity_bits + 7) >> 3;
-+	p = data + config->len;
-+
-+	/* Write the parity bytes generated by the ECC back to the OOB region */
-+	for (i = 0; i < len; i++) {
-+		if ((i % 4) == 0)
-+			val = readl(ecc->res.regs + NFIECC_ENCPAR(i / 4));
-+
-+		p[i] = (val >> ((i % 4) * 8)) & 0xff;
-+	}
-+
-+	return 0;
-+}
-+
-+static int nfiecc_decode(struct nfiecc *ecc, u8 *data)
-+{
-+	int ret;
-+
-+	/* Under NFI mode, nothing need to do */
-+	if (ecc->config.mode == ECC_NFI_MODE)
-+		return 0;
-+
-+	ret = nfiecc_fill_data(ecc, data);
-+	if (ret)
-+		return ret;
-+
-+	return nfiecc_wait_decode_done(ecc);
-+}
-+
-+static int nfiecc_decode_status(struct nfiecc *ecc, u32 start_sector,
-+				u32 sectors)
-+{
-+	void *regs = ecc->res.regs;
-+	u32 i, val = 0, err;
-+	u32 bitflips = 0;
-+
-+	for (i = start_sector; i < start_sector + sectors; i++) {
-+		if ((i % 4) == 0)
-+			val = readl(regs + NFIECC_DECENUM(i / 4));
-+
-+		err = val >> ((i % 4) * 5);
-+		err &= ecc->caps->err_mask;
-+
-+		if (err == ecc->caps->err_mask)
-+			pr_err("sector %d is uncorrect\n", i);
-+
-+		bitflips = max_t(u32, bitflips, err);
-+	}
-+
-+	if (bitflips == ecc->caps->err_mask)
-+		return -ENANDREAD;
-+
-+	if (bitflips)
-+		pr_info("bitflips %d is corrected\n", bitflips);
-+
-+	return bitflips;
-+}
-+
-+static int nfiecc_adjust_strength(struct nfiecc *ecc, int strength)
-+{
-+	struct nfiecc_caps *caps = ecc->caps;
-+	int i, count = caps->ecc_strength_num;
-+
-+	if (strength >= caps->ecc_strength[count - 1])
-+		return caps->ecc_strength[count - 1];
-+
-+	if (strength < caps->ecc_strength[0])
-+		return -EINVAL;
-+
-+	for (i = 1; i < count; i++) {
-+		if (strength < caps->ecc_strength[i])
-+			return caps->ecc_strength[i - 1];
-+	}
-+
-+	return -EINVAL;
-+}
-+
-+static int nfiecc_ctrl(struct nfiecc *ecc, int cmd, void *args)
-+{
-+	int ret = 0;
-+
-+	switch (cmd) {
-+	case NFI_CTRL_ECC_IRQ:
-+		ecc->ecc_irq_en = *(bool *)args;
-+		break;
-+
-+	case NFI_CTRL_ECC_PAGE_IRQ:
-+		ecc->page_irq_en = *(bool *)args;
-+		break;
-+
-+	default:
-+		pr_info("invalid arguments.\n");
-+		ret = -EINVAL;
-+		break;
-+	}
-+
-+	return ret;
-+}
-+
-+static int nfiecc_hw_init(struct nfiecc *ecc)
-+{
-+	int ret;
-+
-+	ret = nfiecc_wait_idle(ecc);
-+	if (ret)
-+		return ret;
-+
-+	writel(~ECC_OP_EN, ecc->res.regs + NFIECC_ENCCON);
-+
-+	ret = nfiecc_wait_idle(ecc);
-+	if (ret)
-+		return ret;
-+
-+	writel(~ECC_OP_EN, ecc->res.regs + NFIECC_DECCON);
-+
-+	return 0;
-+}
-+
-+static struct nfiecc_caps nfiecc_caps_mt7622 = {
-+	.err_mask = 0x1f,
-+	.ecc_mode_shift = 4,
-+	.parity_bits = 13,
-+	.ecc_strength = ecc_strength_mt7622,
-+	.ecc_strength_num = 7,
-+};
-+
-+static struct nfiecc_caps *nfiecc_get_match_data(enum mtk_ic_version ic)
-+{
-+	/* NOTE: add other IC's data */
-+	return &nfiecc_caps_mt7622;
-+}
-+
-+struct nfiecc *nfiecc_init(struct nfiecc_resource *res)
-+{
-+	struct nfiecc *ecc;
-+	int ret;
-+
-+	ecc = mem_alloc(1, sizeof(struct nfiecc));
-+	if (!ecc)
-+		return NULL;
-+
-+	ecc->res = *res;
-+
-+	ret = nandx_irq_register(res->dev, res->irq_id, nfiecc_irq_handler,
-+				 "mtk-ecc", ecc);
-+	if (ret) {
-+		pr_info("ecc irq register failed!\n");
-+		goto error;
-+	}
-+
-+	ecc->ecc_irq_en = false;
-+	ecc->page_irq_en = false;
-+	ecc->done = nandx_event_create();
-+	ecc->caps = nfiecc_get_match_data(res->ic_ver);
-+
-+	ecc->adjust_strength = nfiecc_adjust_strength;
-+	ecc->enable = nfiecc_enable;
-+	ecc->disable = nfiecc_disable;
-+	ecc->decode = nfiecc_decode;
-+	ecc->encode = nfiecc_encode;
-+	ecc->wait_done = nfiecc_wait_done;
-+	ecc->decode_status = nfiecc_decode_status;
-+	ecc->correct_data = nfiecc_correct_data;
-+	ecc->nfiecc_ctrl = nfiecc_ctrl;
-+
-+	ret = nfiecc_hw_init(ecc);
-+	if (ret)
-+		return NULL;
-+
-+	return ecc;
-+
-+error:
-+	mem_free(ecc);
-+
-+	return NULL;
-+}
-+
-+void nfiecc_exit(struct nfiecc *ecc)
-+{
-+	nandx_event_destroy(ecc->done);
-+	mem_free(ecc);
-+}
-+
-diff --git a/drivers/mtd/nandx/core/nfi/nfiecc.h b/drivers/mtd/nandx/core/nfi/nfiecc.h
-new file mode 100644
-index 0000000000..b02a5c3534
---- /dev/null
-+++ b/drivers/mtd/nandx/core/nfi/nfiecc.h
-@@ -0,0 +1,90 @@
-+/*
-+ * Copyright (C) 2017 MediaTek Inc.
-+ * Licensed under either
-+ *     BSD Licence, (see NOTICE for more details)
-+ *     GNU General Public License, version 2.0, (see NOTICE for more details)
-+ */
-+
-+#ifndef __NFIECC_H__
-+#define __NFIECC_H__
-+
-+enum nfiecc_mode {
-+	ECC_DMA_MODE,
-+	ECC_NFI_MODE,
-+	ECC_PIO_MODE
-+};
-+
-+enum nfiecc_operation {
-+	ECC_ENCODE,
-+	ECC_DECODE
-+};
-+
-+enum nfiecc_deccon {
-+	ECC_DEC_FER = 1,
-+	ECC_DEC_LOCATE = 2,
-+	ECC_DEC_CORRECT = 3
-+};
-+
-+struct nfiecc_resource {
-+	int ic_ver;
-+	void *dev;
-+	void *regs;
-+	int irq_id;
-+
-+};
-+
-+struct nfiecc_status {
-+	u32 corrected;
-+	u32 failed;
-+	u32 bitflips;
-+};
-+
-+struct nfiecc_caps {
-+	u32 err_mask;
-+	u32 ecc_mode_shift;
-+	u32 parity_bits;
-+	const int *ecc_strength;
-+	u32 ecc_strength_num;
-+};
-+
-+struct nfiecc_config {
-+	enum nfiecc_operation op;
-+	enum nfiecc_mode mode;
-+	enum nfiecc_deccon deccon;
-+
-+	void *dma_addr; /* DMA use only */
-+	u32 strength;
-+	u32 sectors;
-+	u32 len;
-+};
-+
-+struct nfiecc {
-+	struct nfiecc_resource res;
-+	struct nfiecc_config config;
-+	struct nfiecc_caps *caps;
-+
-+	bool ecc_irq_en;
-+	bool page_irq_en;
-+
-+	void *done;
-+
-+	int (*adjust_strength)(struct nfiecc *ecc, int strength);
-+	int (*enable)(struct nfiecc *ecc);
-+	int (*disable)(struct nfiecc *ecc);
-+
-+	int (*decode)(struct nfiecc *ecc, u8 *data);
-+	int (*encode)(struct nfiecc *ecc, u8 *data);
-+
-+	int (*decode_status)(struct nfiecc *ecc, u32 start_sector, u32 sectors);
-+	int (*correct_data)(struct nfiecc *ecc,
-+			    struct nfiecc_status *status,
-+			    u8 *data, u32 sector);
-+	int (*wait_done)(struct nfiecc *ecc);
-+
-+	int (*nfiecc_ctrl)(struct nfiecc *ecc, int cmd, void *args);
-+};
-+
-+struct nfiecc *nfiecc_init(struct nfiecc_resource *res);
-+void nfiecc_exit(struct nfiecc *ecc);
-+
-+#endif /* __NFIECC_H__ */
-diff --git a/drivers/mtd/nandx/core/nfi/nfiecc_regs.h b/drivers/mtd/nandx/core/nfi/nfiecc_regs.h
-new file mode 100644
-index 0000000000..96564cf872
---- /dev/null
-+++ b/drivers/mtd/nandx/core/nfi/nfiecc_regs.h
-@@ -0,0 +1,51 @@
-+/*
-+ * Copyright (C) 2017 MediaTek Inc.
-+ * Licensed under either
-+ *     BSD Licence, (see NOTICE for more details)
-+ *     GNU General Public License, version 2.0, (see NOTICE for more details)
-+ */
-+
-+#ifndef __NFIECC_REGS_H__
-+#define __NFIECC_REGS_H__
-+
-+#define NFIECC_ENCCON           0x000
-+/* NFIECC_DECCON has same bit define */
-+#define         ECC_OP_EN               BIT(0)
-+#define NFIECC_ENCCNFG          0x004
-+#define         ENCCNFG_MS_SHIFT        16
-+#define         ENC_BURST_EN            BIT(8)
-+#define NFIECC_ENCDIADDR        0x008
-+#define NFIECC_ENCIDLE          0x00c
-+#define NFIECC_ENCSTA           0x02c
-+#define         ENC_FSM_IDLE            1
-+#define NFIECC_ENCIRQEN         0x030
-+/* NFIECC_DECIRQEN has same bit define */
-+#define         ECC_IRQEN               BIT(0)
-+#define         ECC_PG_IRQ_SEL          BIT(1)
-+#define NFIECC_ENCIRQSTA        0x034
-+#define         ENC_IRQSTA_GEN          BIT(0)
-+#define NFIECC_PIO_DIRDY        0x080
-+#define         PIO_DI_RDY              BIT(0)
-+#define NFIECC_PIO_DI           0x084
-+#define NFIECC_DECCON           0x100
-+#define NFIECC_DECCNFG          0x104
-+#define         DEC_BURST_EN            BIT(8)
-+#define         DEC_EMPTY_EN            BIT(31)
-+#define         DEC_CON_SHIFT           12
-+#define         DECCNFG_MS_SHIFT        16
-+#define NFIECC_DECDIADDR        0x108
-+#define NFIECC_DECIDLE          0x10c
-+#define NFIECC_DECENUM(x)       (0x114 + (x) * 4)
-+#define NFIECC_DECDONE          0x11c
-+#define NFIECC_DECIRQEN         0x140
-+#define NFIECC_DECIRQSTA        0x144
-+#define         DEC_IRQSTA_GEN          BIT(0)
-+#define NFIECC_DECFSM           0x14c
-+#define         FSM_MASK                0x7f0f0f0f
-+#define         FSM_IDLE                0x01010101
-+#define NFIECC_BYPASS           0x20c
-+#define         NFIECC_BYPASS_EN        BIT(0)
-+#define NFIECC_ENCPAR(x)        (0x010 + (x) * 4)
-+#define NFIECC_DECEL(x)         (0x120 + (x) * 4)
-+
-+#endif /* __NFIECC_REGS_H__ */
-diff --git a/drivers/mtd/nandx/driver/Nandx.mk b/drivers/mtd/nandx/driver/Nandx.mk
-new file mode 100644
-index 0000000000..3fb93d37c5
---- /dev/null
-+++ b/drivers/mtd/nandx/driver/Nandx.mk
-@@ -0,0 +1,18 @@
-+#
-+# Copyright (C) 2017 MediaTek Inc.
-+# Licensed under either
-+#     BSD Licence, (see NOTICE for more details)
-+#     GNU General Public License, version 2.0, (see NOTICE for more details)
-+#
-+
-+nandx-$(NANDX_SIMULATOR_SUPPORT) += simulator/driver.c
-+
-+nandx-$(NANDX_CTP_SUPPORT) += ctp/ts_nand.c
-+nandx-$(NANDX_CTP_SUPPORT) += ctp/nand_test.c
-+nandx-header-$(NANDX_CTP_SUPPORT) += ctp/nand_test.h
-+
-+nandx-$(NANDX_BBT_SUPPORT) += bbt/bbt.c
-+nandx-$(NANDX_BROM_SUPPORT) += brom/driver.c
-+nandx-$(NANDX_KERNEL_SUPPORT) += kernel/driver.c
-+nandx-$(NANDX_LK_SUPPORT) += lk/driver.c
-+nandx-$(NANDX_UBOOT_SUPPORT) += uboot/driver.c
-diff --git a/drivers/mtd/nandx/driver/bbt/bbt.c b/drivers/mtd/nandx/driver/bbt/bbt.c
-new file mode 100644
-index 0000000000..c9d4823e09
---- /dev/null
-+++ b/drivers/mtd/nandx/driver/bbt/bbt.c
-@@ -0,0 +1,408 @@
-+/*
-+ * Copyright (C) 2017 MediaTek Inc.
-+ * Licensed under either
-+ *     BSD Licence, (see NOTICE for more details)
-+ *     GNU General Public License, version 2.0, (see NOTICE for more details)
-+ */
-+
-+#include "nandx_util.h"
-+#include "nandx_core.h"
-+#include "bbt.h"
-+
-+/* Not support: multi-chip */
-+static u8 main_bbt_pattern[] = {'B', 'b', 't', '0' };
-+static u8 mirror_bbt_pattern[] = {'1', 't', 'b', 'B' };
-+
-+static struct bbt_manager g_bbt_manager = {
-+	{	{{main_bbt_pattern, 4}, 0, BBT_INVALID_ADDR},
-+		{{mirror_bbt_pattern, 4}, 0, BBT_INVALID_ADDR}
-+	},
-+	NAND_BBT_SCAN_MAXBLOCKS, NULL
-+};
-+
-+static inline void set_bbt_mark(u8 *bbt, int block, u8 mark)
-+{
-+	int index, offset;
-+
-+	index = GET_ENTRY(block);
-+	offset = GET_POSITION(block);
-+
-+	bbt[index] &= ~(BBT_ENTRY_MASK << offset);
-+	bbt[index] |= (mark & BBT_ENTRY_MASK) << offset;
-+	pr_info("%s %d block:%d, bbt[%d]:0x%x, offset:%d, mark:%d\n",
-+		__func__, __LINE__, block, index, bbt[index], offset, mark);
-+}
-+
-+static inline u8 get_bbt_mark(u8 *bbt, int block)
-+{
-+	int offset = GET_POSITION(block);
-+	int index = GET_ENTRY(block);
-+	u8 value = bbt[index];
-+
-+	return (value >> offset) & BBT_ENTRY_MASK;
-+}
-+
-+static void mark_nand_bad(struct nandx_info *nand, int block)
-+{
-+	u8 *buf;
-+
-+	buf = mem_alloc(1, nand->page_size + nand->oob_size);
-+	if (!buf) {
-+		pr_info("%s, %d, memory alloc fail, pagesize:%d, oobsize:%d\n",
-+		       __func__, __LINE__, nand->page_size, nand->oob_size);
-+		return;
-+	}
-+	memset(buf, 0, nand->page_size + nand->oob_size);
-+	nandx_erase(block * nand->block_size, nand->block_size);
-+	nandx_write(buf, buf + nand->page_size, block * nand->block_size,
-+		    nand->page_size);
-+	mem_free(buf);
-+}
-+
-+static inline bool is_bbt_data(u8 *buf, struct bbt_pattern *pattern)
-+{
-+	int i;
-+
-+	for (i = 0; i < pattern->len; i++) {
-+		if (buf[i] != pattern->data[i])
-+			return false;
-+	}
-+
-+	return true;
-+}
-+
-+static u64 get_bbt_address(struct nandx_info *nand, u8 *bbt,
-+			   u64 mirror_addr,
-+			   int max_blocks)
-+{
-+	u64 addr, end_addr;
-+	u8 mark;
-+
-+	addr = nand->total_size;
-+	end_addr = nand->total_size - nand->block_size * max_blocks;
-+
-+	while (addr > end_addr) {
-+		addr -= nand->block_size;
-+		mark = get_bbt_mark(bbt, div_down(addr, nand->block_size));
-+
-+		if (mark == BBT_BLOCK_WORN || mark == BBT_BLOCK_FACTORY_BAD)
-+			continue;
-+		if (addr != mirror_addr)
-+			return addr;
-+	}
-+
-+	return BBT_INVALID_ADDR;
-+}
-+
-+static int read_bbt(struct bbt_desc *desc, u8 *bbt, u32 len)
-+{
-+	int ret;
-+
-+	ret = nandx_read(bbt, NULL, desc->bbt_addr + desc->pattern.len + 1,
-+			 len);
-+	if (ret < 0)
-+		pr_info("nand_bbt: error reading BBT page, ret:-%x\n", ret);
-+
-+	return ret;
-+}
-+
-+static void create_bbt(struct nandx_info *nand, u8 *bbt)
-+{
-+	u32 offset = 0, block = 0;
-+
-+	do {
-+		if (nandx_is_bad_block(offset)) {
-+			pr_info("Create bbt at bad block:%d\n", block);
-+			set_bbt_mark(bbt, block, BBT_BLOCK_FACTORY_BAD);
-+		}
-+		block++;
-+		offset += nand->block_size;
-+	} while (offset < nand->total_size);
-+}
-+
-+static int search_bbt(struct nandx_info *nand, struct bbt_desc *desc,
-+		      int max_blocks)
-+{
-+	u64 addr, end_addr;
-+	u8 *buf;
-+	int ret;
-+
-+	buf = mem_alloc(1, nand->page_size);
-+	if (!buf) {
-+		pr_info("%s, %d, mem alloc fail!!! len:%d\n",
-+		       __func__, __LINE__, nand->page_size);
-+		return -ENOMEM;
-+	}
-+
-+	addr = nand->total_size;
-+	end_addr = nand->total_size - max_blocks * nand->block_size;
-+	while (addr > end_addr) {
-+		addr -= nand->block_size;
-+
-+		nandx_read(buf, NULL, addr, nand->page_size);
-+
-+		if (is_bbt_data(buf, &desc->pattern)) {
-+			desc->bbt_addr = addr;
-+			desc->version = buf[desc->pattern.len];
-+			pr_info("BBT is found at addr 0x%llx, version %d\n",
-+				desc->bbt_addr, desc->version);
-+			ret = 0;
-+			break;
-+		}
-+		ret = -EFAULT;
-+	}
-+
-+	mem_free(buf);
-+	return ret;
-+}
-+
-+static int save_bbt(struct nandx_info *nand, struct bbt_desc *desc,
-+		    u8 *bbt)
-+{
-+	u32 page_size_mask, total_block;
-+	int write_len;
-+	u8 *buf;
-+	int ret;
-+
-+	ret = nandx_erase(desc->bbt_addr, nand->block_size);
-+	if (ret) {
-+		pr_info("erase addr 0x%llx fail !!!, ret %d\n",
-+			desc->bbt_addr, ret);
-+		return ret;
-+	}
-+
-+	total_block = div_down(nand->total_size, nand->block_size);
-+	write_len = GET_BBT_LENGTH(total_block) + desc->pattern.len + 1;
-+	page_size_mask = nand->page_size - 1;
-+	write_len = (write_len + page_size_mask) & (~page_size_mask);
-+
-+	buf = (u8 *)mem_alloc(1, write_len);
-+	if (!buf) {
-+		pr_info("%s, %d, mem alloc fail!!! len:%d\n",
-+		       __func__, __LINE__, write_len);
-+		return -ENOMEM;
-+	}
-+	memset(buf, 0xFF, write_len);
-+
-+	memcpy(buf, desc->pattern.data, desc->pattern.len);
-+	buf[desc->pattern.len] = desc->version;
-+
-+	memcpy(buf + desc->pattern.len + 1, bbt, GET_BBT_LENGTH(total_block));
-+
-+	ret = nandx_write(buf, NULL, desc->bbt_addr, write_len);
-+
-+	if (ret)
-+		pr_info("nandx_write fail(%d), offset:0x%llx, len(%d)\n",
-+		       ret, desc->bbt_addr, write_len);
-+	mem_free(buf);
-+
-+	return ret;
-+}
-+
-+static int write_bbt(struct nandx_info *nand, struct bbt_desc *main,
-+		     struct bbt_desc *mirror, u8 *bbt, int max_blocks)
-+{
-+	int block;
-+	int ret;
-+
-+	do {
-+		if (main->bbt_addr == BBT_INVALID_ADDR) {
-+			main->bbt_addr = get_bbt_address(nand, bbt,
-+					 mirror->bbt_addr, max_blocks);
-+			if (main->bbt_addr == BBT_INVALID_ADDR)
-+				return -ENOSPC;
-+		}
-+
-+		ret = save_bbt(nand, main, bbt);
-+		if (!ret)
-+			break;
-+
-+		block = div_down(main->bbt_addr, nand->block_size);
-+		set_bbt_mark(bbt, block, BBT_BLOCK_WORN);
-+		main->version++;
-+		mark_nand_bad(nand, block);
-+		main->bbt_addr = BBT_INVALID_ADDR;
-+	} while (1);
-+
-+	return 0;
-+}
-+
-+static void mark_bbt_region(struct nandx_info *nand, u8 *bbt, int bbt_blocks)
-+{
-+	int total_block;
-+	int block;
-+	u8 mark;
-+
-+	total_block = div_down(nand->total_size, nand->block_size);
-+	block = total_block - bbt_blocks;
-+
-+	while (bbt_blocks) {
-+		mark = get_bbt_mark(bbt, block);
-+		if (mark == BBT_BLOCK_GOOD)
-+			set_bbt_mark(bbt, block, BBT_BLOCK_RESERVED);
-+		block++;
-+		bbt_blocks--;
-+	}
-+}
-+
-+static void unmark_bbt_region(struct nandx_info *nand, u8 *bbt, int bbt_blocks)
-+{
-+	int total_block;
-+	int block;
-+	u8 mark;
-+
-+	total_block = div_down(nand->total_size, nand->block_size);
-+	block = total_block - bbt_blocks;
-+
-+	while (bbt_blocks) {
-+		mark = get_bbt_mark(bbt, block);
-+		if (mark == BBT_BLOCK_RESERVED)
-+			set_bbt_mark(bbt, block, BBT_BLOCK_GOOD);
-+		block++;
-+		bbt_blocks--;
-+	}
-+}
-+
-+static int update_bbt(struct nandx_info *nand, struct bbt_desc *desc,
-+		      u8 *bbt,
-+		      int max_blocks)
-+{
-+	int ret = 0, i;
-+
-+	/* The reserved info is not stored in NAND*/
-+	unmark_bbt_region(nand, bbt, max_blocks);
-+
-+	desc[0].version++;
-+	for (i = 0; i < 2; i++) {
-+		if (i > 0)
-+			desc[i].version = desc[i - 1].version;
-+
-+		ret = write_bbt(nand, &desc[i], &desc[1 - i], bbt, max_blocks);
-+		if (ret)
-+			break;
-+	}
-+	mark_bbt_region(nand, bbt, max_blocks);
-+
-+	return ret;
-+}
-+
-+int scan_bbt(struct nandx_info *nand)
-+{
-+	struct bbt_manager *manager = &g_bbt_manager;
-+	struct bbt_desc *pdesc;
-+	int total_block, len, i;
-+	int valid_desc = 0;
-+	int ret = 0;
-+	u8 *bbt;
-+
-+	total_block = div_down(nand->total_size, nand->block_size);
-+	len = GET_BBT_LENGTH(total_block);
-+
-+	if (!manager->bbt) {
-+		manager->bbt = (u8 *)mem_alloc(1, len);
-+		if (!manager->bbt) {
-+			pr_info("%s, %d, mem alloc fail!!! len:%d\n",
-+			       __func__, __LINE__, len);
-+			return -ENOMEM;
-+		}
-+	}
-+	bbt = manager->bbt;
-+	memset(bbt, 0xFF, len);
-+
-+	/* scan bbt */
-+	for (i = 0; i < 2; i++) {
-+		pdesc = &manager->desc[i];
-+		pdesc->bbt_addr = BBT_INVALID_ADDR;
-+		pdesc->version = 0;
-+		ret = search_bbt(nand, pdesc, manager->max_blocks);
-+		if (!ret && (pdesc->bbt_addr != BBT_INVALID_ADDR))
-+			valid_desc += 1 << i;
-+	}
-+
-+	pdesc = &manager->desc[0];
-+	if ((valid_desc == 0x3) && (pdesc[0].version != pdesc[1].version))
-+		valid_desc = (pdesc[0].version > pdesc[1].version) ? 1 : 2;
-+
-+	/* read bbt */
-+	for (i = 0; i < 2; i++) {
-+		if (!(valid_desc & (1 << i)))
-+			continue;
-+		ret = read_bbt(&pdesc[i], bbt, len);
-+		if (ret) {
-+			pdesc->bbt_addr = BBT_INVALID_ADDR;
-+			pdesc->version = 0;
-+			valid_desc &= ~(1 << i);
-+		}
-+		/* If two BBT version is same, only need to read the first bbt*/
-+		if ((valid_desc == 0x3) &&
-+		    (pdesc[0].version == pdesc[1].version))
-+			break;
-+	}
-+
-+	if (!valid_desc) {
-+		create_bbt(nand, bbt);
-+		pdesc[0].version = 1;
-+		pdesc[1].version = 1;
-+	}
-+
-+	pdesc[0].version = max_t(u8, pdesc[0].version, pdesc[1].version);
-+	pdesc[1].version = pdesc[0].version;
-+
-+	for (i = 0; i < 2; i++) {
-+		if (valid_desc & (1 << i))
-+			continue;
-+
-+		ret = write_bbt(nand, &pdesc[i], &pdesc[1 - i], bbt,
-+				manager->max_blocks);
-+		if (ret) {
-+			pr_info("write bbt(%d) fail, ret:%d\n", i, ret);
-+			manager->bbt = NULL;
-+			return ret;
-+		}
-+	}
-+
-+	/* Prevent the bbt regions from erasing / writing */
-+	mark_bbt_region(nand, manager->bbt, manager->max_blocks);
-+
-+	for (i = 0; i < total_block; i++) {
-+		if (get_bbt_mark(manager->bbt, i) == BBT_BLOCK_WORN)
-+			pr_info("Checked WORN bad blk: %d\n", i);
-+		else if (get_bbt_mark(manager->bbt, i) == BBT_BLOCK_FACTORY_BAD)
-+			pr_info("Checked Factory bad blk: %d\n", i);
-+		else if (get_bbt_mark(manager->bbt, i) == BBT_BLOCK_RESERVED)
-+			pr_info("Checked Reserved blk: %d\n", i);
-+		else if (get_bbt_mark(manager->bbt, i) != BBT_BLOCK_GOOD)
-+			pr_info("Checked unknown blk: %d\n", i);
-+	}
-+
-+	return 0;
-+}
-+
-+int bbt_mark_bad(struct nandx_info *nand, off_t offset)
-+{
-+	struct bbt_manager *manager = &g_bbt_manager;
-+	int block = div_down(offset, nand->block_size);
-+	int ret = 0;
-+
-+	mark_nand_bad(nand, block);
-+
-+#if 0
-+	set_bbt_mark(manager->bbt, block, BBT_BLOCK_WORN);
-+
-+	/* Update flash-based bad block table */
-+	ret = update_bbt(nand, manager->desc, manager->bbt,
-+			 manager->max_blocks);
-+#endif
-+	pr_info("block %d, update result %d.\n", block, ret);
-+
-+	return ret;
-+}
-+
-+int bbt_is_bad(struct nandx_info *nand, off_t offset)
-+{
-+	int block;
-+
-+	block = div_down(offset, nand->block_size);
-+
-+	return get_bbt_mark(g_bbt_manager.bbt, block) != BBT_BLOCK_GOOD;
-+}
-diff --git a/drivers/mtd/nandx/driver/uboot/driver.c b/drivers/mtd/nandx/driver/uboot/driver.c
-new file mode 100644
-index 0000000000..7bd3342452
---- /dev/null
-+++ b/drivers/mtd/nandx/driver/uboot/driver.c
-@@ -0,0 +1,574 @@
-+/*
-+ * Copyright (C) 2017 MediaTek Inc.
-+ * Licensed under either
-+ *     BSD Licence, (see NOTICE for more details)
-+ *     GNU General Public License, version 2.0, (see NOTICE for more details)
-+ */
-+
-+#include <common.h>
-+#include <linux/io.h>
-+#include <dm.h>
-+#include <clk.h>
-+#include <nand.h>
-+#include <linux/iopoll.h>
-+#include <linux/delay.h>
-+#include <linux/mtd/nand.h>
-+#include <linux/mtd/mtd.h>
-+#include <linux/mtd/partitions.h>
-+#include "nandx_core.h"
-+#include "nandx_util.h"
-+#include "bbt.h"
-+
-+typedef int (*func_nandx_operation)(u8 *, u8 *, u64, size_t);
-+
-+struct nandx_clk {
-+	struct clk *nfi_clk;
-+	struct clk *ecc_clk;
-+	struct clk *snfi_clk;
-+	struct clk *snfi_clk_sel;
-+	struct clk *snfi_parent_50m;
-+};
-+
-+struct nandx_nfc {
-+	struct nandx_info info;
-+	struct nandx_clk clk;
-+	struct nfi_resource *res;
-+
-+	struct nand_chip *nand;
-+	spinlock_t lock;
-+};
-+
-+/* Default flash layout for MTK nand controller
-+ * 64Bytes oob format.
-+ */
-+static struct nand_ecclayout eccoob = {
-+	.eccbytes = 42,
-+	.eccpos = {
-+		17, 18, 19, 20, 21, 22, 23, 24, 25,
-+		26, 27, 28, 29, 30, 31, 32, 33, 34,
-+		35, 36, 37, 38, 39, 40, 41
-+	},
-+	.oobavail = 16,
-+	.oobfree = {
-+			{
-+			.offset = 0,
-+			.length = 16,
-+			},
-+	}
-+};
-+
-+static struct nandx_nfc *mtd_to_nfc(struct mtd_info *mtd)
-+{
-+	struct nand_chip *nand = mtd_to_nand(mtd);
-+
-+	return (struct nandx_nfc *)nand_get_controller_data(nand);
-+}
-+
-+static int nandx_enable_clk(struct nandx_clk *clk)
-+{
-+	int ret;
-+
-+	ret = clk_enable(clk->nfi_clk);
-+	if (ret) {
-+		pr_info("failed to enable nfi clk\n");
-+		return ret;
-+	}
-+
-+	ret = clk_enable(clk->ecc_clk);
-+	if (ret) {
-+		pr_info("failed to enable ecc clk\n");
-+		goto disable_nfi_clk;
-+	}
-+
-+	ret = clk_enable(clk->snfi_clk);
-+	if (ret) {
-+		pr_info("failed to enable snfi clk\n");
-+		goto disable_ecc_clk;
-+	}
-+
-+	ret = clk_enable(clk->snfi_clk_sel);
-+	if (ret) {
-+		pr_info("failed to enable snfi clk sel\n");
-+		goto disable_snfi_clk;
-+	}
-+
-+	ret = clk_set_parent(clk->snfi_clk_sel, clk->snfi_parent_50m);
-+	if (ret) {
-+		pr_info("failed to set snfi parent 50MHz\n");
-+		goto disable_snfi_clk;
-+	}
-+
-+	return 0;
-+
-+disable_snfi_clk:
-+	clk_disable(clk->snfi_clk);
-+disable_ecc_clk:
-+	clk_disable(clk->ecc_clk);
-+disable_nfi_clk:
-+	clk_disable(clk->nfi_clk);
-+
-+	return ret;
-+}
-+
-+static void nandx_disable_clk(struct nandx_clk *clk)
-+{
-+	clk_disable(clk->ecc_clk);
-+	clk_disable(clk->nfi_clk);
-+	clk_disable(clk->snfi_clk);
-+}
-+
-+static int mtk_nfc_ooblayout_free(struct mtd_info *mtd, int section,
-+				  struct mtd_oob_region *oob_region)
-+{
-+	struct nandx_nfc *nfc = (struct nandx_nfc *)mtd_to_nfc(mtd);
-+	u32 eccsteps;
-+
-+	eccsteps = div_down(mtd->writesize, mtd->ecc_step_size);
-+
-+	if (section >= eccsteps)
-+		return -EINVAL;
-+
-+	oob_region->length = nfc->info.fdm_reg_size - nfc->info.fdm_ecc_size;
-+	oob_region->offset = section * nfc->info.fdm_reg_size
-+		+ nfc->info.fdm_ecc_size;
-+
-+	return 0;
-+}
-+
-+static int mtk_nfc_ooblayout_ecc(struct mtd_info *mtd, int section,
-+				 struct mtd_oob_region *oob_region)
-+{
-+	struct nandx_nfc *nfc = (struct nandx_nfc *)mtd_to_nfc(mtd);
-+	u32 eccsteps;
-+
-+	if (section)
-+		return -EINVAL;
-+
-+	eccsteps = div_down(mtd->writesize, mtd->ecc_step_size);
-+	oob_region->offset = nfc->info.fdm_reg_size * eccsteps;
-+	oob_region->length = mtd->oobsize - oob_region->offset;
-+
-+	return 0;
-+}
-+
-+static const struct mtd_ooblayout_ops mtk_nfc_ooblayout_ops = {
-+	.rfree = mtk_nfc_ooblayout_free,
-+	.ecc = mtk_nfc_ooblayout_ecc,
-+};
-+
-+struct nfc_compatible {
-+	enum mtk_ic_version ic_ver;
-+
-+	u32 clock_1x;
-+	u32 *clock_2x;
-+	int clock_2x_num;
-+
-+	int min_oob_req;
-+};
-+
-+static const struct nfc_compatible nfc_compats_mt7622 = {
-+	.ic_ver = NANDX_MT7622,
-+	.clock_1x = 26000000,
-+	.clock_2x = NULL,
-+	.clock_2x_num = 8,
-+	.min_oob_req = 1,
-+};
-+
-+static const struct udevice_id ic_of_match[] = {
-+	{.compatible = "mediatek,mt7622-nfc", .data = &nfc_compats_mt7622},
-+	{}
-+};
-+
-+static int nand_operation(struct mtd_info *mtd, loff_t addr, size_t len,
-+	      size_t *retlen, uint8_t *data, uint8_t *oob, bool read)
-+{
-+	struct nandx_split64 split = {0};
-+	func_nandx_operation operation;
-+	u64 block_oobs, val, align;
-+	uint8_t *databuf, *oobbuf;
-+	struct nandx_nfc *nfc;
-+	bool readoob;
-+	int ret = 0;
-+
-+	nfc = (struct nandx_nfc *)nand_get_controller_data;
-+	spin_lock(&nfc->lock);
-+
-+	databuf = data;
-+	oobbuf = oob;
-+
-+	readoob = data ? false : true;
-+	block_oobs = div_up(mtd->erasesize, mtd->writesize) * mtd->oobavail;
-+	align = readoob ? block_oobs : mtd->erasesize;
-+
-+	operation = read ? nandx_read : nandx_write;
-+
-+	nandx_split(&split, addr, len, val, align);
-+
-+	if (split.head_len) {
-+		ret = operation((u8 *) databuf, oobbuf, addr, split.head_len);
-+
-+		if (databuf)
-+			databuf += split.head_len;
-+
-+		if (oobbuf)
-+			oobbuf += split.head_len;
-+
-+		addr += split.head_len;
-+		*retlen += split.head_len;
-+	}
-+
-+	if (split.body_len) {
-+		while (div_up(split.body_len, align)) {
-+			ret = operation((u8 *) databuf, oobbuf, addr, align);
-+
-+			if (databuf) {
-+				databuf += mtd->erasesize;
-+				split.body_len -= mtd->erasesize;
-+				*retlen += mtd->erasesize;
-+			}
-+
-+			if (oobbuf) {
-+				oobbuf += block_oobs;
-+				split.body_len -= block_oobs;
-+				*retlen += block_oobs;
-+			}
-+
-+			addr += mtd->erasesize;
-+		}
-+
-+	}
-+
-+	if (split.tail_len) {
-+		ret = operation((u8 *) databuf, oobbuf, addr, split.tail_len);
-+		*retlen += split.tail_len;
-+	}
-+
-+	spin_unlock(&nfc->lock);
-+
-+	return ret;
-+}
-+
-+static int mtk_nand_read(struct mtd_info *mtd, loff_t from, size_t len,
-+	      size_t *retlen, u_char *buf)
-+{
-+	return nand_operation(mtd, from, len, retlen, buf, NULL, true);
-+}
-+
-+static int mtk_nand_write(struct mtd_info *mtd, loff_t to, size_t len,
-+	       size_t *retlen, const u_char *buf)
-+{
-+	return nand_operation(mtd, to, len, retlen, (uint8_t *)buf,
-+		NULL, false);
-+}
-+
-+int mtk_nand_read_oob(struct mtd_info *mtd, loff_t from, struct mtd_oob_ops *ops)
-+{
-+	size_t retlen;
-+
-+	return nand_operation(mtd, from, ops->ooblen, &retlen, NULL,
-+		ops->oobbuf, true);
-+}
-+
-+int mtk_nand_write_oob(struct mtd_info *mtd, loff_t to, struct mtd_oob_ops *ops)
-+{
-+	size_t retlen;
-+
-+	return nand_operation(mtd, to, ops->ooblen, &retlen, NULL,
-+		ops->oobbuf, false);
-+}
-+
-+static int mtk_nand_erase(struct mtd_info *mtd, struct erase_info *instr)
-+{
-+	struct nandx_nfc *nfc;
-+	u64 erase_len, erase_addr;
-+	u32 block_size;
-+	int ret = 0;
-+
-+	nfc = (struct nandx_nfc *)mtd_to_nfc(mtd);
-+	block_size = nfc->info.block_size;
-+	erase_len = instr->len;
-+	erase_addr = instr->addr;
-+	spin_lock(&nfc->lock);
-+	instr->state = MTD_ERASING;
-+
-+	while (erase_len) {
-+		if (mtk_nand_is_bad(mtd, erase_addr)) {
-+			pr_info("block(0x%llx) is bad, not erase\n",
-+				erase_addr);
-+			instr->state = MTD_ERASE_FAILED;
-+			goto erase_exit;
-+		} else {
-+			ret = nandx_erase(erase_addr, block_size);
-+			if (ret < 0) {
-+				instr->state = MTD_ERASE_FAILED;
-+				goto erase_exit;
-+				pr_info("erase fail at blk %llu, ret:%d\n",
-+					erase_addr, ret);
-+			}
-+		}
-+		erase_addr += block_size;
-+		erase_len -= block_size;
-+	}
-+
-+	instr->state = MTD_ERASE_DONE;
-+
-+erase_exit:
-+	ret = instr->state == MTD_ERASE_DONE ? 0 : -EIO;
-+
-+	spin_unlock(&nfc->lock);
-+	/* Do mtd call back function */
-+	if (!ret)
-+		mtd_erase_callback(instr);
-+
-+	return ret;
-+}
-+
-+int mtk_nand_is_bad(struct mtd_info *mtd, loff_t ofs)
-+{
-+	struct nandx_nfc *nfc;
-+	int ret;
-+
-+	nfc = (struct nandx_nfc *)mtd_to_nfc(mtd);
-+	spin_lock(&nfc->lock);
-+
-+	/*ret = bbt_is_bad(&nfc->info, ofs);*/
-+	ret = nandx_is_bad_block(ofs);
-+	spin_unlock(&nfc->lock);
-+
-+	if (ret) {
-+		pr_info("nand block 0x%x is bad, ret %d!\n", ofs, ret);
-+		return 1;
-+	} else {
-+		return 0;
-+	}
-+}
-+
-+int mtk_nand_mark_bad(struct mtd_info *mtd, loff_t ofs)
-+{
-+	struct nandx_nfc *nfc;
-+	int ret;
-+
-+	nfc = (struct nandx_nfc *)mtd_to_nfc(mtd);
-+	spin_lock(&nfc->lock);
-+	pr_info("%s, %d\n", __func__, __LINE__);
-+	ret = bbt_mark_bad(&nfc->info, ofs);
-+
-+	spin_unlock(&nfc->lock);
-+
-+	return ret;
-+}
-+
-+void mtk_nand_sync(struct mtd_info *mtd)
-+{
-+	nandx_sync();
-+}
-+
-+static struct mtd_info *mtd_info_create(struct udevice *pdev,
-+		struct nandx_nfc *nfc, struct nand_chip *nand)
-+{
-+	struct mtd_info *mtd = nand_to_mtd(nand);
-+	int ret;
-+
-+	nand_set_controller_data(nand, nfc);
-+
-+	nand->flash_node = dev_of_offset(pdev);
-+	nand->ecc.layout = &eccoob;
-+
-+	ret = nandx_ioctl(CORE_CTRL_NAND_INFO, &nfc->info);
-+	if (ret) {
-+		pr_info("fail to get nand info (%d)!\n", ret);
-+		mem_free(mtd);
-+		return NULL;
-+	}
-+
-+	mtd->owner = THIS_MODULE;
-+
-+	mtd->name = "MTK-SNand";
-+	mtd->writesize = nfc->info.page_size;
-+	mtd->erasesize = nfc->info.block_size;
-+	mtd->oobsize = nfc->info.oob_size;
-+	mtd->size = nfc->info.total_size;
-+	mtd->type = MTD_NANDFLASH;
-+	mtd->flags = MTD_CAP_NANDFLASH;
-+	mtd->_erase = mtk_nand_erase;
-+	mtd->_read = mtk_nand_read;
-+	mtd->_write = mtk_nand_write;
-+	mtd->_read_oob = mtk_nand_read_oob;
-+	mtd->_write_oob = mtk_nand_write_oob;
-+	mtd->_sync = mtk_nand_sync;
-+	mtd->_lock = NULL;
-+	mtd->_unlock = NULL;
-+	mtd->_block_isbad = mtk_nand_is_bad;
-+	mtd->_block_markbad = mtk_nand_mark_bad;
-+	mtd->writebufsize = mtd->writesize;
-+
-+	mtd_set_ooblayout(mtd, &mtk_nfc_ooblayout_ops);
-+
-+	mtd->ecc_strength = nfc->info.ecc_strength;
-+	mtd->ecc_step_size = nfc->info.sector_size;
-+
-+	if (!mtd->bitflip_threshold)
-+		mtd->bitflip_threshold = mtd->ecc_strength;
-+
-+	return mtd;
-+}
-+
-+int board_nand_init(struct nand_chip *nand)
-+{
-+	struct udevice *dev;
-+	struct mtd_info *mtd;
-+	struct nandx_nfc *nfc;
-+	int arg = 1;
-+	int ret;
-+
-+	ret = uclass_get_device_by_driver(UCLASS_MTD,
-+					  DM_GET_DRIVER(mtk_snand_drv),
-+					  &dev);
-+	if (ret) {
-+		pr_err("Failed to get mtk_nand_drv. (error %d)\n", ret);
-+		return ret;
-+	}
-+
-+	nfc = dev_get_priv(dev);
-+
-+	ret = nandx_enable_clk(&nfc->clk);
-+	if (ret) {
-+		pr_err("failed to enable nfi clk (error %d)\n", ret);
-+		return ret;
-+	}
-+
-+	ret = nandx_init(nfc->res);
-+	if (ret) {
-+		pr_err("nandx init error (%d)!\n", ret);
-+		goto disable_clk;
-+	}
-+
-+	arg = 1;
-+	nandx_ioctl(NFI_CTRL_DMA, &arg);
-+	nandx_ioctl(NFI_CTRL_ECC, &arg);
-+
-+#ifdef NANDX_UNIT_TEST
-+	nandx_unit_test(0x780000, 0x800);
-+#endif
-+
-+	mtd = mtd_info_create(dev, nfc, nand);
-+	if (!mtd) {
-+		ret = -ENOMEM;
-+		goto disable_clk;
-+	}
-+
-+	spin_lock_init(&nfc->lock);
-+#if 0
-+	ret = scan_bbt(&nfc->info);
-+	if (ret) {
-+		pr_info("bbt init error (%d)!\n", ret);
-+		goto disable_clk;
-+	}
-+#endif
-+	return ret;
-+
-+disable_clk:
-+	nandx_disable_clk(&nfc->clk);
-+
-+	return ret;
-+}
-+
-+static int mtk_snand_ofdata_to_platdata(struct udevice *dev)
-+{
-+	struct nandx_nfc *nfc = dev_get_priv(dev);
-+	struct nfc_compatible *compat;
-+	struct nfi_resource *res;
-+
-+	int ret = 0;
-+
-+	res = mem_alloc(1, sizeof(struct nfi_resource));
-+	if (!res)
-+		return -ENOMEM;
-+
-+	nfc->res = res;
-+
-+	res->nfi_regs = (void *)dev_read_addr_index(dev, 0);
-+	res->ecc_regs = (void *)dev_read_addr_index(dev, 1);
-+	pr_debug("mtk snand nfi_regs:0x%x ecc_regs:0x%x\n",
-+		res->nfi_regs, res->ecc_regs);
-+
-+	compat = (struct nfc_compatible *)dev_get_driver_data(dev);
-+
-+	res->ic_ver = (enum mtk_ic_version)(compat->ic_ver);
-+	res->clock_1x = compat->clock_1x;
-+	res->clock_2x = compat->clock_2x;
-+	res->clock_2x_num = compat->clock_2x_num;
-+
-+	memset(&nfc->clk, 0, sizeof(struct nandx_clk));
-+	nfc->clk.nfi_clk =
-+	    kmalloc(sizeof(*nfc->clk.nfi_clk), GFP_KERNEL);
-+	nfc->clk.ecc_clk =
-+	    kmalloc(sizeof(*nfc->clk.ecc_clk), GFP_KERNEL);
-+	nfc->clk.snfi_clk=
-+	    kmalloc(sizeof(*nfc->clk.snfi_clk), GFP_KERNEL);
-+	nfc->clk.snfi_clk_sel =
-+	    kmalloc(sizeof(*nfc->clk.snfi_clk_sel), GFP_KERNEL);
-+	nfc->clk.snfi_parent_50m =
-+	    kmalloc(sizeof(*nfc->clk.snfi_parent_50m), GFP_KERNEL);
-+
-+	if (!nfc->clk.nfi_clk || !nfc->clk.ecc_clk || !nfc->clk.snfi_clk ||
-+		!nfc->clk.snfi_clk_sel || !nfc->clk.snfi_parent_50m) {
-+		ret = -ENOMEM;
-+		goto err;
-+	}
-+
-+	ret = clk_get_by_name(dev, "nfi_clk", nfc->clk.nfi_clk);
-+	if (IS_ERR(nfc->clk.nfi_clk)) {
-+		ret = PTR_ERR(nfc->clk.nfi_clk);
-+		goto err;
-+	}
-+
-+	ret = clk_get_by_name(dev, "ecc_clk", nfc->clk.ecc_clk);
-+	if (IS_ERR(nfc->clk.ecc_clk)) {
-+		ret = PTR_ERR(nfc->clk.ecc_clk);
-+		goto err;
-+	}
-+
-+	ret = clk_get_by_name(dev, "snfi_clk", nfc->clk.snfi_clk);
-+	if (IS_ERR(nfc->clk.snfi_clk)) {
-+		ret = PTR_ERR(nfc->clk.snfi_clk);
-+		goto err;
-+	}
-+
-+	ret = clk_get_by_name(dev, "spinfi_sel", nfc->clk.snfi_clk_sel);
-+	if (IS_ERR(nfc->clk.snfi_clk_sel)) {
-+		ret = PTR_ERR(nfc->clk.snfi_clk_sel);
-+		goto err;
-+	}
-+
-+	ret = clk_get_by_name(dev, "spinfi_parent_50m", nfc->clk.snfi_parent_50m);
-+	if (IS_ERR(nfc->clk.snfi_parent_50m))
-+		pr_info("spinfi parent 50MHz is not configed\n");
-+
-+	return 0;
-+err:
-+	if (nfc->clk.nfi_clk)
-+		kfree(nfc->clk.nfi_clk);
-+	if (nfc->clk.snfi_clk)
-+		kfree(nfc->clk.snfi_clk);
-+	if (nfc->clk.ecc_clk)
-+		kfree(nfc->clk.ecc_clk);
-+	if (nfc->clk.snfi_clk_sel)
-+		kfree(nfc->clk.snfi_clk_sel);
-+	if (nfc->clk.snfi_parent_50m)
-+		kfree(nfc->clk.snfi_parent_50m);
-+
-+	return ret;
-+}
-+
-+U_BOOT_DRIVER(mtk_snand_drv) = {
-+	.name = "mtk_snand",
-+	.id = UCLASS_MTD,
-+	.of_match = ic_of_match,
-+	.ofdata_to_platdata = mtk_snand_ofdata_to_platdata,
-+	.priv_auto_alloc_size = sizeof(struct nandx_nfc),
-+};
-+
-+MODULE_LICENSE("GPL v2");
-+MODULE_DESCRIPTION("MTK Nand Flash Controller Driver");
-+MODULE_AUTHOR("MediaTek");
-diff --git a/drivers/mtd/nandx/include/Nandx.mk b/drivers/mtd/nandx/include/Nandx.mk
-new file mode 100644
-index 0000000000..667402790e
---- /dev/null
-+++ b/drivers/mtd/nandx/include/Nandx.mk
-@@ -0,0 +1,16 @@
-+#
-+# Copyright (C) 2017 MediaTek Inc.
-+# Licensed under either
-+#     BSD Licence, (see NOTICE for more details)
-+#     GNU General Public License, version 2.0, (see NOTICE for more details)
-+#
-+
-+nandx-header-y += internal/nandx_core.h
-+nandx-header-y += internal/nandx_errno.h
-+nandx-header-y += internal/nandx_util.h
-+nandx-header-$(NANDX_BBT_SUPPORT) += internal/bbt.h
-+nandx-header-$(NANDX_SIMULATOR_SUPPORT) += simulator/nandx_os.h
-+nandx-header-$(NANDX_CTP_SUPPORT) += ctp/nandx_os.h
-+nandx-header-$(NANDX_LK_SUPPORT) += lk/nandx_os.h
-+nandx-header-$(NANDX_KERNEL_SUPPORT) += kernel/nandx_os.h
-+nandx-header-$(NANDX_UBOOT_SUPPORT) += uboot/nandx_os.h
-diff --git a/drivers/mtd/nandx/include/internal/bbt.h b/drivers/mtd/nandx/include/internal/bbt.h
-new file mode 100644
-index 0000000000..4676def1f5
---- /dev/null
-+++ b/drivers/mtd/nandx/include/internal/bbt.h
-@@ -0,0 +1,62 @@
-+/*
-+ * Copyright (C) 2017 MediaTek Inc.
-+ * Licensed under either
-+ *     BSD Licence, (see NOTICE for more details)
-+ *     GNU General Public License, version 2.0, (see NOTICE for more details)
-+ */
-+
-+#ifndef __BBT_H__
-+#define __BBT_H__
-+
-+#define BBT_BLOCK_GOOD      0x03
-+#define BBT_BLOCK_WORN      0x02
-+#define BBT_BLOCK_RESERVED      0x01
-+#define BBT_BLOCK_FACTORY_BAD   0x00
-+
-+#define BBT_INVALID_ADDR 0
-+/* The maximum number of blocks to scan for a bbt */
-+#define NAND_BBT_SCAN_MAXBLOCKS 4
-+#define NAND_BBT_USE_FLASH  0x00020000
-+#define NAND_BBT_NO_OOB     0x00040000
-+
-+/* Search good / bad pattern on the first and the second page */
-+#define NAND_BBT_SCAN2NDPAGE    0x00008000
-+/* Search good / bad pattern on the last page of the eraseblock */
-+#define NAND_BBT_SCANLASTPAGE   0x00010000
-+
-+#define NAND_DRAM_BUF_DATABUF_ADDR  (NAND_BUF_ADDR)
-+
-+struct bbt_pattern {
-+	u8 *data;
-+	int len;
-+};
-+
-+struct bbt_desc {
-+	struct bbt_pattern pattern;
-+	u8 version;
-+	u64 bbt_addr;/*0: invalid value; otherwise, valid value*/
-+};
-+
-+struct bbt_manager {
-+	/* main bbt descriptor and mirror descriptor */
-+	struct bbt_desc desc[2];/* 0: main bbt; 1: mirror bbt */
-+	int max_blocks;
-+	u8 *bbt;
-+};
-+
-+#define BBT_ENTRY_MASK      0x03
-+#define BBT_ENTRY_SHIFT     2
-+
-+#define GET_BBT_LENGTH(blocks) (blocks >> 2)
-+#define GET_ENTRY(block) ((block) >> BBT_ENTRY_SHIFT)
-+#define GET_POSITION(block) (((block) & BBT_ENTRY_MASK) * 2)
-+#define GET_MARK_VALUE(block, mark) \
-+	(((mark) & BBT_ENTRY_MASK) << GET_POSITION(block))
-+
-+int scan_bbt(struct nandx_info *nand);
-+
-+int bbt_mark_bad(struct nandx_info *nand, off_t offset);
-+
-+int bbt_is_bad(struct nandx_info *nand, off_t offset);
-+
-+#endif /*__BBT_H__*/
-diff --git a/drivers/mtd/nandx/include/internal/nandx_core.h b/drivers/mtd/nandx/include/internal/nandx_core.h
-new file mode 100644
-index 0000000000..09aff72224
---- /dev/null
-+++ b/drivers/mtd/nandx/include/internal/nandx_core.h
-@@ -0,0 +1,250 @@
-+/*
-+ * Copyright (C) 2017 MediaTek Inc.
-+ * Licensed under either
-+ *     BSD Licence, (see NOTICE for more details)
-+ *     GNU General Public License, version 2.0, (see NOTICE for more details)
-+ */
-+
-+#ifndef __NANDX_CORE_H__
-+#define __NANDX_CORE_H__
-+
-+/**
-+ * mtk_ic_version - indicates specifical IC, IP need this to load some info
-+ */
-+enum mtk_ic_version {
-+	NANDX_MT7622,
-+};
-+
-+/**
-+ * nandx_ioctl_cmd - operations supported by nandx
-+ *
-+ * @NFI_CTRL_DMA dma enable or not
-+ * @NFI_CTRL_NFI_MODE customer/read/program/erase...
-+ * @NFI_CTRL_ECC ecc enable or not
-+ * @NFI_CTRL_ECC_MODE nfi/dma/pio
-+ * @CHIP_CTRL_DRIVE_STRENGTH enum chip_ctrl_drive_strength
-+ */
-+enum nandx_ctrl_cmd {
-+	CORE_CTRL_NAND_INFO,
-+
-+	NFI_CTRL_DMA,
-+	NFI_CTRL_NFI_MODE,
-+	NFI_CTRL_AUTOFORMAT,
-+	NFI_CTRL_NFI_IRQ,
-+	NFI_CTRL_PAGE_IRQ,
-+	NFI_CTRL_RANDOMIZE,
-+	NFI_CTRL_BAD_MARK_SWAP,
-+
-+	NFI_CTRL_ECC,
-+	NFI_CTRL_ECC_MODE,
-+	NFI_CTRL_ECC_CLOCK,
-+	NFI_CTRL_ECC_IRQ,
-+	NFI_CTRL_ECC_PAGE_IRQ,
-+	NFI_CTRL_ECC_DECODE_MODE,
-+
-+	SNFI_CTRL_OP_MODE,
-+	SNFI_CTRL_RX_MODE,
-+	SNFI_CTRL_TX_MODE,
-+	SNFI_CTRL_DELAY_MODE,
-+
-+	CHIP_CTRL_OPS_CACHE,
-+	CHIP_CTRL_OPS_MULTI,
-+	CHIP_CTRL_PSLC_MODE,
-+	CHIP_CTRL_DRIVE_STRENGTH,
-+	CHIP_CTRL_DDR_MODE,
-+	CHIP_CTRL_ONDIE_ECC,
-+	CHIP_CTRL_TIMING_MODE
-+};
-+
-+enum snfi_ctrl_op_mode {
-+	SNFI_CUSTOM_MODE,
-+	SNFI_AUTO_MODE,
-+	SNFI_MAC_MODE
-+};
-+
-+enum snfi_ctrl_rx_mode {
-+	SNFI_RX_111,
-+	SNFI_RX_112,
-+	SNFI_RX_114,
-+	SNFI_RX_122,
-+	SNFI_RX_144
-+};
-+
-+enum snfi_ctrl_tx_mode {
-+	SNFI_TX_111,
-+	SNFI_TX_114,
-+};
-+
-+enum chip_ctrl_drive_strength {
-+	CHIP_DRIVE_NORMAL,
-+	CHIP_DRIVE_HIGH,
-+	CHIP_DRIVE_MIDDLE,
-+	CHIP_DRIVE_LOW
-+};
-+
-+enum chip_ctrl_timing_mode {
-+	CHIP_TIMING_MODE0,
-+	CHIP_TIMING_MODE1,
-+	CHIP_TIMING_MODE2,
-+	CHIP_TIMING_MODE3,
-+	CHIP_TIMING_MODE4,
-+	CHIP_TIMING_MODE5,
-+};
-+
-+/**
-+ * nandx_info - basic information
-+ */
-+struct nandx_info {
-+	u32 max_io_count;
-+	u32 min_write_pages;
-+	u32 plane_num;
-+	u32 oob_size;
-+	u32 page_parity_size;
-+	u32 page_size;
-+	u32 block_size;
-+	u64 total_size;
-+	u32 fdm_reg_size;
-+	u32 fdm_ecc_size;
-+	u32 ecc_strength;
-+	u32 sector_size;
-+};
-+
-+/**
-+ * nfi_resource - the resource needed by nfi & ecc to do initialization
-+ */
-+struct nfi_resource {
-+	int ic_ver;
-+	void *dev;
-+
-+	void *ecc_regs;
-+	int ecc_irq_id;
-+
-+	void *nfi_regs;
-+	int nfi_irq_id;
-+
-+	u32 clock_1x;
-+	u32 *clock_2x;
-+	int clock_2x_num;
-+
-+	int min_oob_req;
-+};
-+
-+/**
-+ * nandx_init - init all related modules below
-+ *
-+ * @res: basic resource of the project
-+ *
-+ * return 0 if init success, otherwise return negative error code
-+ */
-+int nandx_init(struct nfi_resource *res);
-+
-+/**
-+ * nandx_exit - release resource those that obtained in init flow
-+ */
-+void nandx_exit(void);
-+
-+/**
-+ * nandx_read - read data from nand this function can read data and related
-+ *   oob from specifical address
-+ *   if do multi_ops, set one operation per time, and call nandx_sync at last
-+ *   in multi mode, not support page partial read
-+ *   oob not support partial read
-+ *
-+ * @data: buf to receive data from nand
-+ * @oob: buf to receive oob data from nand which related to data page
-+ *   length of @oob should oob size aligned, oob not support partial read
-+ * @offset: offset address on the whole flash
-+ * @len: the length of @data that need to read
-+ *
-+ * if read success return 0, otherwise return negative error code
-+ */
-+int nandx_read(u8 *data, u8 *oob, u64 offset, size_t len);
-+
-+/**
-+ * nandx_write -  write data to nand
-+ *   this function can write data and related oob to specifical address
-+ *   if do multi_ops, set one operation per time, and call nandx_sync at last
-+ *
-+ * @data: source data to be written to nand,
-+ *   for multi operation, the length of @data should be page size aliged
-+ * @oob: source oob which related to data page to be written to nand,
-+ *   length of @oob should oob size aligned
-+ * @offset: offset address on the whole flash, the value should be start address
-+ *   of a page
-+ * @len: the length of @data that need to write,
-+ *   for multi operation, the len should be page size aliged
-+ *
-+ * if write success return 0, otherwise return negative error code
-+ * if return value > 0, it indicates that how many pages still need to write,
-+ * and data has not been written to nand
-+ * please call nandx_sync after pages alligned $nandx_info.min_write_pages
-+ */
-+int nandx_write(u8 *data, u8 *oob, u64 offset, size_t len);
-+
-+/**
-+ * nandx_erase - erase an area of nand
-+ *   if do multi_ops, set one operation per time, and call nandx_sync at last
-+ *
-+ * @offset: offset address on the flash
-+ * @len: erase length which should be block size aligned
-+ *
-+ * if erase success return 0, otherwise return negative error code
-+ */
-+int nandx_erase(u64 offset, size_t len);
-+
-+/**
-+ * nandx_sync - sync all operations to nand
-+ *   when do multi_ops, this function will be called at last operation
-+ *   when write data, if number of pages not alligned
-+ *   by $nandx_info.min_write_pages, this interface could be called to do
-+ *   force write, 0xff will be padded to blanked pages.
-+ */
-+int nandx_sync(void);
-+
-+/**
-+ * nandx_is_bad_block - check if the block is bad
-+ *   only check the flag that marked by the flash vendor
-+ *
-+ * @offset: offset address on the whole flash
-+ *
-+ * return true if the block is bad, otherwise return false
-+ */
-+bool nandx_is_bad_block(u64 offset);
-+
-+/**
-+ * nandx_ioctl - set/get property of nand chip
-+ *
-+ * @cmd: parameter that defined in enum nandx_ioctl_cmd
-+ * @arg: operate parameter
-+ *
-+ * return 0 if operate success, otherwise return negative error code
-+ */
-+int nandx_ioctl(int cmd, void *arg);
-+
-+/**
-+ * nandx_suspend - suspend nand, and store some data
-+ *
-+ * return 0 if suspend success, otherwise return negative error code
-+ */
-+int nandx_suspend(void);
-+
-+/**
-+ * nandx_resume - resume nand, and replay some data
-+ *
-+ * return 0 if resume success, otherwise return negative error code
-+ */
-+int nandx_resume(void);
-+
-+#ifdef NANDX_UNIT_TEST
-+/**
-+ * nandx_unit_test - unit test
-+ *
-+ * @offset: offset address on the whole flash
-+ * @len: should be not larger than a block size, we only test a block per time
-+ *
-+ * return 0 if test success, otherwise return negative error code
-+ */
-+int nandx_unit_test(u64 offset, size_t len);
-+#endif
-+
-+#endif /* __NANDX_CORE_H__ */
-diff --git a/drivers/mtd/nandx/include/internal/nandx_errno.h b/drivers/mtd/nandx/include/internal/nandx_errno.h
-new file mode 100644
-index 0000000000..51fb299c03
---- /dev/null
-+++ b/drivers/mtd/nandx/include/internal/nandx_errno.h
-@@ -0,0 +1,40 @@
-+/*
-+ * Copyright (C) 2017 MediaTek Inc.
-+ * Licensed under either
-+ *     BSD Licence, (see NOTICE for more details)
-+ *     GNU General Public License, version 2.0, (see NOTICE for more details)
-+ */
-+
-+#ifndef __NANDX_ERRNO_H__
-+#define __NANDX_ERRNO_H__
-+
-+#ifndef EIO
-+#define EIO             5       /* I/O error */
-+#define ENOMEM          12      /* Out of memory */
-+#define EFAULT          14      /* Bad address */
-+#define EBUSY           16      /* Device or resource busy */
-+#define ENODEV          19      /* No such device */
-+#define EINVAL          22      /* Invalid argument */
-+#define ENOSPC          28      /* No space left on device */
-+/* Operation not supported on transport endpoint */
-+#define EOPNOTSUPP      95
-+#define ETIMEDOUT       110     /* Connection timed out */
-+#endif
-+
-+#define ENANDFLIPS      1024    /* Too many bitflips, uncorrected */
-+#define ENANDREAD       1025    /* Read fail, can't correct */
-+#define ENANDWRITE      1026    /* Write fail */
-+#define ENANDERASE      1027    /* Erase fail */
-+#define ENANDBAD        1028    /* Bad block */
-+#define ENANDWP         1029
-+
-+#define IS_NAND_ERR(err)        ((err) >= -ENANDBAD && (err) <= -ENANDFLIPS)
-+
-+#ifndef MAX_ERRNO
-+#define MAX_ERRNO       4096
-+#define ERR_PTR(errno)  ((void *)((long)errno))
-+#define PTR_ERR(ptr)    ((long)(ptr))
-+#define IS_ERR(ptr)     ((unsigned long)(ptr) > (unsigned long)-MAX_ERRNO)
-+#endif
-+
-+#endif /* __NANDX_ERRNO_H__ */
-diff --git a/drivers/mtd/nandx/include/internal/nandx_util.h b/drivers/mtd/nandx/include/internal/nandx_util.h
-new file mode 100644
-index 0000000000..1990b000ee
---- /dev/null
-+++ b/drivers/mtd/nandx/include/internal/nandx_util.h
-@@ -0,0 +1,221 @@
-+/*
-+ * Copyright (C) 2017 MediaTek Inc.
-+ * Licensed under either
-+ *     BSD Licence, (see NOTICE for more details)
-+ *     GNU General Public License, version 2.0, (see NOTICE for more details)
-+ */
-+
-+#ifndef __NANDX_UTIL_H__
-+#define __NANDX_UTIL_H__
-+
-+typedef unsigned char u8;
-+typedef unsigned short u16;
-+typedef unsigned int u32;
-+typedef unsigned long long u64;
-+
-+enum nand_irq_return {
-+	NAND_IRQ_NONE,
-+	NAND_IRQ_HANDLED,
-+};
-+
-+enum nand_dma_operation {
-+	NDMA_FROM_DEV,
-+	NDMA_TO_DEV,
-+};
-+
-+
-+/*
-+ * Compatible function
-+ * used for preloader/lk/kernel environment
-+ */
-+#include "nandx_os.h"
-+#include "nandx_errno.h"
-+
-+#ifndef BIT
-+#define BIT(a)                  (1 << (a))
-+#endif
-+
-+#ifndef min_t
-+#define min_t(type, x, y) ({                    \
-+	type __min1 = (x);                      \
-+	type __min2 = (y);                      \
-+	__min1 < __min2 ? __min1 : __min2; })
-+
-+#define max_t(type, x, y) ({                    \
-+	type __max1 = (x);                      \
-+	type __max2 = (y);                      \
-+	__max1 > __max2 ? __max1 : __max2; })
-+#endif
-+
-+#ifndef GENMASK
-+#define GENMASK(h, l) \
-+	(((~0UL) << (l)) & (~0UL >> ((sizeof(unsigned long) * 8) - 1 - (h))))
-+#endif
-+
-+#ifndef __weak
-+#define __weak __attribute__((__weak__))
-+#endif
-+
-+#ifndef __packed
-+#define __packed __attribute__((__packed__))
-+#endif
-+
-+#ifndef KB
-+#define KB(x)   ((x) << 10)
-+#define MB(x)   (KB(x) << 10)
-+#define GB(x)   (MB(x) << 10)
-+#endif
-+
-+#ifndef offsetof
-+#define offsetof(type, member) ((size_t)&((type *)0)->member)
-+#endif
-+
-+#ifndef NULL
-+#define NULL (void *)0
-+#endif
-+static inline u32 nandx_popcount(u32 x)
-+{
-+	x = (x & 0x55555555) + ((x >> 1) & 0x55555555);
-+	x = (x & 0x33333333) + ((x >> 2) & 0x33333333);
-+	x = (x & 0x0F0F0F0F) + ((x >> 4) & 0x0F0F0F0F);
-+	x = (x & 0x00FF00FF) + ((x >> 8) & 0x00FF00FF);
-+	x = (x & 0x0000FFFF) + ((x >> 16) & 0x0000FFFF);
-+
-+	return x;
-+}
-+
-+#ifndef zero_popcount
-+#define zero_popcount(x) (32 - nandx_popcount(x))
-+#endif
-+
-+#ifndef do_div
-+#define do_div(n, base) \
-+	({ \
-+		u32 __base = (base); \
-+		u32 __rem; \
-+		__rem = ((u64)(n)) % __base; \
-+		(n) = ((u64)(n)) / __base; \
-+		__rem; \
-+	})
-+#endif
-+
-+#define div_up(x, y) \
-+	({ \
-+		u64 __temp = ((x) + (y) - 1); \
-+		do_div(__temp, (y)); \
-+		__temp; \
-+	})
-+
-+#define div_down(x, y) \
-+	({ \
-+		u64 __temp = (x); \
-+		do_div(__temp, (y)); \
-+		__temp; \
-+	})
-+
-+#define div_round_up(x, y)      (div_up(x, y) * (y))
-+#define div_round_down(x, y)    (div_down(x, y) * (y))
-+
-+#define reminder(x, y) \
-+	({ \
-+		u64 __temp = (x); \
-+		do_div(__temp, (y)); \
-+	})
-+
-+#ifndef round_up
-+#define round_up(x, y)          ((((x) - 1) | ((y) - 1)) + 1)
-+#define round_down(x, y)        ((x) & ~((y) - 1))
-+#endif
-+
-+#ifndef readx_poll_timeout_atomic
-+#define readx_poll_timeout_atomic(op, addr, val, cond, delay_us, timeout_us) \
-+	({ \
-+		u64 end = get_current_time_us() + timeout_us; \
-+		for (;;) { \
-+			u64 now = get_current_time_us(); \
-+			(val) = op(addr); \
-+			if (cond) \
-+				break; \
-+			if (now > end) { \
-+				(val) = op(addr); \
-+				break; \
-+			} \
-+		} \
-+		(cond) ? 0 : -ETIMEDOUT; \
-+	})
-+
-+#define readl_poll_timeout_atomic(addr, val, cond, delay_us, timeout_us) \
-+	readx_poll_timeout_atomic(readl, addr, val, cond, delay_us, timeout_us)
-+#define readw_poll_timeout_atomic(addr, val, cond, delay_us, timeout_us) \
-+	readx_poll_timeout_atomic(readw, addr, val, cond, delay_us, timeout_us)
-+#define readb_poll_timeout_atomic(addr, val, cond, delay_us, timeout_us) \
-+	readx_poll_timeout_atomic(readb, addr, val, cond, delay_us, timeout_us)
-+#endif
-+
-+struct nandx_split64 {
-+	u64 head;
-+	size_t head_len;
-+	u64 body;
-+	size_t body_len;
-+	u64 tail;
-+	size_t tail_len;
-+};
-+
-+struct nandx_split32 {
-+	u32 head;
-+	u32 head_len;
-+	u32 body;
-+	u32 body_len;
-+	u32 tail;
-+	u32 tail_len;
-+};
-+
-+#define nandx_split(split, offset, len, val, align) \
-+	do { \
-+		(split)->head = (offset); \
-+		(val) = div_round_down((offset), (align)); \
-+		(val) = (align) - ((offset) - (val)); \
-+		if ((val) == (align)) \
-+			(split)->head_len = 0; \
-+		else if ((val) > (len)) \
-+			(split)->head_len = len; \
-+		else \
-+			(split)->head_len = val; \
-+		(split)->body = (offset) + (split)->head_len; \
-+		(split)->body_len = div_round_down((len) - \
-+						   (split)->head_len,\
-+						   (align)); \
-+		(split)->tail = (split)->body + (split)->body_len; \
-+		(split)->tail_len = (len) - (split)->head_len - \
-+				    (split)->body_len; \
-+	} while (0)
-+
-+#ifndef container_of
-+#define container_of(ptr, type, member) \
-+	({const __typeof__(((type *)0)->member) * __mptr = (ptr); \
-+		(type *)((char *)__mptr - offsetof(type, member)); })
-+#endif
-+
-+static inline u32 nandx_cpu_to_be32(u32 val)
-+{
-+	u32 temp = 1;
-+	u8 *p_temp = (u8 *)&temp;
-+
-+	if (*p_temp)
-+		return ((val & 0xff) << 24) | ((val & 0xff00) << 8) |
-+		       ((val >> 8) & 0xff00) | ((val >> 24) & 0xff);
-+
-+	return val;
-+}
-+
-+static inline void nandx_set_bits32(unsigned long addr, u32 mask,
-+				    u32 val)
-+{
-+	u32 temp = readl((void *)addr);
-+
-+	temp &= ~(mask);
-+	temp |= val;
-+	writel(temp, (void *)addr);
-+}
-+
-+#endif /* __NANDX_UTIL_H__ */
-diff --git a/drivers/mtd/nandx/include/uboot/nandx_os.h b/drivers/mtd/nandx/include/uboot/nandx_os.h
-new file mode 100644
-index 0000000000..8ea53378bf
---- /dev/null
-+++ b/drivers/mtd/nandx/include/uboot/nandx_os.h
-@@ -0,0 +1,78 @@
-+/*
-+ * Copyright (C) 2017 MediaTek Inc.
-+ * Licensed under either
-+ *     BSD Licence, (see NOTICE for more details)
-+ *     GNU General Public License, version 2.0, (see NOTICE for more details)
-+ */
-+
-+#ifndef __NANDX_OS_H__
-+#define __NANDX_OS_H__
-+
-+#include <common.h>
-+#include <dm.h>
-+#include <clk.h>
-+#include <asm/dma-mapping.h>
-+#include <linux/io.h>
-+#include <linux/err.h>
-+#include <linux/errno.h>
-+#include <linux/bitops.h>
-+#include <linux/kernel.h>
-+#include <linux/compiler-gcc.h>
-+
-+#define NANDX_BULK_IO_USE_DRAM 0
-+
-+#define nandx_event_create()     NULL
-+#define nandx_event_destroy(event)
-+#define nandx_event_complete(event)
-+#define nandx_event_init(event)
-+#define nandx_event_wait_complete(event, timeout)        true
-+
-+#define nandx_irq_register(dev, irq, irq_handler, name, data)	NULL
-+
-+static inline void *mem_alloc(u32 count, u32 size)
-+{
-+	return kmalloc(count * size, GFP_KERNEL | __GFP_ZERO);
-+}
-+
-+static inline void mem_free(void *mem)
-+{
-+	kfree(mem);
-+}
-+
-+static inline u64 get_current_time_us(void)
-+{
-+	return timer_get_us();
-+}
-+
-+static inline u32 nandx_dma_map(void *dev, void *buf, u64 len,
-+				enum nand_dma_operation op)
-+{
-+	unsigned long addr = (unsigned long)buf;
-+	u64 size;
-+
-+	size = ALIGN(len, ARCH_DMA_MINALIGN);
-+
-+	if (op == NDMA_FROM_DEV)
-+		invalidate_dcache_range(addr, addr + size);
-+	else
-+		flush_dcache_range(addr, addr + size);
-+
-+	return addr;
-+}
-+
-+static inline void nandx_dma_unmap(void *dev, void *buf, void *addr,
-+				   u64 len, enum nand_dma_operation op)
-+{
-+	u64 size;
-+
-+	size = ALIGN(len, ARCH_DMA_MINALIGN);
-+
-+	if (op != NDMA_FROM_DEV)
-+		invalidate_dcache_range((unsigned long)addr, addr + size);
-+	else
-+		flush_dcache_range((unsigned long)addr, addr + size);
-+
-+	return addr;
-+}
-+
-+#endif /* __NANDX_OS_H__ */
-diff --git a/include/configs/mt7622.h b/include/configs/mt7622.h
-index dfd506ed24..6d0c956484 100644
---- a/include/configs/mt7622.h
-+++ b/include/configs/mt7622.h
-@@ -11,6 +11,31 @@
- 
- #include <linux/sizes.h>
- 
-+/* SPI Nand */
-+#if defined(CONFIG_MTD_RAW_NAND)
-+#define CONFIG_SYS_MAX_NAND_DEVICE 1
-+#define CONFIG_SYS_NAND_BASE		0x1100d000
-+
-+#define ENV_BOOT_READ_IMAGE \
-+	"boot_rd_img=" \
-+	"nand read 0x4007ff28 0x380000 0x1400000" \
-+	";iminfo 0x4007ff28 \0"
-+
-+#define ENV_BOOT_WRITE_IMAGE \
-+	"boot_wr_img=" \
-+	"nand write 0x4007ff28 0x380000 0x1400000" \
-+	";iminfo 0x4007ff28 \0"
-+
-+#define ENV_BOOT_CMD \
-+	"mtk_boot=run boot_rd_img;bootm;\0"
-+
-+#define CONFIG_EXTRA_ENV_SETTINGS \
-+	ENV_BOOT_READ_IMAGE \
-+	ENV_BOOT_CMD \
-+	"bootcmd=run mtk_boot;\0"
-+
-+#endif
-+
- #define CONFIG_SYS_MAXARGS		8
- #define CONFIG_SYS_BOOTM_LEN		SZ_64M
- #define CONFIG_SYS_CBSIZE		SZ_1K
--- 
-2.17.1
-
diff --git a/package/boot/uboot-mediatek/patches/003-mt7622-uboot-add-dts-and-config-for-spi-nand.patch b/package/boot/uboot-mediatek/patches/003-mt7622-uboot-add-dts-and-config-for-spi-nand.patch
deleted file mode 100644
index 2c021e1c80..0000000000
--- a/package/boot/uboot-mediatek/patches/003-mt7622-uboot-add-dts-and-config-for-spi-nand.patch
+++ /dev/null
@@ -1,64 +0,0 @@
-From b1b3c3d2ce62872c8dec4a7d645af6b3c565e094 Mon Sep 17 00:00:00 2001
-From: Sam Shih <sam.shih@mediatek.com>
-Date: Mon, 20 Apr 2020 17:11:32 +0800
-Subject: [PATCH 2/3] mt7622 uboot: add dts and config for spi nand
-
-This patch add dts and config for mt7622 spi nand
-
-Signed-off-by: Xiangsheng Hou <xiangsheng.hou@mediatek.com>
----
- arch/arm/dts/mt7622-rfb.dts |  6 ++++++
- arch/arm/dts/mt7622.dtsi    | 20 ++++++++++++++++++++
- 2 files changed, 26 insertions(+)
-
-diff --git a/arch/arm/dts/mt7622-rfb.dts b/arch/arm/dts/mt7622-rfb.dts
-index f05c3fe14d..05502bddec 100644
---- a/arch/arm/dts/mt7622-rfb.dts
-+++ b/arch/arm/dts/mt7622-rfb.dts
-@@ -143,6 +143,12 @@
- 	};
- };
- 
-+&nandc {
-+	pinctrl-names = "default";
-+	pinctrl-0 = <&snfi_pins>;
-+	status = "okay";
-+};
-+
- &uart0 {
- 	pinctrl-names = "default";
- 	pinctrl-0 = <&uart0_pins>;
-diff --git a/arch/arm/dts/mt7622.dtsi b/arch/arm/dts/mt7622.dtsi
-index 1e8ec9b48b..63fdb63d4a 100644
---- a/arch/arm/dts/mt7622.dtsi
-+++ b/arch/arm/dts/mt7622.dtsi
-@@ -52,6 +52,26 @@
- 		#size-cells = <0>;
- 	};
- 
-+	nandc: nfi@1100d000 {
-+		compatible = "mediatek,mt7622-nfc";
-+		reg = <0x1100d000 0x1000>,
-+		      <0x1100e000 0x1000>;
-+		interrupts = <GIC_SPI 96 IRQ_TYPE_LEVEL_LOW>,
-+			     <GIC_SPI 95 IRQ_TYPE_LEVEL_LOW>;
-+		clocks = <&pericfg CLK_PERI_NFI_PD>,
-+			 <&pericfg CLK_PERI_NFIECC_PD>,
-+			 <&pericfg CLK_PERI_SNFI_PD>,
-+			 <&topckgen CLK_TOP_NFI_INFRA_SEL>,
-+			 <&topckgen CLK_TOP_UNIVPLL2_D8>;
-+		clock-names = "nfi_clk",
-+			      "ecc_clk",
-+			      "snfi_clk",
-+			      "spinfi_sel",
-+			      "spinfi_parent_50m";
-+		nand-ecc-mode = "hw";
-+		status = "disabled";
-+	};
-+
- 	timer {
- 		compatible = "arm,armv8-timer";
- 		interrupt-parent = <&gic>;
--- 
-2.17.1
-
diff --git a/package/boot/uboot-mediatek/patches/004-configs-enable-mtd-and-mtk_spi_nand-in-defconfig.patch b/package/boot/uboot-mediatek/patches/004-configs-enable-mtd-and-mtk_spi_nand-in-defconfig.patch
deleted file mode 100644
index cb564965c7..0000000000
--- a/package/boot/uboot-mediatek/patches/004-configs-enable-mtd-and-mtk_spi_nand-in-defconfig.patch
+++ /dev/null
@@ -1,39 +0,0 @@
-From e5745143a2984cf44fbfc0b3aedb49e57873f109 Mon Sep 17 00:00:00 2001
-From: Sam Shih <sam.shih@mediatek.com>
-Date: Mon, 20 Apr 2020 17:17:04 +0800
-Subject: [PATCH 3/3] configs: enable mtd and mtk_spi_nand in defconfig
-
-This patch enable mtk and mtk_spi_nand in mt7622_rfb defconfig
-
-Signed-off-by: Sam Shih <sam.shih@mediatek.com>
----
- configs/mt7622_rfb_defconfig | 5 +++++
- 1 file changed, 5 insertions(+)
-
-diff --git a/configs/mt7622_rfb_defconfig b/configs/mt7622_rfb_defconfig
-index 1ce6ebdfeb..816126267b 100644
---- a/configs/mt7622_rfb_defconfig
-+++ b/configs/mt7622_rfb_defconfig
-@@ -13,6 +13,7 @@ CONFIG_DEFAULT_FDT_FILE="mt7622-rfb"
- CONFIG_SYS_PROMPT="MT7622> "
- CONFIG_CMD_BOOTMENU=y
- CONFIG_CMD_MMC=y
-+CONFIG_CMD_NAND=y
- CONFIG_CMD_PCI=y
- CONFIG_CMD_SF_TEST=y
- CONFIG_CMD_PING=y
- CONFIG_CMD_SMC=y
-@@ -25,6 +26,10 @@ CONFIG_CLK=y
- CONFIG_DM_MMC=y
- CONFIG_MMC_HS200_SUPPORT=y
- CONFIG_MMC_MTK=y
-+CONFIG_MTD=y
-+CONFIG_DM_MTD=y
-+CONFIG_MTK_SPI_NAND=y
-+CONFIG_MTD_RAW_NAND=y
- CONFIG_DM_SPI_FLASH=y
- CONFIG_SPI_FLASH_EON=y
- CONFIG_SPI_FLASH_GIGADEVICE=y
--- 
-2.17.1
-
diff --git a/package/boot/uboot-mediatek/patches/005-update-bpir2-defconfig.patch b/package/boot/uboot-mediatek/patches/005-update-bpir2-defconfig.patch
deleted file mode 100644
index cc7ed89280..0000000000
--- a/package/boot/uboot-mediatek/patches/005-update-bpir2-defconfig.patch
+++ /dev/null
@@ -1,17 +0,0 @@
-diff --git a/configs/mt7623n_bpir2_defconfig b/configs/mt7623n_bpir2_defconfig
-index 6b9fbd7e22..fb2a004803 100644
---- a/configs/mt7623n_bpir2_defconfig
-+++ b/configs/mt7623n_bpir2_defconfig
-@@ -52,3 +52,13 @@ CONFIG_TIMER=y
- CONFIG_WDT_MTK=y
- CONFIG_LZMA=y
-+CONFIG_CMD_BOOTZ=y
-+CONFIG_OF_LIBFDT_OVERLAY=y
-+#enables savenenv-command
-+CONFIG_ENV_IS_IN_FAT=y
-+CONFIG_ENV_FAT_INTERFACE="mmc"
-+CONFIG_ENV_FAT_DEVICE_AND_PART=":2"
-+CONFIG_ENV_FAT_FILE="uboot.env"
-+CONFIG_CMD_ASKENV=y
-+CONFIG_ENV_SIZE=0x2000
-+CONFIG_CMD_SETEXPR=y
diff --git a/package/boot/uboot-mediatek/patches/010-no-binman.patch b/package/boot/uboot-mediatek/patches/010-no-binman.patch
deleted file mode 100644
index a2680e56fd..0000000000
--- a/package/boot/uboot-mediatek/patches/010-no-binman.patch
+++ /dev/null
@@ -1,23 +0,0 @@
---- a/Makefile	2020-10-13 13:39:06.471438591 +0800
-+++ b/Makefile	2020-10-13 13:39:39.190798462 +0800
-@@ -1725,6 +1725,10 @@
- 
- ifeq ($(CONFIG_SPL),y)
- spl/u-boot-spl-mtk.bin: spl/u-boot-spl
-+OBJCOPYFLAGS_u-boot-mtk.bin = -I binary -O binary \
-+			--pad-to=$(CONFIG_SPL_PAD_TO) --gap-fill=0xff
-+u-boot-mtk.bin: u-boot.img spl/u-boot-spl-mtk.bin FORCE
-+	$(call if_changed,pad_cat)
- else
- MKIMAGEFLAGS_u-boot-mtk.bin = -T mtk_image \
- 	-a $(CONFIG_SYS_TEXT_BASE) -e $(CONFIG_SYS_TEXT_BASE) \
---- a/arch/arm/mach-mediatek/Kconfig
-+++ b/arch/arm/mach-mediatek/Kconfig
-@@ -36,7 +36,6 @@ config TARGET_MT7629
- 	bool "MediaTek MT7629 SoC"
- 	select CPU_V7A
- 	select SPL
--	select BINMAN
- 	help
- 	  The MediaTek MT7629 is a ARM-based SoC with a dual-core Cortex-A7
- 	  including DDR3, crypto engine, 3x3 11n/ac Wi-Fi, Gigabit Ethernet,
diff --git a/package/boot/uboot-mediatek/patches/050-mt7622-enable-pstore.patch b/package/boot/uboot-mediatek/patches/050-mt7622-enable-pstore.patch
new file mode 100644
index 0000000000..42d60c3f66
--- /dev/null
+++ b/package/boot/uboot-mediatek/patches/050-mt7622-enable-pstore.patch
@@ -0,0 +1,33 @@
+--- a/arch/arm/dts/mt7622.dtsi
++++ b/arch/arm/dts/mt7622.dtsi
+@@ -37,6 +37,30 @@
+ 		};
+ 	};
+ 
++	psci {
++		compatible  = "arm,psci-1.0";
++		method      = "smc";
++	};
++
++	reserved-memory {
++		#address-cells = <2>;
++		#size-cells = <2>;
++		ranges;
++
++		/* 64 KiB reserved for ramoops/pstore */
++		ramoops@0x42ff0000 {
++			compatible = "ramoops";
++			reg = <0 0x42ff0000 0 0x10000>;
++			record-size = <0x1000>;
++		};
++
++		/* 192 KiB reserved for ARM Trusted Firmware (BL31) */
++		secmon_reserved: secmon@43000000 {
++			reg = <0 0x43000000 0 0x30000>;
++			no-map;
++		};
++	};
++
+ 	snfi: snfi@1100d000 {
+ 		compatible = "mediatek,mtk-snfi-spi";
+ 		reg = <0x1100d000 0x2000>;
diff --git a/package/boot/uboot-mediatek/patches/100-scripts-remove-dependency-on-swig.patch b/package/boot/uboot-mediatek/patches/100-scripts-remove-dependency-on-swig.patch
new file mode 100644
index 0000000000..3fcae5ac7f
--- /dev/null
+++ b/package/boot/uboot-mediatek/patches/100-scripts-remove-dependency-on-swig.patch
@@ -0,0 +1,24 @@
+From 12de602dc824bcb821287500fba831225cff5392 Mon Sep 17 00:00:00 2001
+From: David Bauer <mail@david-bauer.net>
+Date: Mon, 13 Jul 2020 23:37:37 +0200
+Subject: [PATCH 11/12] scripts: remove dependency on swig
+
+Don't build the libfdt tool, as it has a dependency on swig (which
+OpenWrt does not ship).
+
+This requires more hacks, as of-platdata generation does not work
+without it.
+
+Signed-off-by: David Bauer <mail@david-bauer.net>
+---
+ scripts/dtc/Makefile | 2 --
+ 1 file changed, 2 deletions(-)
+
+--- a/scripts/dtc/Makefile
++++ b/scripts/dtc/Makefile
+@@ -18,5 +18,3 @@ HOSTCFLAGS_dtc-parser.tab.o := -I$(src)
+ # dependencies on generated files need to be listed explicitly
+ $(obj)/dtc-lexer.lex.o: $(obj)/dtc-parser.tab.h
+ 
+-# Added for U-Boot
+-subdir-$(CONFIG_PYLIBFDT) += pylibfdt
diff --git a/package/boot/uboot-mediatek/patches/110-no-kwbimage.patch b/package/boot/uboot-mediatek/patches/110-no-kwbimage.patch
new file mode 100644
index 0000000000..d904c4d280
--- /dev/null
+++ b/package/boot/uboot-mediatek/patches/110-no-kwbimage.patch
@@ -0,0 +1,10 @@
+--- a/tools/Makefile
++++ b/tools/Makefile
+@@ -118,7 +118,6 @@ dumpimage-mkimage-objs := aisimage.o \
+ 			imximage.o \
+ 			imx8image.o \
+ 			imx8mimage.o \
+-			kwbimage.o \
+ 			lib/md5.o \
+ 			lpc32xximage.o \
+ 			mxsimage.o \
diff --git a/package/boot/uboot-mediatek/patches/120-use-xz-instead-of-lzma.patch b/package/boot/uboot-mediatek/patches/120-use-xz-instead-of-lzma.patch
new file mode 100644
index 0000000000..627b3a7839
--- /dev/null
+++ b/package/boot/uboot-mediatek/patches/120-use-xz-instead-of-lzma.patch
@@ -0,0 +1,11 @@
+--- a/Makefile
++++ b/Makefile
+@@ -1051,7 +1051,7 @@ quiet_cmd_pad_cat = CAT     $@
+ cmd_pad_cat = $(cmd_objcopy) && $(append) || { rm -f $@; false; }
+ 
+ quiet_cmd_lzma = LZMA    $@
+-cmd_lzma = lzma -c -z -k -9 $< > $@
++cmd_lzma = xz --format=lzma -c -z -k -9 $< > $@
+ 
+ cfg: u-boot.cfg
+ 
diff --git a/package/boot/uboot-mediatek/patches/200-cmd-add-imsz-and-imszb.patch b/package/boot/uboot-mediatek/patches/200-cmd-add-imsz-and-imszb.patch
new file mode 100644
index 0000000000..f45de1cc54
--- /dev/null
+++ b/package/boot/uboot-mediatek/patches/200-cmd-add-imsz-and-imszb.patch
@@ -0,0 +1,132 @@
+--- a/cmd/bootm.c
++++ b/cmd/bootm.c
+@@ -228,6 +228,65 @@ U_BOOT_CMD(
+ /* iminfo - print header info for a requested image */
+ /*******************************************************************/
+ #if defined(CONFIG_CMD_IMI)
++#define SECTOR_SHIFT 9
++static int image_totalsize(struct cmd_tbl *cmdtp, int flag, int argc,
++			   char *const argv[], short int in_blocks)
++{
++	ulong addr;
++	void *fit;
++	int bsize, tsize;
++	char buf[16];
++
++	if (argc >= 2)
++		addr = simple_strtoul(argv[1], NULL, 16);
++	else
++		addr = image_load_addr;
++
++	fit = (void *)map_sysmem(addr, 0);
++	tsize = fit_get_totalsize(fit);
++	unmap_sysmem(fit);
++	if (tsize == 0)
++		return 1;
++
++	bsize = (tsize >> SECTOR_SHIFT) + ((tsize & ((1 << SECTOR_SHIFT) - 1))?1:0);
++
++	if (!in_blocks)
++		snprintf(buf, sizeof(buf), "%x", tsize);
++	else
++		snprintf(buf, sizeof(buf), "%x", bsize);
++
++	if (argc >= 3)
++		return env_set(argv[2], buf);
++	else
++		printf("%s\n", buf);
++
++	return 0;
++}
++
++static int do_imsz(struct cmd_tbl *cmdtp, int flag, int argc,
++		     char *const argv[])
++{
++	return image_totalsize(cmdtp, flag, argc, argv, 0);
++}
++
++static int do_imszb(struct cmd_tbl *cmdtp, int flag, int argc,
++		     char *const argv[])
++{
++	return image_totalsize(cmdtp, flag, argc, argv, 1);
++}
++
++U_BOOT_CMD(
++	imsz,	CONFIG_SYS_MAXARGS,	1,	do_imsz,
++	"get image total size (in bytes)",
++	"addr [maxhdrlen] [varname]\n"
++);
++
++U_BOOT_CMD(
++	imszb,	CONFIG_SYS_MAXARGS,	1,	do_imszb,
++	"get image total size (in blocks)",
++	"addr [maxhdrlen] [varname]\n"
++);
++
+ static int do_iminfo(struct cmd_tbl *cmdtp, int flag, int argc,
+ 		     char *const argv[])
+ {
+--- a/common/image-fit.c
++++ b/common/image-fit.c
+@@ -1962,6 +1962,51 @@ static const char *fit_get_image_type_pr
+ 	return "unknown";
+ }
+ 
++size_t fit_get_totalsize(const void *fit)
++{
++	int ret, ndepth, noffset, images_noffset;
++	size_t data_size, hdrsize, img_total, max_size = 0;
++	const void *data;
++
++	ret = fdt_check_header(fit);
++	if (ret) {
++		debug("Wrong FIT format: not a flattened device tree (err=%d)\n",
++			  ret);
++		return 0;
++	}
++
++	hdrsize = fdt_totalsize(fit);
++
++	/* simple FIT with internal images */
++	if (hdrsize > 0x1000)
++		return hdrsize;
++
++	images_noffset = fdt_path_offset(fit, FIT_IMAGES_PATH);
++	if (images_noffset < 0) {
++		printf("Can't find images parent node '%s' (%s)\n",
++		FIT_IMAGES_PATH, fdt_strerror(images_noffset));
++		return 0;
++	}
++
++	for (ndepth = 0,
++	     noffset = fdt_next_node(fit, images_noffset, &ndepth);
++	     (noffset >= 0) && (ndepth > 0);
++	     noffset = fdt_next_node(fit, noffset, &ndepth)) {
++		if (ndepth == 1) {
++			ret = fit_image_get_data_and_size(fit, noffset, &data, &data_size);
++			if (ret)
++				return 0;
++
++			img_total = data_size + (data - fit);
++
++			max_size = (max_size > img_total) ? max_size : img_total;
++		}
++	}
++
++	return max_size;
++}
++
++
+ int fit_image_load(bootm_headers_t *images, ulong addr,
+ 		   const char **fit_unamep, const char **fit_uname_configp,
+ 		   int arch, int image_type, int bootstage_id,
+--- a/include/image.h
++++ b/include/image.h
+@@ -996,6 +996,7 @@ int fit_parse_subimage(const char *spec,
+ 		ulong *addr, const char **image_name);
+ 
+ int fit_get_subimage_count(const void *fit, int images_noffset);
++size_t fit_get_totalsize(const void *fit);
+ void fit_print_contents(const void *fit);
+ void fit_image_print(const void *fit, int noffset, const char *p);
+ 
diff --git a/package/boot/uboot-mediatek/patches/210-cmd-bootmenu-add-ability-to-select-item-by-shortkey.patch b/package/boot/uboot-mediatek/patches/210-cmd-bootmenu-add-ability-to-select-item-by-shortkey.patch
new file mode 100644
index 0000000000..c43b542dcb
--- /dev/null
+++ b/package/boot/uboot-mediatek/patches/210-cmd-bootmenu-add-ability-to-select-item-by-shortkey.patch
@@ -0,0 +1,192 @@
+From afea25576fc92d562b248b783cf03564eb4521da Mon Sep 17 00:00:00 2001
+From: Weijie Gao <weijie.gao@mediatek.com>
+Date: Tue, 19 Jan 2021 10:58:48 +0800
+Subject: [PATCH 12/12] cmd: bootmenu: add ability to select item by shortkey
+
+Add ability to use shortkey to select item for bootmenu command
+
+Signed-off-by: Weijie Gao <weijie.gao@mediatek.com>
+---
+ cmd/bootmenu.c | 77 +++++++++++++++++++++++++++++++++++++++++++++-----
+ 1 file changed, 70 insertions(+), 7 deletions(-)
+
+--- a/cmd/bootmenu.c
++++ b/cmd/bootmenu.c
+@@ -11,6 +11,7 @@
+ #include <menu.h>
+ #include <watchdog.h>
+ #include <malloc.h>
++#include <linux/ctype.h>
+ #include <linux/delay.h>
+ #include <linux/string.h>
+ 
+@@ -38,6 +39,7 @@ struct bootmenu_data {
+ 	int active;			/* active menu entry */
+ 	int count;			/* total count of menu entries */
+ 	struct bootmenu_entry *first;	/* first menu entry */
++	bool last_choiced;
+ };
+ 
+ enum bootmenu_key {
+@@ -46,8 +48,27 @@ enum bootmenu_key {
+ 	KEY_DOWN,
+ 	KEY_SELECT,
+ 	KEY_QUIT,
++	KEY_CHOICE,
+ };
+ 
++static const char choice_chars[] = {
++	'1', '2', '3', '4', '5', '6', '7', '8', '9',
++	'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j',
++	'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't',
++	'u', 'v', 'w', 'x', 'y', 'z'
++};
++
++static int find_choice(char choice)
++{
++	int i;
++
++	for (i = 0; i < ARRAY_SIZE(choice_chars); i++)
++		if (tolower(choice) == choice_chars[i])
++			return i;
++
++	return -1;
++}
++
+ static char *bootmenu_getoption(unsigned short int n)
+ {
+ 	char name[MAX_ENV_SIZE];
+@@ -82,7 +103,7 @@ static void bootmenu_print_entry(void *d
+ }
+ 
+ static void bootmenu_autoboot_loop(struct bootmenu_data *menu,
+-				enum bootmenu_key *key, int *esc)
++				enum bootmenu_key *key, int *esc, int *choice)
+ {
+ 	int i, c;
+ 
+@@ -115,6 +136,19 @@ static void bootmenu_autoboot_loop(struc
+ 				break;
+ 			default:
+ 				*key = KEY_NONE;
++				if (*esc)
++					break;
++
++				*choice = find_choice(c);
++				if ((*choice >= 0 &&
++				     *choice < menu->count - 1)) {
++					*key = KEY_CHOICE;
++				} else if (c == '0') {
++					*choice = menu->count - 1;
++					*key = KEY_CHOICE;
++				} else {
++					*key = KEY_NONE;
++				}
+ 				break;
+ 			}
+ 
+@@ -136,10 +170,16 @@ static void bootmenu_autoboot_loop(struc
+ }
+ 
+ static void bootmenu_loop(struct bootmenu_data *menu,
+-		enum bootmenu_key *key, int *esc)
++		enum bootmenu_key *key, int *esc, int *choice)
+ {
+ 	int c;
+ 
++	if (menu->last_choiced) {
++		menu->last_choiced = false;
++		*key = KEY_SELECT;
++		return;
++	}
++
+ 	if (*esc == 1) {
+ 		if (tstc()) {
+ 			c = getchar();
+@@ -165,6 +205,14 @@ static void bootmenu_loop(struct bootmen
+ 		if (c == '\e') {
+ 			*esc = 1;
+ 			*key = KEY_NONE;
++		} else {
++			*choice = find_choice(c);
++			if ((*choice >= 0 && *choice < menu->count - 1)) {
++				*key = KEY_CHOICE;
++			} else if (c == '0') {
++				*choice = menu->count - 1;
++				*key = KEY_CHOICE;
++			}
+ 		}
+ 		break;
+ 	case 1:
+@@ -216,16 +264,17 @@ static char *bootmenu_choice_entry(void
+ 	struct bootmenu_data *menu = data;
+ 	struct bootmenu_entry *iter;
+ 	enum bootmenu_key key = KEY_NONE;
++	int choice = -1;
+ 	int esc = 0;
+ 	int i;
+ 
+ 	while (1) {
+ 		if (menu->delay >= 0) {
+ 			/* Autoboot was not stopped */
+-			bootmenu_autoboot_loop(menu, &key, &esc);
++			bootmenu_autoboot_loop(menu, &key, &esc, &choice);
+ 		} else {
+ 			/* Some key was pressed, so autoboot was stopped */
+-			bootmenu_loop(menu, &key, &esc);
++			bootmenu_loop(menu, &key, &esc, &choice);
+ 		}
+ 
+ 		switch (key) {
+@@ -239,6 +288,12 @@ static char *bootmenu_choice_entry(void
+ 				++menu->active;
+ 			/* no menu key selected, regenerate menu */
+ 			return NULL;
++		case KEY_CHOICE:
++			menu->active = choice;
++			if (!menu->last_choiced) {
++				menu->last_choiced = true;
++				return NULL;
++			}
+ 		case KEY_SELECT:
+ 			iter = menu->first;
+ 			for (i = 0; i < menu->active; ++i)
+@@ -294,6 +349,7 @@ static struct bootmenu_data *bootmenu_cr
+ 	menu->delay = delay;
+ 	menu->active = 0;
+ 	menu->first = NULL;
++	menu->last_choiced = false;
+ 
+ 	default_str = env_get("bootmenu_default");
+ 	if (default_str)
+@@ -311,12 +367,19 @@ static struct bootmenu_data *bootmenu_cr
+ 			goto cleanup;
+ 
+ 		len = sep-option;
+-		entry->title = malloc(len + 1);
++		entry->title = malloc(len + 4);
+ 		if (!entry->title) {
+ 			free(entry);
+ 			goto cleanup;
+ 		}
+-		memcpy(entry->title, option, len);
++
++		if (i < ARRAY_SIZE(choice_chars)) {
++			len = sprintf(entry->title, "%c. %.*s", choice_chars[i],
++				      len, option);
++		} else {
++			len = sprintf(entry->title, "   %.*s", len, option);
++		}
++
+ 		entry->title[len] = 0;
+ 
+ 		len = strlen(sep + 1);
+@@ -353,7 +416,7 @@ static struct bootmenu_data *bootmenu_cr
+ 		if (!entry)
+ 			goto cleanup;
+ 
+-		entry->title = strdup("U-Boot console");
++		entry->title = strdup("0. U-Boot console");
+ 		if (!entry->title) {
+ 			free(entry);
+ 			goto cleanup;
diff --git a/package/boot/uboot-mediatek/patches/211-cmd-bootmenu-custom-title.patch b/package/boot/uboot-mediatek/patches/211-cmd-bootmenu-custom-title.patch
new file mode 100644
index 0000000000..3f98f13c6e
--- /dev/null
+++ b/package/boot/uboot-mediatek/patches/211-cmd-bootmenu-custom-title.patch
@@ -0,0 +1,32 @@
+--- a/cmd/bootmenu.c
++++ b/cmd/bootmenu.c
+@@ -39,6 +39,7 @@ struct bootmenu_data {
+ 	int active;			/* active menu entry */
+ 	int count;			/* total count of menu entries */
+ 	struct bootmenu_entry *first;	/* first menu entry */
++	char *mtitle;			/* custom menu title */
+ 	bool last_choiced;
+ };
+ 
+@@ -471,7 +472,12 @@ static void menu_display_statusline(stru
+ 	printf(ANSI_CURSOR_POSITION, 1, 1);
+ 	puts(ANSI_CLEAR_LINE);
+ 	printf(ANSI_CURSOR_POSITION, 2, 1);
+-	puts("  *** U-Boot Boot Menu ***");
++
++	if (menu->mtitle)
++		puts(menu->mtitle);
++	else
++		puts("  *** U-Boot Boot Menu ***");
++
+ 	puts(ANSI_CLEAR_LINE_TO_END);
+ 	printf(ANSI_CURSOR_POSITION, 3, 1);
+ 	puts(ANSI_CLEAR_LINE);
+@@ -525,6 +531,7 @@ static void bootmenu_show(int delay)
+ 		return;
+ 	}
+ 
++	bootmenu->mtitle = env_get("bootmenu_title");
+ 	for (iter = bootmenu->first; iter; iter = iter->next) {
+ 		if (!menu_item_add(menu, iter->key, iter))
+ 			goto cleanup;
diff --git a/package/boot/uboot-mediatek/patches/220-cmd-env-readmem.patch b/package/boot/uboot-mediatek/patches/220-cmd-env-readmem.patch
new file mode 100644
index 0000000000..530a413ef3
--- /dev/null
+++ b/package/boot/uboot-mediatek/patches/220-cmd-env-readmem.patch
@@ -0,0 +1,116 @@
+--- a/cmd/Kconfig
++++ b/cmd/Kconfig
+@@ -484,6 +484,12 @@ config CMD_ENV_EXISTS
+ 	  Check if a variable is defined in the environment for use in
+ 	  shell scripting.
+ 
++config CMD_ENV_READMEM
++	bool "env readmem"
++	default y
++	help
++	  Store memory content into environment variable.
++
+ config CMD_ENV_CALLBACK
+ 	bool "env callbacks - print callbacks and their associated variables"
+ 	help
+--- a/cmd/nvedit.c
++++ b/cmd/nvedit.c
+@@ -473,6 +473,60 @@ int do_env_ask(struct cmd_tbl *cmdtp, in
+ }
+ #endif
+ 
++#if defined(CONFIG_CMD_ENV_READMEM)
++int do_env_readmem(struct cmd_tbl *cmdtp, int flag, int argc, char *const argv[])
++{
++	char varstr[CONFIG_SYS_CBSIZE];
++	const void *buf;
++	char *local_args[4];
++	ulong addr, bytes = 6;
++	int hexdump = 0;
++
++	/*
++	 * Check the syntax:
++	 *
++	 * readmem [-b] name address [size]
++	 */
++	if (argc < 3)
++		return CMD_RET_USAGE;
++
++	local_args[0] = argv[0];
++
++	if (!strncmp(argv[1], "-b", 3))
++		hexdump = 1;
++
++	local_args[1] = argv[hexdump + 1];
++	local_args[2] = varstr;
++	local_args[3] = NULL;
++
++	addr = simple_strtoul(argv[hexdump + 2], NULL, 16);
++
++	if (!hexdump)
++		bytes = simple_strtoul(argv[hexdump + 3], NULL, 16);
++
++	if (bytes < 1)
++		return 1;
++
++	if ((hexdump * 3) * bytes >= CONFIG_SYS_CBSIZE)
++		return 1;
++
++	buf = map_sysmem(addr, bytes);
++	if (!buf)
++		return 1;
++
++	if (hexdump) {
++		sprintf(varstr, "%pM", buf);
++	} else {
++		memcpy(varstr, buf, bytes);
++		varstr[bytes] = '\0';
++	}
++	unmap_sysmem(buf);
++
++	/* Continue calling setenv code */
++	return _do_env_set(flag, 3, local_args, H_INTERACTIVE);
++}
++#endif
++
+ #if defined(CONFIG_CMD_ENV_CALLBACK)
+ static int print_static_binding(const char *var_name, const char *callback_name,
+ 				void *priv)
+@@ -1377,6 +1431,9 @@ static struct cmd_tbl cmd_env_sub[] = {
+ 	U_BOOT_CMD_MKENT(load, 1, 0, do_env_load, "", ""),
+ #endif
+ 	U_BOOT_CMD_MKENT(print, CONFIG_SYS_MAXARGS, 1, do_env_print, "", ""),
++#if defined(CONFIG_CMD_ENV_READMEM)
++	U_BOOT_CMD_MKENT(readmem, CONFIG_SYS_MAXARGS, 3, do_env_readmem, "", ""),
++#endif
+ #if defined(CONFIG_CMD_RUN)
+ 	U_BOOT_CMD_MKENT(run, CONFIG_SYS_MAXARGS, 1, do_run, "", ""),
+ #endif
+@@ -1465,6 +1522,9 @@ static char env_help_text[] =
+ #if defined(CONFIG_CMD_NVEDIT_EFI)
+ 	"env print -e [-guid guid] [-n] [name ...] - print UEFI environment\n"
+ #endif
++#if defined(CONFIG_CMD_ENV_READMEM)
++	"env readmem [-b] name address size - read variable from memory\n"
++#endif
+ #if defined(CONFIG_CMD_RUN)
+ 	"env run var [...] - run commands in an environment variable\n"
+ #endif
+@@ -1574,6 +1634,17 @@ U_BOOT_CMD(
+ );
+ #endif
+ 
++#if defined(CONFIG_CMD_ENV_READMEM)
++U_BOOT_CMD_COMPLETE(
++	readmem,	CONFIG_SYS_MAXARGS,	3,	do_env_readmem,
++	"get environment variable from memory address",
++	"name [-b] address size\n"
++	"    - store memory address to env variable\n"
++	"      \"-b\": read binary ethaddr",
++	var_complete
++);
++#endif
++
+ #if defined(CONFIG_CMD_RUN)
+ U_BOOT_CMD_COMPLETE(
+ 	run,	CONFIG_SYS_MAXARGS,	1,	do_run,
diff --git a/package/boot/uboot-mediatek/patches/230-cmd-add-pstore-check.patch b/package/boot/uboot-mediatek/patches/230-cmd-add-pstore-check.patch
new file mode 100644
index 0000000000..587245d2ab
--- /dev/null
+++ b/package/boot/uboot-mediatek/patches/230-cmd-add-pstore-check.patch
@@ -0,0 +1,78 @@
+--- a/cmd/pstore.c
++++ b/cmd/pstore.c
+@@ -207,6 +207,58 @@ static int pstore_set(struct cmd_tbl *cm
+ }
+ 
+ /**
++ * pstore_check() - Check for pstore records
++ * @cmdtp: Command data struct pointer
++ * @flag: Command flag
++ * @argc: Command-line argument count
++ * @argv: Array of command-line arguments
++ *
++ * Return: 0 if there are records in pstore, 1 otherwise
++ */
++static int pstore_check(struct cmd_tbl *cmdtp, int flag,  int argc,
++			char * const argv[])
++{
++	phys_addr_t ptr;
++	char *buffer;
++	u32 size;
++	int header_len = 0;
++	bool compressed;
++
++	if (pstore_length == 0) {
++		printf("Please set PStore configuration\n");
++		return CMD_RET_USAGE;
++	}
++
++	if (buffer_size == 0)
++		pstore_init_buffer_size();
++
++	buffer = malloc_cache_aligned(buffer_size);
++
++	ptr = pstore_addr;
++	phys_addr_t ptr_end = ptr + pstore_length - pstore_pmsg_size
++			- pstore_ftrace_size - pstore_console_size;
++
++	while (ptr < ptr_end) {
++		size = pstore_get_buffer(PERSISTENT_RAM_SIG, ptr,
++					 pstore_record_size, buffer);
++		ptr += pstore_record_size;
++
++		if (size == 0)
++			continue;
++
++		header_len = pstore_read_kmsg_hdr(buffer, &compressed);
++		if (header_len == 0)
++			continue;
++
++		free(buffer);
++		return 0;
++	}
++
++	free(buffer);
++	return 1;
++}
++
++/**
+  * pstore_print_buffer() - Print buffer
+  * @type: buffer type
+  * @buffer: buffer to print
+@@ -458,6 +510,7 @@ static int pstore_save(struct cmd_tbl *c
+ 
+ static struct cmd_tbl cmd_pstore_sub[] = {
+ 	U_BOOT_CMD_MKENT(set, 8, 0, pstore_set, "", ""),
++	U_BOOT_CMD_MKENT(check, 1, 0, pstore_check, "", ""),
+ 	U_BOOT_CMD_MKENT(display, 3, 0, pstore_display, "", ""),
+ 	U_BOOT_CMD_MKENT(save, 4, 0, pstore_save, "", ""),
+ };
+@@ -531,6 +584,8 @@ U_BOOT_CMD(pstore, 10, 0, do_pstore,
+ 	   "  'pmsg-size' is the size of the user space logs record.\n"
+ 	   "  'ecc-size' enables/disables ECC support and specifies ECC buffer size in\n"
+ 	   "  bytes (0 disables it, 1 is a special value, means 16 bytes ECC).\n"
++	   "pstore check\n"
++	   "- Returns true if there are records in pstore.\n"
+ 	   "pstore display [record-type] [nb]\n"
+ 	   "- Display existing records in pstore reserved memory. A 'record-type' can\n"
+ 	   "  be given to only display records of this kind. 'record-type' can be one\n"
diff --git a/package/boot/uboot-mediatek/patches/260-add-missing-type-u64.patch b/package/boot/uboot-mediatek/patches/260-add-missing-type-u64.patch
new file mode 100644
index 0000000000..a6204c7b69
--- /dev/null
+++ b/package/boot/uboot-mediatek/patches/260-add-missing-type-u64.patch
@@ -0,0 +1,10 @@
+--- a/include/linux/types.h
++++ b/include/linux/types.h
+@@ -1,6 +1,7 @@
+ #ifndef _LINUX_TYPES_H
+ #define _LINUX_TYPES_H
+ 
++typedef unsigned long long __u64;
+ #include <linux/posix_types.h>
+ #include <asm/types.h>
+ #include <stdbool.h>
diff --git a/package/boot/uboot-mediatek/patches/300-mt7622-generic-reset-button-ignore-env.patch b/package/boot/uboot-mediatek/patches/300-mt7622-generic-reset-button-ignore-env.patch
new file mode 100644
index 0000000000..f45462eeab
--- /dev/null
+++ b/package/boot/uboot-mediatek/patches/300-mt7622-generic-reset-button-ignore-env.patch
@@ -0,0 +1,52 @@
+--- a/board/mediatek/mt7622/mt7622_rfb.c
++++ b/board/mediatek/mt7622/mt7622_rfb.c
+@@ -6,9 +6,16 @@
+ 
+ #include <common.h>
+ #include <config.h>
++#include <dm.h>
++#include <button.h>
+ #include <env.h>
+ #include <init.h>
+ #include <asm/global_data.h>
++#include <linux/delay.h>
++
++#ifndef CONFIG_RESET_BUTTON_LABEL
++#define CONFIG_RESET_BUTTON_LABEL "reset"
++#endif
+ 
+ DECLARE_GLOBAL_DATA_PTR;
+ 
+@@ -20,7 +27,20 @@ int board_init(void)
+ 
+ int board_late_init(void)
+ {
+-	gd->env_valid = 1; //to load environment variable from persistent store
++	struct udevice *dev;
++	int ret;
++
++	if (!button_get_by_label(CONFIG_RESET_BUTTON_LABEL, &dev)) {
++		puts("reset button found\n");
++#ifdef CONFIG_RESET_BUTTON_SETTLE_DELAY
++		mdelay(CONFIG_RESET_BUTTON_SETTLE_DELAY);
++#endif
++		if (button_get_state(dev) == BUTTON_ON) {
++			puts("button pushed, resetting environment\n");
++			gd->env_valid = ENV_INVALID;
++		}
++	}
++
+ 	env_relocate();
+ 	return 0;
+ }
+--- a/board/mediatek/mt7622/Kconfig
++++ b/board/mediatek/mt7622/Kconfig
+@@ -14,4 +14,8 @@ config MTK_BROM_HEADER_INFO
+ 	string
+ 	default "media=nor"
+ 
++config RESET_BUTTON_LABEL
++	string "Button to trigger factory reset"
++	default "reset"
++
+ endif
diff --git a/package/boot/uboot-mediatek/patches/350-add-support-for-Winbond-W25Q512JV.patch b/package/boot/uboot-mediatek/patches/350-add-support-for-Winbond-W25Q512JV.patch
new file mode 100644
index 0000000000..8ad4fc412d
--- /dev/null
+++ b/package/boot/uboot-mediatek/patches/350-add-support-for-Winbond-W25Q512JV.patch
@@ -0,0 +1,11 @@
+--- a/drivers/mtd/spi/spi-nor-ids.c
++++ b/drivers/mtd/spi/spi-nor-ids.c
+@@ -353,6 +353,8 @@ const struct flash_info spi_nor_ids[] =
+ 			SPI_NOR_HAS_LOCK | SPI_NOR_HAS_TB)
+ 	},
+ 	{ INFO("w25q256", 0xef4019, 0, 64 * 1024, 512, SECT_4K | SPI_NOR_DUAL_READ | SPI_NOR_QUAD_READ) },
++	{ INFO("w25q512jv", 0xef4020, 0, 64 * 1024, 1024, SECT_4K | SPI_NOR_QUAD_READ | SPI_NOR_DUAL_READ |
++			SPI_NOR_HAS_TB | SPI_NOR_HAS_LOCK) },
+ 	{ INFO("w25m512jw", 0xef6119, 0, 64 * 1024, 1024, SECT_4K | SPI_NOR_DUAL_READ | SPI_NOR_QUAD_READ) },
+ 	{ INFO("w25m512jv", 0xef7119, 0, 64 * 1024, 1024, SECT_4K | SPI_NOR_DUAL_READ | SPI_NOR_QUAD_READ) },
+ #endif
diff --git a/package/boot/uboot-mediatek/patches/400-update-bpir2-defconfig.patch b/package/boot/uboot-mediatek/patches/400-update-bpir2-defconfig.patch
new file mode 100644
index 0000000000..67853c7026
--- /dev/null
+++ b/package/boot/uboot-mediatek/patches/400-update-bpir2-defconfig.patch
@@ -0,0 +1,302 @@
+--- a/configs/mt7623n_bpir2_defconfig
++++ b/configs/mt7623n_bpir2_defconfig
+@@ -4,52 +4,137 @@ CONFIG_ARCH_MEDIATEK=y
+ CONFIG_SYS_TEXT_BASE=0x81e00000
+ CONFIG_SYS_MALLOC_F_LEN=0x4000
+ CONFIG_NR_DRAM_BANKS=1
+-CONFIG_ENV_SIZE=0x1000
++CONFIG_ENV_SIZE=0x10000
+ CONFIG_ENV_OFFSET=0x100000
+-CONFIG_DEFAULT_DEVICE_TREE="mt7623n-bananapi-bpi-r2"
+ CONFIG_TARGET_MT7623=y
++CONFIG_DEFAULT_DEVICE_TREE="mt7623n-bananapi-bpi-r2"
++CONFIG_USE_DEFAULT_ENV_FILE=y
+ CONFIG_DISTRO_DEFAULTS=y
+ CONFIG_FIT=y
+-CONFIG_FIT_VERBOSE=y
++CONFIG_FIT_ENABLE_SHA256_SUPPORT=y
++CONFIG_LED=y
++CONFIG_LED_BLINK=y
++CONFIG_LED_GPIO=y
++CONFIG_LOGLEVEL=7
++CONFIG_LOG=y
++CONFIG_AUTOBOOT_KEYED=y
++CONFIG_AUTOBOOT_MENU_SHOW=y
++CONFIG_BOARD_LATE_INIT=y
+ CONFIG_BOOTDELAY=3
++CONFIG_BOOTP_SEND_HOSTNAME=y
+ CONFIG_DEFAULT_FDT_FILE="mt7623n-bananapi-bpi-r2.dtb"
+ CONFIG_SYS_CONSOLE_IS_IN_ENV=y
++CONFIG_DEFAULT_ENV_FILE="bananapi_bpi-r2_env"
++CONFIG_BUTTON=y
++CONFIG_BUTTON_GPIO=y
++CONFIG_RESET_BUTTON_LABEL="factory"
++CONFIG_CFB_CONSOLE_ANSI=y
++CONFIG_CMD_ENV_FLAGS=y
+ # CONFIG_DISPLAY_BOARDINFO is not set
+-CONFIG_SYS_PROMPT="U-Boot> "
++CONFIG_SYS_PROMPT="MT7623> "
+ CONFIG_CMD_BOOTMENU=y
++CONFIG_CMD_BOOTP=y
++CONFIG_CMD_BUTTON=y
++CONFIG_CMD_CACHE=y
++CONFIG_CMD_CDP=y
++CONFIG_CMD_DHCP=y
++CONFIG_CMD_DM=y
++CONFIG_CMD_DNS=y
++CONFIG_CMD_ECHO=y
++CONFIG_CMD_ENV_READMEM=y
++CONFIG_CMD_ERASEENV=y
++CONFIG_CMD_EXT4=y
++CONFIG_CMD_FAT=y
++CONFIG_CMD_FS_GENERIC=y
++CONFIG_CMD_FS_UUID=y
+ # CONFIG_CMD_ELF is not set
+ # CONFIG_CMD_XIMG is not set
+ CONFIG_CMD_GPIO=y
+-CONFIG_CMD_GPT=y
++# CONFIG_CMD_GPT is not set
++CONFIG_CMD_HASH=y
++CONFIG_CMD_ITEST=y
++CONFIG_CMD_LED=y
++CONFIG_CMD_LICENSE=y
++CONFIG_CMD_LINK_LOCAL=y
++CONFIG_CMD_MBR=y
+ CONFIG_CMD_MMC=y
+-CONFIG_CMD_READ=y
+-# CONFIG_CMD_SETEXPR is not set
++CONFIG_CMD_MTD=y
+ # CONFIG_CMD_NFS is not set
++CONFIG_CMD_PCI=y
++CONFIG_CMD_SF_TEST=y
++CONFIG_CMD_PING=y
++CONFIG_CMD_PXE=y
++CONFIG_CMD_PWM=y
++CONFIG_CMD_SMC=y
++CONFIG_CMD_TFTPBOOT=y
++CONFIG_CMD_TFTPSRV=y
++CONFIG_CMD_ASKENV=y
++CONFIG_CMD_PART=y
++CONFIG_CMD_RARP=y
++CONFIG_CMD_SATA=y
++CONFIG_CMD_SETEXPR=y
++CONFIG_CMD_SLEEP=y
++CONFIG_CMD_SNTP=y
++CONFIG_CMD_SOURCE=y
++CONFIG_CMD_STRINGS=y
++CONFIG_CMD_USB=y
++CONFIG_CMD_UUID=y
++CONFIG_CMD_MMC=y
++CONFIG_CMD_READ=y
++CONFIG_CMD_SCSI=y
++CONFIG_DISPLAY_CPUINFO=y
++CONFIG_DM_ETH=y
++CONFIG_DM_GPIO=y
++CONFIG_DM_SCSI=y
++CONFIG_DM_MMC=y
++CONFIG_DM_MTD=y
++CONFIG_DM_REGULATOR=y
++CONFIG_DM_REGULATOR_FIXED=y
++CONFIG_DM_SERIAL=y
++CONFIG_DM_REGULATOR_GPIO=y
++CONFIG_DM_USB=y
++CONFIG_DM_PCI=y
++CONFIG_DM_PWM=y
++CONFIG_AHCI=y
++CONFIG_AHCI_PCI=y
++CONFIG_SCSI_AHCI=y
++CONFIG_SCSI=y
++CONFIG_PWM_MTK=y
++CONFIG_HUSH_PARSER=y
++CONFIG_SYS_RELOC_GD_ENV_ADDR=y
+ CONFIG_ENV_OVERWRITE=y
+ CONFIG_ENV_IS_IN_MMC=y
+ CONFIG_SYS_RELOC_GD_ENV_ADDR=y
+ CONFIG_NET_RANDOM_ETHADDR=y
++CONFIG_NETCONSOLE=y
+ CONFIG_REGMAP=y
+ CONFIG_SYSCON=y
+ CONFIG_CLK=y
++CONFIG_LZMA=y
++CONFIG_MEDIATEK_ETH=y
+ # CONFIG_MMC_QUIRKS is not set
+ CONFIG_SUPPORT_EMMC_BOOT=y
+ CONFIG_MMC_HS400_SUPPORT=y
+ CONFIG_MMC_MTK=y
++CONFIG_MTK_AHCI=y
++CONFIG_MTK_POWER_DOMAIN=y
++CONFIG_MTK_SERIAL=y
++CONFIG_MTK_TIMER=y
++CONFIG_OF_LIBFDT_OVERLAY=y
++CONFIG_PARTITION_UUIDS=y
++CONFIG_PCI=y
++CONFIG_PCIE_MEDIATEK=y
++CONFIG_PHY=y
+ CONFIG_PHY_FIXED=y
+-CONFIG_DM_ETH=y
+-CONFIG_MEDIATEK_ETH=y
+ CONFIG_PINCTRL=y
+ CONFIG_PINCONF=y
+ CONFIG_PINCTRL_MT7623=y
+ CONFIG_POWER_DOMAIN=y
+-CONFIG_MTK_POWER_DOMAIN=y
+-CONFIG_DM_SERIAL=y
+-CONFIG_MTK_SERIAL=y
++CONFIG_RANDOM_UUID=y
++CONFIG_REGEX=y
+ CONFIG_SYSRESET=y
+ CONFIG_SYSRESET_WATCHDOG=y
+ CONFIG_TIMER=y
+-CONFIG_MTK_TIMER=y
++CONFIG_VERSION_VARIABLE=y
+ CONFIG_WDT_MTK=y
+-CONFIG_LZMA=y
+ # CONFIG_EFI_GRUB_ARM32_WORKAROUND is not set
+--- /dev/null
++++ b/bananapi_bpi-r2_env
+@@ -0,0 +1,70 @@
++ipaddr=192.168.0.45
++serverip=192.168.0.100
++loadaddr=0x88000000
++dtaddr=0x83f00000
++console=earlycon=uart8250,mmio32,0x11004000 console=ttyS2,115200 console=tty1
++initrd_high=0xafffffff
++part_default=3
++part_recovery=2
++bootcmd=run boot_mmc
++bootdelay=0
++bootfile=openwrt-mediatek-mt7623-bananapi_bpi-r2-initramfs-recovery.itb
++bootfile_upg=openwrt-mediatek-mt7623-bananapi_bpi-r2-squashfs-sysupgrade.itb
++bootled_pwr=bpi-r2:pio:green
++bootled_rec=bpi-r2:pio:blue
++bootmenu_confirm_return=askenv - Press ENTER to return to menu ; bootmenu 60
++bootmenu_default=0
++bootmenu_delay=0
++bootmenu_title=      [0;34m( ( ( [1;39mOpenWrt[0;34m ) ) )
++bootmenu_0=Initialize environment.=run _firstboot
++bootmenu_0d=Run default boot command.=run boot_default
++bootmenu_1=Boot system via TFTP.=run boot_tftp ; run bootmenu_confirm_return
++boot_default=if env exists flag_recover ; then else run bootcmd ; fi ; run boot_recovery ; setenv replacevol 1 ; run boot_tftp_forever
++boot_first=if button factory ; then led $bootled_rec on ; run boot_tftp_recovery ; setenv flag_recover 1 ; run boot_default ; fi ; bootmenu
++boot_tftp_forever=led bpi-r2:pio:blue on ; while true ; do run boot_tftp_recovery ; sleep 1 ; done
++boot_tftp_production=tftpboot $loadaddr $bootfile_upg && env exists replacevol && iminfo $loadaddr && run mmc_write_production ; if env exists noboot ; then else bootm $loadaddr ; fi
++boot_tftp_recovery=tftpboot $loadaddr $bootfile && env exists replacevol && iminfo $loadaddr && run mmc_write_recovery ; if env exists noboot ; then else bootm $loadaddr ; fi
++boot_tftp=tftpboot $loadaddr $bootfile && bootm $loadaddr
++boot_mmc=run boot_production ; run boot_recovery
++emmc_init=run emmc_init_bl && run emmc_init_openwrt ; env default bootcmd ; saveenv
++emmc_init_bl=run sdmmc_read_emmc_hdr && run emmc_write_hdr && run sdmmc_read_preloader && run emmc_write_preloader && run sdmmc_read_uboot && run emmc_write_uboot
++emmc_init_openwrt=run sdmmc_read_recovery && run emmc_write_recovery ; run sdmmc_read_production && run emmc_write_production
++emmc_write_hdr=mmc dev 0 0 ; mmc erase 0x0 0x2000 ; mmc write $loadaddr 0x0 0x4 ; mmc dev 0 1 ; mmc partconf 0 1 1 1 ; mmc erase 0x0 0x400 ; mmc write $loadaddr 0x0 0x4 ; mmc partconf 0 1 1 0
++emmc_write_preloader=mmc dev 0 1 ; mmc partconf 0 1 1 1 ; mmc write $loadaddr 0x4 0x100 ; mmc partconf 0 1 1 0
++emmc_write_uboot=mmc dev 0 0 ; part size mmc 0 1 part_size && part start mmc 0 1 part_addr && mmc write $loadaddr $part_addr 0x400
++emmc_write_production=mmc dev 0 0 ; iminfo $loadaddr && part start mmc 0 $part_default part_addr && part size mmc 0 $part_default part_size && run mmc_write_vol
++emmc_write_recovery=mmc dev 0 0 ; iminfo $loadaddr && part start mmc 0 $part_recovery part_addr && part size mmc 0 $part_recovery part_size && run mmc_write_vol
++emmc_read_production=mmc dev 0 0 ; part start mmc 0 $part_default part_addr && part size mmc 0 $part_default part_size && run mmc_read_vol
++emmc_read_recovery=mmc dev 0 0 ; part start mmc 0 $part_recovery part_addr && part size mmc 0 $part_recovery part_size && run mmc_read_vol
++mmc_write_production=if test "$bootedfrom" = "SD" ; then run sdmmc_write_production ; else run emmc_write_production ; fi
++mmc_write_recovery=if test "$bootedfrom" = "SD" ; run sdmmc_write_recovery ; else run emmc_write_recovery ; fi
++mmc_write_vol=imszb $loadaddr image_size && test 0x$image_size -le 0x$part_size && mmc erase 0x$part_addr 0x$part_size && mmc write $loadaddr 0x$part_addr 0x$image_size
++mmc_read_vol=mmc read $loadaddr $part_addr 0x8 && imszb $loadaddr image_size && test 0x$image_size -le 0x$part_size && mmc read $loadaddr 0x$part_addr 0x$image_size && setexpr filesize $image_size * 0x200
++reset_factory=eraseenv && reset
++sdmmc_read_emmc_hdr=mmc dev 1 && mmc read $loadaddr 0x1ff8 0x8
++sdmmc_read_preloader=mmc dev 1 && mmc read $loadaddr 0x4 0x100
++sdmmc_read_uboot=mmc dev 1 ; part start mmc 1 1 part_addr && part size mmc 1 1 part_size && mmc read $loadaddr $part_addr $part_size
++sdmmc_read_production=mmc dev 1 ; part start mmc 1 $part_default part_addr && part size mmc 1 $part_default part_size && run mmc_read_vol
++sdmmc_read_recovery=mmc dev 1 ; part start mmc 1 $part_recovery part_addr && part size mmc 1 $part_recovery part_size && run mmc_read_vol
++sdmmc_write_production=iminfo $fileaddr && mmc dev 1 && part start mmc 1 $part_default part_addr && part size mmc 1 $part_default part_size && run mmc_write_vol
++sdmmc_write_recovery=iminfo $fileaddr && mmc dev 1 && part start mmc 1 $part_recovery part_addr && part size mmc 1 $part_recovery part_size && run mmc_write_vol
++_checkbootedfrom=setenv _checkbootedfrom ; if itest.l *81dffff0 == 434d4d65 ; then setenv bootedfrom eMMC ; else setenv bootedfrom SD ; fi
++_init_env=setenv _init_env ; setenv _create_env ; saveenv ; saveenv
++_firstboot=setenv _firstboot ; led $bootled_pwr off ;led $bootled_rec on ; run _checkbootedfrom _switch_to_menu _update_bootdev _update_bootcmd _update_bootcmd2 _init_env boot_first
++_set_bootcmd_sdmmc=setenv boot_production "led $bootled_rec off ; led $bootled_pwr on ; run sdmmc_read_production && bootm $loadaddr ; led $bootled_pwr off"
++_set_bootcmd_emmc=setenv boot_production "led $bootled_rec off ; led $bootled_pwr on ; run emmc_read_production && bootm $loadaddr ; led $bootled_pwr off"
++_update_bootcmd=setenv _update_bootcmd ; if test "$bootedfrom" = "SD" ; then run _set_bootcmd_sdmmc ; else run _set_bootcmd_emmc ; fi ; setenv _set_bootcmd_sdmmc ; setenv _set_bootcmd_emmc
++_set_bootcmd2_sdmmc=setenv boot_recovery "led $bootled_pwr off ; led $bootled_rec on ; run sdmmc_read_recovery && bootm $loadaddr ; led $bootled_rec off"
++_set_bootcmd2_emmc=setenv boot_recovery "led $bootled_pwr off ; led $bootled_rec on ; run emmc_read_recovery && bootm $loadaddr ; led $bootled_rec off"
++_update_bootcmd2=setenv _update_bootcmd2 ; if test "$bootedfrom" = "SD" ; then run _set_bootcmd2_sdmmc ; else run _set_bootcmd2_emmc ; fi ; setenv _set_bootcmd2_sdmmc ; setenv _set_bootcmd2_emmc
++_update_bootdev=setenv _update_bootdev ; if test "$bootedfrom" = "SD" ; then setenv bootargs "$console root=/dev/mmcblk1p65" ; else setenv bootargs "$console root=/dev/mmcblk0p65" ; fi
++_switch_to_menu=setenv _switch_to_menu ; setenv bootdelay 3 ; setenv bootmenu_delay 3 ; setenv bootmenu_0 $bootmenu_0d ; setenv bootmenu_0d ; run _bootmenu_update_title
++_bootmenu_update_title=setenv _bootmenu_update_title ; setenv bootmenu_title "$bootmenu_title  [0;36m[$bootedfrom][0m    [33m$ver[0m" ; run _set_bm2
++_set_bm2=setenv _set_bm2 ; setenv bootmenu_2 "Boot production system from $bootedfrom.=run boot_production ; run bootmenu_confirm_return" ; run _set_bm3
++_set_bm3=setenv _set_bm3 ; setenv bootmenu_3 "Boot recovery system from $bootedfrom.=run boot_recovery ; run bootmenu_confirm_return" ; run _set_bm4
++_set_bm4=setenv _set_bm4 ; setenv bootmenu_4 "Load production system via TFTP then write to $bootedfrom.=setenv noboot 1 ; setenv replacevol 1 ; run boot_tftp_production ; setenv noboot ; setenv replacevol ; run bootmenu_confirm_return" ; run _set_bm5
++_set_bm5=setenv _set_bm5 ; setenv bootmenu_5 "Load recovery system via TFTP then write to $bootedfrom.=setenv noboot 1 ; setenv replacevol 1 ; run boot_tftp_recovery ; setenv noboot ; setenv replacevol ; run bootmenu_confirm_return" ; run _set_bm5a
++_set_bm5a=setenv _set_bm5a ; if test "$bootedfrom" = "SD" ; then run _set_bm6 ; else setenv _set_bm6 ; setenv _menu_next 6 ; fi ; run _set_bmr
++_set_bm6=setenv _set_bm6 ; setenv bootmenu_6 "[31mInstall bootloader, recovery and production to eMMC.[0m=run emmc_init ; run bootmenu_confirm_return" ; setenv _menu_next 7
++_set_bmr=setenv _set_bmr ; setenv bootmenu_${_menu_next} "Reboot.=reset" ; setexpr _menu_next ${_menu_next} + 1 ; run _set_bmf
++_set_bmf=setenv _set_bmf ; setenv bootmenu_${_menu_next} "Reset all settings to factory defaults.=run reset_factory ; reset" ; setenv _menu_next
+--- a/arch/arm/dts/mt7623n-bananapi-bpi-r2.dts
++++ b/arch/arm/dts/mt7623n-bananapi-bpi-r2.dts
+@@ -66,6 +66,15 @@
+ 			default-state = "off";
+ 		};
+ 	};
++
++	gpio-keys {
++		compatible = "gpio-keys";
++
++		factory {
++			label = "factory";
++			gpios = <&gpio 256 GPIO_ACTIVE_LOW>;
++		};
++	};
+ };
+ 
+ &eth {
+--- a/board/mediatek/mt7623/mt7623_rfb.c
++++ b/board/mediatek/mt7623/mt7623_rfb.c
+@@ -6,6 +6,17 @@
+ #include <common.h>
+ #include <mmc.h>
+ #include <asm/global_data.h>
++#include <config.h>
++#include <dm.h>
++#include <button.h>
++#include <env.h>
++#include <init.h>
++#include <asm/global_data.h>
++#include <linux/delay.h>
++
++#ifndef CONFIG_RESET_BUTTON_LABEL
++#define CONFIG_RESET_BUTTON_LABEL "reset"
++#endif
+ 
+ DECLARE_GLOBAL_DATA_PTR;
+ 
+@@ -17,6 +28,25 @@ int board_init(void)
+ 	return 0;
+ }
+ 
++int board_late_init(void)
++{
++	struct udevice *dev;
++
++	if (!button_get_by_label(CONFIG_RESET_BUTTON_LABEL, &dev)) {
++		puts("reset button found\n");
++#ifdef CONFIG_RESET_BUTTON_SETTLE_DELAY
++		mdelay(CONFIG_RESET_BUTTON_SETTLE_DELAY);
++#endif
++		if (button_get_state(dev) == BUTTON_ON) {
++			puts("button pushed, resetting environment\n");
++			gd->env_valid = ENV_INVALID;
++		}
++	}
++
++	env_relocate();
++	return 0;
++}
++
+ #ifdef CONFIG_MMC
+ int mmc_get_boot_dev(void)
+ {
+--- a/board/mediatek/mt7623/Kconfig
++++ b/board/mediatek/mt7623/Kconfig
+@@ -10,4 +10,8 @@ config MTK_BROM_HEADER_INFO
+ 	string
+ 	default "lk=1"
+ 
++config RESET_BUTTON_LABEL
++	string "Button to trigger factory reset"
++	default "reset"
++
+ endif
diff --git a/package/boot/uboot-mediatek/patches/010-update-u7623-defconfig.patch b/package/boot/uboot-mediatek/patches/401-update-u7623-defconfig.patch
similarity index 72%
rename from package/boot/uboot-mediatek/patches/010-update-u7623-defconfig.patch
rename to package/boot/uboot-mediatek/patches/401-update-u7623-defconfig.patch
index ec189f82dc..89208b4723 100644
--- a/package/boot/uboot-mediatek/patches/010-update-u7623-defconfig.patch
+++ b/package/boot/uboot-mediatek/patches/401-update-u7623-defconfig.patch
@@ -1,8 +1,6 @@
-diff --git a/configs/mt7623n_bpir2_defconfig b/configs/mt7623n_bpir2_defconfig
-index 6b9fbd7e22..fb2a004803 100644
 --- a/configs/mt7623a_unielec_u7623_02_defconfig
 +++ b/configs/mt7623a_unielec_u7623_02_defconfig
-@@ -52,3 +52,12 @@ CONFIG_TIMER=y
+@@ -51,3 +51,12 @@ CONFIG_TIMER=y
  CONFIG_MTK_TIMER=y
  CONFIG_WDT_MTK=y
  CONFIG_LZMA=y
diff --git a/package/boot/uboot-mediatek/patches/402-update-bananapi-bpi-r64-device-tree.patch b/package/boot/uboot-mediatek/patches/402-update-bananapi-bpi-r64-device-tree.patch
new file mode 100644
index 0000000000..781a685721
--- /dev/null
+++ b/package/boot/uboot-mediatek/patches/402-update-bananapi-bpi-r64-device-tree.patch
@@ -0,0 +1,71 @@
+--- a/arch/arm/dts/mt7622-bananapi-bpi-r64.dts
++++ b/arch/arm/dts/mt7622-bananapi-bpi-r64.dts
+@@ -20,6 +20,7 @@
+ 
+ 	aliases {
+ 		spi0 = &snfi;
++		ethernet0 = &eth;
+ 	};
+ 
+ 	memory@40000000 {
+@@ -27,6 +28,42 @@
+ 		reg = <0x40000000 0x40000000>;
+ 	};
+ 
++	gpio-keys {
++		compatible = "gpio-keys";
++
++		reset {
++			label = "reset";
++			gpios = <&gpio 0 GPIO_ACTIVE_LOW>;
++		};
++
++		wps {
++			label = "wps";
++			gpios = <&gpio 102 GPIO_ACTIVE_LOW>;
++		};
++	};
++
++	leds {
++		compatible = "gpio-leds";
++/*
++ *		red {
++ *			label = "bpi-r64:pio:red";
++ *			gpios = <&gpio 88 GPIO_ACTIVE_HIGH>;
++ *			default-state = "off";
++ *		};
++ */
++		green {
++			label = "bpi-r64:pio:green";
++			gpios = <&gpio 89 GPIO_ACTIVE_HIGH>;
++			default-state = "off";
++		};
++
++		blue {
++			label = "bpi-r64:pio:blue";
++			gpios = <&gpio 85 GPIO_ACTIVE_LOW>;
++			default-state = "off";
++		};
++	};
++
+ 	reg_1p8v: regulator-1p8v {
+ 		compatible = "regulator-fixed";
+ 		regulator-name = "fixed-1.8V";
+@@ -199,7 +236,7 @@
+ 	status = "okay";
+ 	bus-width = <8>;
+ 	max-frequency = <50000000>;
+-	cap-sd-highspeed;
++	cap-mmc-highspeed;
+ 	vmmc-supply = <&reg_3p3v>;
+ 	vqmmc-supply = <&reg_3p3v>;
+ 	non-removable;
+@@ -210,7 +247,7 @@
+ 	pinctrl-0 = <&mmc1_pins_default>;
+ 	status = "okay";
+ 	bus-width = <4>;
+-	max-frequency = <50000000>;
++	max-frequency = <12000000>;
+ 	cap-sd-highspeed;
+ 	r_smpl = <1>;
+ 	vmmc-supply = <&reg_3p3v>;
diff --git a/package/boot/uboot-mediatek/patches/403-add-bananapi_bpi-r64-snand.patch b/package/boot/uboot-mediatek/patches/403-add-bananapi_bpi-r64-snand.patch
new file mode 100644
index 0000000000..1dc2a84893
--- /dev/null
+++ b/package/boot/uboot-mediatek/patches/403-add-bananapi_bpi-r64-snand.patch
@@ -0,0 +1,33 @@
+--- a/arch/arm/dts/mt7622-bananapi-bpi-r64.dts
++++ b/arch/arm/dts/mt7622-bananapi-bpi-r64.dts
+@@ -19,7 +19,7 @@
+ 	};
+ 
+ 	aliases {
+-		spi0 = &snfi;
++		spi0 = &snand;
+ 		ethernet0 = &eth;
+ 	};
+ 
+@@ -205,17 +205,11 @@
+ 	};
+ };
+ 
+-&snfi {
+-	pinctrl-names = "default", "snfi";
+-	pinctrl-0 = <&snor_pins>;
+-	pinctrl-1 = <&snfi_pins>;
++&snand {
++	pinctrl-names = "default";
++	pinctrl-0 = <&snfi_pins>;
+ 	status = "okay";
+-
+-	spi-flash@0{
+-		compatible = "jedec,spi-nor";
+-		reg = <0>;
+-		u-boot,dm-pre-reloc;
+-	};
++	quad-spi;
+ };
+ 
+ &uart0 {
diff --git a/package/boot/uboot-mediatek/patches/404-add-bananapi_bpi-r64_defconfigs.patch b/package/boot/uboot-mediatek/patches/404-add-bananapi_bpi-r64_defconfigs.patch
new file mode 100644
index 0000000000..abac2e0cd1
--- /dev/null
+++ b/package/boot/uboot-mediatek/patches/404-add-bananapi_bpi-r64_defconfigs.patch
@@ -0,0 +1,655 @@
+--- /dev/null
++++ b/configs/mt7622_bananapi_bpi-r64-sdmmc_defconfig
+@@ -0,0 +1,158 @@
++CONFIG_ARM=y
++CONFIG_POSITION_INDEPENDENT=y
++CONFIG_ARCH_MEDIATEK=y
++CONFIG_TARGET_MT7622=y
++CONFIG_SYS_TEXT_BASE=0x41e00000
++CONFIG_SYS_MALLOC_F_LEN=0x4000
++CONFIG_USE_DEFAULT_ENV_FILE=y
++CONFIG_BOARD_LATE_INIT=y
++CONFIG_BOOTP_SEND_HOSTNAME=y
++CONFIG_NR_DRAM_BANKS=1
++CONFIG_DEBUG_UART_BASE=0x11002000
++CONFIG_DEBUG_UART_CLOCK=25000000
++CONFIG_DEFAULT_DEVICE_TREE="mt7622-bananapi-bpi-r64"
++CONFIG_OF_LIBFDT_OVERLAY=y
++CONFIG_DEBUG_UART=y
++CONFIG_DEFAULT_ENV_FILE="bananapi_bpi-r64-sdmmc_env"
++CONFIG_NET_RANDOM_ETHADDR=y
++CONFIG_SMBIOS_PRODUCT_NAME=""
++CONFIG_AUTOBOOT_KEYED=y
++CONFIG_BOOTDELAY=30
++CONFIG_AUTOBOOT_MENU_SHOW=y
++CONFIG_CFB_CONSOLE_ANSI=y
++CONFIG_BUTTON=y
++CONFIG_BUTTON_GPIO=y
++CONFIG_GPIO_HOG=y
++CONFIG_CMD_ENV_FLAGS=y
++CONFIG_FIT=y
++CONFIG_FIT_ENABLE_SHA256_SUPPORT=y
++CONFIG_LED=y
++CONFIG_LED_BLINK=y
++CONFIG_LED_GPIO=y
++CONFIG_LOGLEVEL=7
++CONFIG_LOG=y
++CONFIG_DEFAULT_FDT_FILE="mediatek/mt7622-bananapi-bpi-r64.dtb"
++CONFIG_SYS_PROMPT="MT7622> "
++CONFIG_CMD_BOOTMENU=y
++CONFIG_CMD_BOOTP=y
++CONFIG_CMD_BUTTON=y
++CONFIG_CMD_CACHE=y
++CONFIG_CMD_CDP=y
++CONFIG_CMD_DHCP=y
++CONFIG_CMD_DM=y
++CONFIG_CMD_DNS=y
++CONFIG_CMD_ECHO=y
++CONFIG_CMD_ENV_READMEM=y
++CONFIG_CMD_ERASEENV=y
++CONFIG_CMD_EXT4=y
++CONFIG_CMD_FAT=y
++CONFIG_CMD_FS_GENERIC=y
++CONFIG_CMD_FS_UUID=y
++CONFIG_CMD_GPIO=y
++CONFIG_CMD_GPT=y
++CONFIG_CMD_HASH=y
++CONFIG_CMD_ITEST=y
++CONFIG_CMD_LED=y
++CONFIG_CMD_LICENSE=y
++CONFIG_CMD_LINK_LOCAL=y
++# CONFIG_CMD_MBR is not set
++CONFIG_CMD_MMC=y
++CONFIG_CMD_MTD=y
++CONFIG_CMD_PCI=y
++CONFIG_CMD_SF_TEST=y
++CONFIG_CMD_PING=y
++CONFIG_CMD_PXE=y
++CONFIG_CMD_PWM=y
++CONFIG_CMD_SMC=y
++CONFIG_CMD_TFTPBOOT=y
++CONFIG_CMD_TFTPSRV=y
++CONFIG_CMD_UBI=y
++CONFIG_CMD_UBI_RENAME=y
++CONFIG_CMD_UBIFS=y
++CONFIG_CMD_ASKENV=y
++CONFIG_CMD_PART=y
++CONFIG_CMD_PSTORE=y
++CONFIG_CMD_PSTORE_MEM_ADDR=0x42ff0000
++CONFIG_CMD_RARP=y
++CONFIG_CMD_SETEXPR=y
++CONFIG_CMD_SLEEP=y
++CONFIG_CMD_SNTP=y
++CONFIG_CMD_SOURCE=y
++CONFIG_CMD_STRINGS=y
++CONFIG_CMD_USB=y
++CONFIG_CMD_UUID=y
++CONFIG_DISPLAY_CPUINFO=y
++CONFIG_DM_MMC=y
++CONFIG_DM_MTD=y
++CONFIG_DM_REGULATOR=y
++CONFIG_DM_REGULATOR_FIXED=y
++CONFIG_DM_REGULATOR_GPIO=y
++CONFIG_DM_USB=y
++CONFIG_DM_PWM=y
++CONFIG_PWM_MTK=y
++CONFIG_HUSH_PARSER=y
++CONFIG_SYS_REDUNDAND_ENVIRONMENT=y
++CONFIG_SYS_RELOC_GD_ENV_ADDR=y
++CONFIG_ENV_IS_IN_MMC=y
++CONFIG_SYS_MMC_ENV_DEV=1
++CONFIG_ENV_OFFSET=0x400000
++CONFIG_ENV_OFFSET_REDUND=0x480000
++CONFIG_ENV_SIZE=0x80000
++CONFIG_ENV_VARS_UBOOT_RUNTIME_CONFIG=y
++CONFIG_VERSION_VARIABLE=y
++CONFIG_PARTITION_UUIDS=y
++CONFIG_NETCONSOLE=y
++CONFIG_REGMAP=y
++CONFIG_SYSCON=y
++CONFIG_CLK=y
++CONFIG_DM_GPIO=y
++CONFIG_DM_SCSI=y
++CONFIG_AHCI=y
++CONFIG_AHCI_PCI=y
++CONFIG_SCSI_AHCI=y
++CONFIG_SCSI=y
++CONFIG_CMD_SCSI=y
++CONFIG_PHY=y
++CONFIG_PHY_MTK_TPHY=y
++CONFIG_PHY_FIXED=y
++CONFIG_MTK_AHCI=y
++CONFIG_DM_ETH=y
++CONFIG_MEDIATEK_ETH=y
++CONFIG_PCI=y
++CONFIG_MTD=y
++CONFIG_MTD_UBI_FASTMAP=y
++CONFIG_MTDPARTS_DEFAULT="mtdparts=spi-nand0:512k(bl2),2048k(fip),-(ubi)"
++CONFIG_DM_PCI=y
++CONFIG_PCIE_MEDIATEK=y
++CONFIG_PINCTRL=y
++CONFIG_PINCONF=y
++CONFIG_PINCTRL_MT7622=y
++CONFIG_POWER_DOMAIN=y
++CONFIG_PRE_CONSOLE_BUFFER=y
++CONFIG_PRE_CON_BUF_ADDR=0x4007EF00
++CONFIG_MTK_POWER_DOMAIN=y
++CONFIG_RAM=y
++CONFIG_DM_SERIAL=y
++CONFIG_MTK_SERIAL=y
++CONFIG_MMC=y
++CONFIG_MMC_DEFAULT_DEV=1
++CONFIG_MMC_HS200_SUPPORT=y
++CONFIG_MMC_MTK=y
++CONFIG_MMC_SUPPORTS_TUNING=y
++CONFIG_SUPPORT_EMMC_BOOT=y
++CONFIG_SPI=y
++CONFIG_DM_SPI=y
++CONFIG_MTK_SPI_NAND=y
++CONFIG_MTK_SPI_NAND_MTD=y
++CONFIG_SYSRESET_WATCHDOG=y
++CONFIG_WDT_MTK=y
++CONFIG_LZO=y
++CONFIG_ZSTD=y
++CONFIG_HEXDUMP=y
++CONFIG_RANDOM_UUID=y
++CONFIG_REGEX=y
++CONFIG_USB=y
++CONFIG_USB_HOST=y
++CONFIG_USB_XHCI_HCD=y
++CONFIG_USB_XHCI_MTK=y
++CONFIG_USB_STORAGE=y
+--- /dev/null
++++ b/bananapi_bpi-r64-sdmmc_env
+@@ -0,0 +1,82 @@
++ipaddr=192.168.0.45
++serverip=192.168.0.100
++loadaddr=0x48000000
++bootargs=root=/dev/mmcblk1p65
++bootcmd=if pstore check ; then run boot_recovery ; else run boot_sdmmc ; fi
++bootconf=config-mt7622-bananapi-bpi-r64-pcie1
++bootconf_pcie=config-mt7622-bananapi-bpi-r64-pcie1
++bootconf_sata=config-mt7622-bananapi-bpi-r64-sata
++bootdelay=0
++bootfile=openwrt-mediatek-mt7622-bananapi_bpi-r64-initramfs-recovery.itb
++bootfile_emmcbl2=openwrt-mediatek-mt7622-bananapi_bpi-r64-emmc-preloader.bin
++bootfile_emmcbl3=openwrt-mediatek-mt7622-bananapi_bpi-r64-emmc-bl31-uboot.fip
++bootfile_upg=openwrt-mediatek-mt7622-bananapi_bpi-r64-squashfs-sysupgrade.itb
++bootled_pwr=bpi-r64:pio:green
++bootled_rec=bpi-r64:pio:blue
++bootmenu_confirm_return=askenv - Press ENTER to return to menu ; bootmenu 60
++bootmenu_default=0
++bootmenu_delay=0
++bootmenu_title=      [0;34m( ( ( [1;39mOpenWrt[0;34m ) ) )  [0;36m[SD card][0m
++bootmenu_0=Initialize environment.=run _firstboot
++bootmenu_0d=Run default boot command.=run boot_default
++bootmenu_1=Boot system via TFTP.=run boot_tftp ; run bootmenu_confirm_return
++bootmenu_2=Boot production system from SD card.=run boot_production ; run bootmenu_confirm_return
++bootmenu_3=Boot recovery system from SD card.=run boot_recovery ; run bootmenu_confirm_return
++bootmenu_4=Load production system via TFTP then write to SD card.=setenv noboot 1 ; setenv replacevol 1 ; run boot_tftp_production ; setenv noboot ; setenv replacevol ; run bootmenu_confirm_return
++bootmenu_5=Load recovery system via TFTP then write to SD card.=setenv noboot 1 ; setenv replacevol 1 ; run boot_tftp_recovery ; setenv noboot ; setenv replacevol ; run bootmenu_confirm_return
++bootmenu_6=[31mInstall bootloader, recovery and production to eMMC.[0m=run emmc_init ; run bootmenu_confirm_return
++bootmenu_7=[31mInstall bootloader, recovery and production to NAND.[0m=run ubi_init ; run bootmenu_confirm_return
++bootmenu_8=Reboot.=reset
++bootmenu_9=Reset all settings to factory defaults.=run reset_factory ; reset
++boot_first=if button reset ; then led $bootled_rec on ; run boot_tftp_recovery ; setenv flag_recover 1 ; run boot_default ; fi ; bootmenu
++boot_default=if env exists flag_recover ; then else run bootcmd ; fi ; run boot_recovery ; setenv replacevol 1 ; run boot_tftp_forever
++boot_production=led $bootled_pwr on ; run sdmmc_read_production && bootm $loadaddr#$bootconf ; led $bootled_pwr off
++boot_recovery=led $bootled_rec on ; run sdmmc_read_recovery && bootm $loadaddr#$bootconf ; led $bootled_rec off
++boot_sdmmc=run boot_production ; run boot_recovery
++boot_tftp_forever=led $bootled_rec on ; while true ; do run boot_tftp_recovery ; sleep 1 ; done
++boot_tftp_production=tftpboot $loadaddr $bootfile_upg && env exists replacevol && iminfo $loadaddr && run sdmmc_write_production ; if env exists noboot ; then else bootm $loadaddr#$bootconf ; fi
++boot_tftp_recovery=tftpboot $loadaddr $bootfile && env exists replacevol && iminfo $loadaddr && run sdmmc_write_recovery ; if env exists noboot ; then else bootm $loadaddr#$bootconf ; fi
++boot_tftp=tftpboot $loadaddr $bootfile && bootm $loadaddr
++boot_ubi=ubi part ubi && setenv bootargs && run boot_ubi_production ; run boot_ubi_recovery
++boot_ubi_production=led $bootled_pwr on ; run ubi_read_production && bootm $loadaddr ; led $bootled_pwr off
++boot_ubi_recovery=led $bootled_rec on ; run ubi_read_recovery ; bootm $loadaddr#$bootconf ; ubi remove recovery ; led $bootled_rec off
++check_ubi=ubi part ubi || run ubi_format
++emmc_init=run emmc_init_bl && run emmc_init_openwrt ; env default bootcmd ; saveenv ; saveenv
++emmc_init_bl=run sdmmc_read_emmc_bl2 && run emmc_write_bl2 && run sdmmc_read_emmc_hdr && run emmc_write_hdr && run sdmmc_read_emmc_fip && run emmc_write_fip
++emmc_init_openwrt=run sdmmc_read_recovery && iminfo $loadaddr && run emmc_write_recovery ; run sdmmc_read_production && iminfo $loadaddr && run emmc_write_production
++emmc_write_bl2=mmc dev 0 1 && mmc partconf 0 1 1 1 && mmc erase 0x0 0x400 && mmc write $loadaddr 0x0 0x100 ; mmc partconf 0 1 1 0
++emmc_write_fip=mmc dev 0 0 && mmc erase 0x1000 0x1000 && mmc write $loadaddr 0x1000 0x1000 && mmc erase 0x2000 0x800
++emmc_write_hdr=mmc dev 0 0 && mmc erase 0x0 0x40 && mmc write $loadaddr 0x0 0x40
++emmc_write_production=mmc dev 0 && part start mmc 0 $part_default part_addr && part size mmc 0 $part_default part_size && run mmc_write_vol
++emmc_write_recovery=mmc dev 0 && part start mmc 0 $part_recovery part_addr && part size mmc 0 $part_recovery part_size && run mmc_write_vol
++mmc_write_vol=imszb $loadaddr image_size && test 0x$image_size -le 0x$part_size && mmc erase 0x$part_addr 0x$part_size && mmc write $loadaddr 0x$part_addr 0x$image_size
++mmc_read_vol=mmc read $loadaddr $part_addr 0x8 && imszb $loadaddr image_size && test 0x$image_size -le 0x$part_size && mmc read $loadaddr 0x$part_addr 0x$image_size && setexpr filesize $image_size * 0x200
++part_default=production
++part_recovery=recovery
++reset_factory=eraseenv && reset
++sdmmc_read_emmc_hdr=mmc dev 1 && part start mmc 1 install part_addr && mmc read $loadaddr $part_addr 0x40
++sdmmc_read_emmc_bl2=mmc dev 1 && part start mmc 1 install part_addr && setexpr offset $part_addr + 0x400 && mmc read $loadaddr $offset 0x400
++sdmmc_read_emmc_fip=mmc dev 1 && part start mmc 1 install part_addr && setexpr offset $part_addr + 0x1000 && mmc read $loadaddr $offset 0x1000
++sdmmc_read_production=mmc dev 1 && part start mmc 1 $part_default part_addr && part size mmc 1 $part_default part_size && run mmc_read_vol
++sdmmc_read_recovery=mmc dev 1 && part start mmc 1 $part_recovery part_addr && part size mmc 1 $part_recovery part_size && run mmc_read_vol
++sdmmc_read_snand_bl2=mmc dev 1 && part start mmc 1 install part_addr && setexpr offset $part_addr + 0x2000 && mmc read $loadaddr $offset 0x400
++sdmmc_read_snand_fip=mmc dev 1 && part start mmc 1 install part_addr && setexpr offset $part_addr + 0x2400 && mmc read $loadaddr $offset 0x1000
++sdmmc_write_production=mmc dev 1 && part start mmc 1 $part_default part_addr && part size mmc 1 $part_default part_size && run mmc_write_vol
++sdmmc_write_recovery=mmc dev 1 && part start mmc 1 $part_recovery part_addr && part size mmc 1 $part_recovery part_size && run mmc_write_vol
++snand_write_fip=mtd erase fip && mtd write fip $loadaddr
++snand_write_bl2=mtd erase bl2 && mtd write bl2 $loadaddr
++ubi_create_env=ubi create ubootenv 0x100000 dynamic 0 ; ubi create ubootenv2 0x100000 dynamic 1 ; ubi create fit 0x100000 dynamic 2 ; ubi create recovery 0x100000 dynamic 3
++ubi_format=ubi detach ; mtd erase ubi && ubi part ubi ; reset
++ubi_init=run ubi_init_bl && ubi detach && mtd erase ubi && ubi part ubi && run ubi_create_env && run ubi_init_openwrt
++ubi_init_openwrt=run sdmmc_read_recovery && iminfo $loadaddr && run ubi_write_recovery ; run sdmmc_read_production && iminfo $loadaddr && run ubi_write_production
++ubi_init_bl=run sdmmc_read_snand_bl2 && run snand_write_bl2 && run sdmmc_read_snand_fip && run snand_write_fip
++ubi_prepare_rootfs=if ubi check rootfs_data ; then else if env exists rootfs_data_max ; then ubi create rootfs_data $rootfs_data_max dynamic || ubi create rootfs_data - dynamic ; else ubi create rootfs_data - dynamic ; fi ; fi
++ubi_read_production=ubi read $loadaddr fit && iminfo $loadaddr && run ubi_prepare_rootfs
++ubi_read_recovery=ubi check recovery && ubi read $loadaddr recovery
++ubi_remove_rootfs=ubi check rootfs_data && ubi remove rootfs_data
++ubi_write_production=ubi check fit && ubi remove fit ; run ubi_remove_rootfs ; ubi create fit $filesize dynamic 2 && ubi write $loadaddr fit $filesize
++ubi_write_recovery=ubi check recovery && ubi remove recovery ; run ubi_remove_rootfs ; ubi create recovery $filesize dynamic 3 && ubi write $loadaddr recovery $filesize
++_init_env=setenv _init_env ; setenv _create_env ; saveenv ; saveenv
++_firstboot=setenv _firstboot ; run _switch_to_menu ; run _init_env ; run boot_first
++_switch_to_menu=setenv _switch_to_menu ; setenv bootdelay 3 ; setenv bootmenu_delay 3 ; setenv bootmenu_0 $bootmenu_0d ; setenv bootmenu_0d ; run _bootmenu_update_title
++_bootmenu_update_title=setenv _bootmenu_update_title ; setenv bootmenu_title "$bootmenu_title       [33m$ver[0m"
+--- /dev/null
++++ b/configs/mt7622_bananapi_bpi-r64-emmc_defconfig
+@@ -0,0 +1,145 @@
++CONFIG_ARM=y
++CONFIG_POSITION_INDEPENDENT=y
++CONFIG_ARCH_MEDIATEK=y
++CONFIG_TARGET_MT7622=y
++CONFIG_SYS_TEXT_BASE=0x41e00000
++CONFIG_SYS_MALLOC_F_LEN=0x4000
++CONFIG_USE_DEFAULT_ENV_FILE=y
++CONFIG_BOARD_LATE_INIT=y
++CONFIG_BOOTP_SEND_HOSTNAME=y
++CONFIG_NR_DRAM_BANKS=1
++CONFIG_DEBUG_UART_BASE=0x11002000
++CONFIG_DEBUG_UART_CLOCK=25000000
++CONFIG_DEFAULT_DEVICE_TREE="mt7622-bananapi-bpi-r64"
++CONFIG_OF_LIBFDT_OVERLAY=y
++CONFIG_DEBUG_UART=y
++CONFIG_DEFAULT_ENV_FILE="bananapi_bpi-r64-emmc_env"
++CONFIG_NET_RANDOM_ETHADDR=y
++CONFIG_SMBIOS_PRODUCT_NAME=""
++CONFIG_AUTOBOOT_KEYED=y
++CONFIG_BOOTDELAY=30
++CONFIG_AUTOBOOT_MENU_SHOW=y
++CONFIG_CFB_CONSOLE_ANSI=y
++CONFIG_BUTTON=y
++CONFIG_BUTTON_GPIO=y
++CONFIG_GPIO_HOG=y
++CONFIG_CMD_ENV_FLAGS=y
++CONFIG_FIT=y
++CONFIG_FIT_ENABLE_SHA256_SUPPORT=y
++CONFIG_LED=y
++CONFIG_LED_BLINK=y
++CONFIG_LED_GPIO=y
++CONFIG_LOGLEVEL=7
++CONFIG_LOG=y
++CONFIG_DEFAULT_FDT_FILE="mt7622-bananapi-bpi-r64"
++CONFIG_SYS_PROMPT="MT7622> "
++CONFIG_CMD_BOOTMENU=y
++CONFIG_CMD_BOOTP=y
++CONFIG_CMD_BUTTON=y
++CONFIG_CMD_CACHE=y
++CONFIG_CMD_CDP=y
++CONFIG_CMD_DHCP=y
++CONFIG_CMD_DNS=y
++CONFIG_CMD_ECHO=y
++CONFIG_CMD_ENV_READMEM=y
++CONFIG_CMD_ERASEENV=y
++CONFIG_CMD_EXT4=y
++CONFIG_CMD_FAT=y
++CONFIG_CMD_FS_GENERIC=y
++CONFIG_CMD_FS_UUID=y
++CONFIG_CMD_GPIO=y
++CONFIG_CMD_GPT=y
++CONFIG_CMD_HASH=y
++CONFIG_CMD_ITEST=y
++CONFIG_CMD_LED=y
++CONFIG_CMD_LICENSE=y
++CONFIG_CMD_LINK_LOCAL=y
++# CONFIG_CMD_MBR is not set
++CONFIG_CMD_MMC=y
++CONFIG_CMD_PCI=y
++CONFIG_CMD_SF_TEST=y
++CONFIG_CMD_PING=y
++CONFIG_CMD_PXE=y
++CONFIG_CMD_PWM=y
++CONFIG_CMD_SMC=y
++CONFIG_CMD_TFTPBOOT=y
++CONFIG_CMD_TFTPSRV=y
++CONFIG_CMD_ASKENV=y
++CONFIG_CMD_PART=y
++CONFIG_CMD_PSTORE=y
++CONFIG_CMD_PSTORE_MEM_ADDR=0x42ff0000
++CONFIG_CMD_RARP=y
++CONFIG_CMD_SETEXPR=y
++CONFIG_CMD_SLEEP=y
++CONFIG_CMD_SNTP=y
++CONFIG_CMD_SOURCE=y
++CONFIG_CMD_STRINGS=y
++CONFIG_CMD_USB=y
++CONFIG_CMD_UUID=y
++CONFIG_DISPLAY_CPUINFO=y
++CONFIG_DM_MMC=y
++CONFIG_DM_REGULATOR=y
++CONFIG_DM_REGULATOR_FIXED=y
++CONFIG_DM_REGULATOR_GPIO=y
++CONFIG_DM_USB=y
++CONFIG_DM_PWM=y
++CONFIG_PWM_MTK=y
++CONFIG_HUSH_PARSER=y
++CONFIG_SYS_REDUNDAND_ENVIRONMENT=y
++CONFIG_SYS_RELOC_GD_ENV_ADDR=y
++CONFIG_ENV_IS_IN_MMC=y
++CONFIG_SYS_MMC_ENV_DEV=0
++CONFIG_ENV_OFFSET=0x400000
++CONFIG_ENV_OFFSET_REDUND=0x480000
++CONFIG_ENV_SIZE=0x80000
++CONFIG_ENV_VARS_UBOOT_RUNTIME_CONFIG=y
++CONFIG_VERSION_VARIABLE=y
++CONFIG_PARTITION_UUIDS=y
++CONFIG_NETCONSOLE=y
++CONFIG_REGMAP=y
++CONFIG_SYSCON=y
++CONFIG_CLK=y
++CONFIG_DM_GPIO=y
++CONFIG_DM_SCSI=y
++CONFIG_AHCI=y
++CONFIG_AHCI_PCI=y
++CONFIG_SCSI_AHCI=y
++CONFIG_SCSI=y
++CONFIG_CMD_SCSI=y
++CONFIG_PHY=y
++CONFIG_PHY_MTK_TPHY=y
++CONFIG_PHY_FIXED=y
++CONFIG_MTK_AHCI=y
++CONFIG_DM_ETH=y
++CONFIG_MEDIATEK_ETH=y
++CONFIG_PCI=y
++CONFIG_DM_PCI=y
++CONFIG_PCIE_MEDIATEK=y
++CONFIG_PINCTRL=y
++CONFIG_PINCONF=y
++CONFIG_PINCTRL_MT7622=y
++CONFIG_POWER_DOMAIN=y
++CONFIG_PRE_CONSOLE_BUFFER=y
++CONFIG_PRE_CON_BUF_ADDR=0x4007EF00
++CONFIG_MTK_POWER_DOMAIN=y
++CONFIG_RAM=y
++CONFIG_DM_SERIAL=y
++CONFIG_MTK_SERIAL=y
++CONFIG_MMC=y
++CONFIG_MMC_DEFAULT_DEV=0
++CONFIG_MMC_HS200_SUPPORT=y
++CONFIG_MMC_MTK=y
++CONFIG_MMC_SUPPORTS_TUNING=y
++CONFIG_SUPPORT_EMMC_BOOT=y
++CONFIG_SYSRESET_WATCHDOG=y
++CONFIG_WDT_MTK=y
++CONFIG_LZO=y
++CONFIG_ZSTD=y
++CONFIG_HEXDUMP=y
++CONFIG_RANDOM_UUID=y
++CONFIG_REGEX=y
++CONFIG_USB=y
++CONFIG_USB_HOST=y
++CONFIG_USB_XHCI_HCD=y
++CONFIG_USB_XHCI_MTK=y
++CONFIG_USB_STORAGE=y
+--- /dev/null
++++ b/bananapi_bpi-r64-emmc_env
+@@ -0,0 +1,56 @@
++ipaddr=192.168.0.45
++serverip=192.168.0.100
++loadaddr=0x48000000
++bootcmd=if pstore check ; then run boot_recovery ; else run boot_emmc ; fi
++bootargs=root=/dev/mmcblk0p65
++bootconf=config-mt7622-bananapi-bpi-r64-pcie1
++bootconf_pcie=config-mt7622-bananapi-bpi-r64-pcie1
++bootconf_sata=config-mt7622-bananapi-bpi-r64-sata
++bootdelay=0
++bootfile=openwrt-mediatek-mt7622-bananapi_bpi-r64-initramfs-recovery.itb
++bootfile_upg=openwrt-mediatek-mt7622-bananapi_bpi-r64-squashfs-sysupgrade.itb
++bootfile_bl2=openwrt-mediatek-mt7622-bananapi_bpi-r64-emmc-preloader.bin
++bootfile_fip=openwrt-mediatek-mt7622-bananapi_bpi-r64-emmc-bl31-uboot.fip
++bootled_pwr=bpi-r64:pio:green
++bootled_rec=bpi-r64:pio:blue
++bootmenu_confirm_return=askenv - Press ENTER to return to menu ; bootmenu 60
++bootmenu_default=0
++bootmenu_delay=0
++bootmenu_title=      [0;34m( ( ( [1;39mOpenWrt[0;34m ) ) )  [0;36m[eMMC][0m
++bootmenu_0=Initialize environment.=run _firstboot
++bootmenu_0d=Run default boot command.=run boot_default
++bootmenu_1=Boot system via TFTP.=run boot_tftp ; run bootmenu_confirm_return
++bootmenu_2=Boot production system from eMMC.=run boot_production ; run bootmenu_confirm_return
++bootmenu_3=Boot recovery system from eMMC.=run boot_recovery ; run bootmenu_confirm_return
++bootmenu_4=Load production system via TFTP then write to eMMC.=setenv noboot 1 ; setenv replacevol 1 ; run boot_tftp_production ; setenv noboot ; setenv replacevol ; run bootmenu_confirm_return
++bootmenu_5=Load recovery system via TFTP then write to eMMC.=setenv noboot 1 ; setenv replacevol 1 ; run boot_tftp_recovery ; setenv noboot ; setenv replacevol ; run bootmenu_confirm_return
++bootmenu_6=[31mLoad BL31+U-Boot FIP via TFTP then write to eMMC.[0m=run boot_tftp_write_fip ; run bootmenu_confirm_return
++bootmenu_7=[31mLoad BL2 preloader via TFTP then write to eMMC.[0m=run boot_tftp_write_bl2 ; run bootmenu_confirm_return
++bootmenu_8=Reboot.=reset
++bootmenu_9=Reset all settings to factory defaults.=run reset_factory ; reset
++boot_first=if button reset ; then led $bootled_rec on ; run boot_tftp_recovery ; setenv flag_recover 1 ; run boot_default ; fi ; bootmenu
++boot_default=if env exists flag_recover ; then else run bootcmd ; fi ; run boot_recovery ; setenv replacevol 1 ; run boot_tftp_forever
++boot_production=led $bootled_pwr on ; run emmc_read_production && bootm $loadaddr#$bootconf ; led $bootled_pwr off
++boot_recovery=led $bootled_rec on ; run emmc_read_recovery && bootm $loadaddr#$bootconf ; led $bootled_rec off
++boot_emmc=run boot_production ; run boot_recovery
++boot_tftp_forever=led $bootled_rec on ; while true ; do run boot_tftp_recovery ; sleep 1 ; done
++boot_tftp_production=tftpboot $loadaddr $bootfile_upg && env exists replacevol && iminfo $loadaddr && run emmc_write_production ; if env exists noboot ; then else bootm $loadaddr#$bootconf ; fi
++boot_tftp_recovery=tftpboot $loadaddr $bootfile && env exists replacevol && iminfo $loadaddr && run emmc_write_recovery ; if env exists noboot ; then else bootm $loadaddr#$bootconf ; fi
++boot_tftp_write_bl2=tftpboot $loadaddr $bootfile_bl2 && run emmc_write_bl2
++boot_tftp_write_fip=tftpboot $loadaddr $bootfile_fip && run emmc_write_fip
++boot_tftp=tftpboot $loadaddr $bootfile && bootm $loadaddr
++emmc_write_production=mmc dev 0 && part start mmc 0 $part_default part_addr && part size mmc 0 $part_default part_size && run mmc_write_vol
++emmc_write_recovery=mmc dev 0 && part start mmc 0 $part_recovery part_addr && part size mmc 0 $part_recovery part_size && run mmc_write_vol
++emmc_write_bl2=mmc dev 0 1 && mmc partconf 0 1 1 1 && mmc erase 0x0 0x400 && mmc write $loadaddr 0x0 0x100 ; mmc partconf 0 1 1 0
++emmc_write_fip=mmc dev 0 0 && mmc erase 0x1000 0x1000 && mmc write $loadaddr 0x1000 0x1000 && mmc erase 0x2000 0x800
++emmc_read_production=mmc dev 0 && part start mmc 0 $part_default part_addr && part size mmc 0 $part_default part_size && run mmc_read_vol
++emmc_read_recovery=mmc dev 0 && part start mmc 0 $part_recovery part_addr && part size mmc 0 $part_recovery part_size && run mmc_read_vol
++mmc_write_vol=imszb $fileaddr image_size && test 0x$image_size -le 0x$part_size && mmc erase 0x$part_addr 0x$part_size && mmc write $fileaddr 0x$part_addr 0x$image_size
++mmc_read_vol=mmc read $loadaddr $part_addr 0x8 && imszb $loadaddr image_size && test 0x$image_size -le 0x$part_size && mmc read $loadaddr 0x$part_addr 0x$image_size
++part_default=production
++part_recovery=recovery
++reset_factory=eraseenv && reset
++_init_env=setenv _init_env ; setenv _create_env ; saveenv ; saveenv
++_firstboot=setenv _firstboot ; run _switch_to_menu ; run _init_env ; run boot_first
++_switch_to_menu=setenv _switch_to_menu ; setenv bootdelay 3 ; setenv bootmenu_delay 3 ; setenv bootmenu_0 $bootmenu_0d ; setenv bootmenu_0d ; run _bootmenu_update_title
++_bootmenu_update_title=setenv _bootmenu_update_title ; setenv bootmenu_title "$bootmenu_title       [33m$ver[0m"
+--- /dev/null
++++ b/configs/mt7622_bananapi_bpi-r64-snand_defconfig
+@@ -0,0 +1,139 @@
++CONFIG_ARM=y
++CONFIG_POSITION_INDEPENDENT=y
++CONFIG_ARCH_MEDIATEK=y
++CONFIG_SYS_TEXT_BASE=0x41e00000
++CONFIG_SYS_MALLOC_F_LEN=0x4000
++CONFIG_USE_DEFAULT_ENV_FILE=y
++CONFIG_BOARD_LATE_INIT=y
++CONFIG_BOOTP_SEND_HOSTNAME=y
++CONFIG_NR_DRAM_BANKS=1
++CONFIG_DEBUG_UART_BASE=0x11002000
++CONFIG_DEBUG_UART_CLOCK=25000000
++CONFIG_DEFAULT_DEVICE_TREE="mt7622-bananapi-bpi-r64"
++CONFIG_OF_LIBFDT_OVERLAY=y
++CONFIG_DEBUG_UART=y
++CONFIG_DEFAULT_ENV_FILE="bananapi_bpi-r64-snand_env"
++CONFIG_DISTRO_DEFAULTS=y
++CONFIG_NET_RANDOM_ETHADDR=y
++CONFIG_SMBIOS_PRODUCT_NAME=""
++CONFIG_AUTOBOOT_KEYED=y
++CONFIG_BOOTDELAY=30
++CONFIG_AUTOBOOT_MENU_SHOW=y
++CONFIG_CFB_CONSOLE_ANSI=y
++CONFIG_BUTTON=y
++CONFIG_BUTTON_GPIO=y
++CONFIG_CMD_ENV_FLAGS=y
++CONFIG_FIT=y
++CONFIG_FIT_ENABLE_SHA256_SUPPORT=y
++CONFIG_LED=y
++CONFIG_LED_BLINK=y
++CONFIG_LED_GPIO=y
++CONFIG_LOGLEVEL=7
++CONFIG_LOG=y
++CONFIG_DEFAULT_FDT_FILE="mediatek/mt7622-bananapi-bpi-r64.dtb"
++CONFIG_SYS_PROMPT="MT7622> "
++CONFIG_CMD_BOOTMENU=y
++CONFIG_CMD_BOOTP=y
++CONFIG_CMD_BUTTON=y
++CONFIG_CMD_CDP=y
++CONFIG_CMD_DHCP=y
++CONFIG_CMD_DM=y
++CONFIG_CMD_DNS=y
++CONFIG_CMD_ECHO=y
++CONFIG_CMD_EFIDEBUG=y
++CONFIG_CMD_ENV_READMEM=y
++CONFIG_CMD_ERASEENV=y
++CONFIG_CMD_EXT4=y
++CONFIG_CMD_FAT=y
++CONFIG_CMD_FS_GENERIC=y
++CONFIG_CMD_FS_UUID=y
++CONFIG_CMD_GPIO=y
++CONFIG_CMD_GPT=y
++CONFIG_CMD_HASH=y
++CONFIG_CMD_ITEST=y
++CONFIG_CMD_LED=y
++CONFIG_CMD_LICENSE=y
++CONFIG_CMD_LINK_LOCAL=y
++# CONFIG_CMD_MBR is not set
++CONFIG_CMD_MMC=y
++CONFIG_CMD_MTD=y
++CONFIG_CMD_PCI=y
++CONFIG_CMD_PING=y
++CONFIG_CMD_PXE=y
++CONFIG_CMD_SMC=y
++CONFIG_CMD_TFTPBOOT=y
++CONFIG_CMD_TFTPSRV=y
++CONFIG_CMD_UBI=y
++CONFIG_CMD_UBI_RENAME=y
++CONFIG_CMD_UBIFS=y
++CONFIG_CMD_ASKENV=y
++CONFIG_CMD_PART=y
++CONFIG_CMD_PSTORE=y
++CONFIG_CMD_PSTORE_MEM_ADDR=0x42ff0000
++CONFIG_CMD_RARP=y
++CONFIG_CMD_SETEXPR=y
++CONFIG_CMD_SLEEP=y
++CONFIG_CMD_SNTP=y
++CONFIG_CMD_SOURCE=y
++CONFIG_CMD_USB=y
++CONFIG_CMD_UUID=y
++CONFIG_DISPLAY_CPUINFO=y
++CONFIG_DM_MMC=y
++CONFIG_DM_MTD=y
++CONFIG_DM_REGULATOR=y
++CONFIG_DM_REGULATOR_FIXED=y
++CONFIG_DM_REGULATOR_GPIO=y
++CONFIG_DM_USB=y
++CONFIG_HUSH_PARSER=y
++CONFIG_SYS_REDUNDAND_ENVIRONMENT=y
++CONFIG_SYS_RELOC_GD_ENV_ADDR=y
++CONFIG_ENV_IS_IN_UBI=y
++CONFIG_ENV_UBI_PART="ubi"
++CONFIG_ENV_UBI_VOLUME="ubootenv"
++CONFIG_ENV_UBI_VOLUME_REDUND="ubootenv2"
++CONFIG_ENV_VARS_UBOOT_RUNTIME_CONFIG=y
++CONFIG_VERSION_VARIABLE=y
++CONFIG_PARTITION_UUIDS=y
++CONFIG_NETCONSOLE=y
++CONFIG_REGMAP=y
++CONFIG_SYSCON=y
++CONFIG_CLK=y
++CONFIG_PHY_FIXED=y
++CONFIG_DM_ETH=y
++CONFIG_MEDIATEK_ETH=y
++CONFIG_PCI=y
++CONFIG_MTD=y
++CONFIG_MTD_UBI_FASTMAP=y
++CONFIG_MTDPARTS_DEFAULT="mtdparts=spi-nand0:512k(bl2),2048k(fip),-(ubi)"
++CONFIG_DM_PCI=y
++CONFIG_PCIE_MEDIATEK=y
++CONFIG_PINCTRL=y
++CONFIG_PINCONF=y
++CONFIG_PINCTRL_MT7622=y
++CONFIG_POWER_DOMAIN=y
++CONFIG_PRE_CONSOLE_BUFFER=y
++CONFIG_PRE_CON_BUF_ADDR=0x4007EF00
++CONFIG_MTK_POWER_DOMAIN=y
++CONFIG_RAM=y
++CONFIG_DM_SERIAL=y
++CONFIG_MTK_SERIAL=y
++CONFIG_MMC=y
++CONFIG_MMC_DEFAULT_DEV=1
++CONFIG_MMC_MTK=y
++CONFIG_SUPPORT_EMMC_BOOT=y
++CONFIG_SPI=y
++CONFIG_DM_SPI=y
++CONFIG_MTK_SPI_NAND=y
++CONFIG_MTK_SPI_NAND_MTD=y
++CONFIG_SYSRESET_WATCHDOG=y
++CONFIG_WDT_MTK=y
++CONFIG_LZO=y
++CONFIG_ZSTD=y
++CONFIG_HEXDUMP=y
++CONFIG_RANDOM_UUID=y
++CONFIG_REGEX=y
++CONFIG_USB=y
++CONFIG_USB_HOST=y
++CONFIG_USB_XHCI_HCD=y
++CONFIG_USB_XHCI_MTK=y
++CONFIG_USB_STORAGE=y
+--- /dev/null
++++ b/bananapi_bpi-r64-snand_env
+@@ -0,0 +1,57 @@
++ipaddr=192.168.0.45
++serverip=192.168.0.100
++loadaddr=0x48000000
++bootargs=root=/dev/ubiblock0_2p1
++bootcmd=if pstore check ; then run boot_recovery ; else run boot_ubi ; fi
++bootconf=config-mt7622-bananapi-bpi-r64-pcie1
++bootconf_pcie=config-mt7622-bananapi-bpi-r64-pcie1
++bootconf_sata=config-mt7622-bananapi-bpi-r64-sata
++bootdelay=0
++bootfile=openwrt-mediatek-mt7622-bananapi_bpi-r64-initramfs-recovery.itb
++bootfile_fip=openwrt-mediatek-mt7622-bananapi_bpi-r64-snand-bl31-uboot.fip
++bootfile_bl2=openwrt-mediatek-mt7622-bananapi_bpi-r64-snand-preloader.bin
++bootfile_upg=openwrt-mediatek-mt7622-bananapi_bpi-r64-squashfs-sysupgrade.itb
++bootled_pwr=bpi-r64:pio:green
++bootled_rec=bpi-r64:pio:blue
++bootmenu_confirm_return=askenv - Press ENTER to return to menu ; bootmenu 60
++bootmenu_default=0
++bootmenu_delay=0
++bootmenu_title=      [0;34m( ( ( [1;39mOpenWrt[0;34m ) ) )  [0;36m[SPI-NAND][0m
++bootmenu_0=Initialize environment.=run _firstboot
++bootmenu_0d=Run default boot command.=run boot_default
++bootmenu_1=Boot system via TFTP.=run boot_tftp ; run bootmenu_confirm_return
++bootmenu_2=Boot production system from NAND.=run boot_production ; run bootmenu_confirm_return
++bootmenu_3=Boot recovery system from NAND.=run boot_recovery ; run bootmenu_confirm_return
++bootmenu_4=Load production system via TFTP then write to NAND.=setenv noboot 1 ; setenv replacevol 1 ; run boot_tftp_production ; setenv noboot ; setenv replacevol ; run bootmenu_confirm_return
++bootmenu_5=Load recovery system via TFTP then write to NAND.=setenv noboot 1 ; setenv replacevol 1 ; run boot_tftp_recovery ; setenv noboot ; setenv replacevol ; run bootmenu_confirm_return
++bootmenu_6=[31mLoad BL31+U-Boot FIP via TFTP then write to NAND.[0m=run boot_tftp_write_fip ; run bootmenu_confirm_return
++bootmenu_7=[31mLoad BL2 preloader via TFTP then write to NAND.[0m=run boot_tftp_write_bl2 ; run bootmenu_confirm_return
++bootmenu_8=Reboot.=reset
++bootmenu_9=Reset all settings to factory defaults.=run reset_factory ; reset
++boot_first=if button reset ; then led $bootled_rec on ; run boot_tftp_recovery ; setenv flag_recover 1 ; run boot_default ; fi ; bootmenu
++boot_default=if env exists flag_recover ; then else run bootcmd ; fi ; run boot_recovery ; setenv replacevol 1 ; run boot_tftp_forever
++boot_production=led $bootled_pwr on ; run ubi_read_production && bootm $loadaddr#$bootconf ; led $bootled_pwr off
++boot_recovery=led $bootled_rec on ; run ubi_read_recovery ; bootm $loadaddr#$bootconf ; ubi remove recovery ; led $bootled_rec off
++boot_tftp=tftpboot $loadaddr $bootfile && bootm $loadaddr#$bootconf
++boot_tftp_forever=led $bootled_rec on ; while true ; do run boot_tftp_recovery ; sleep 1 ; done
++boot_tftp_production=tftpboot $loadaddr $bootfile_upg && iminfo $loadaddr && ubi part ubi && run ubi_write_production ubi_prepare_rootfs ; if env exists noboot ; then else bootm $loadaddr#$bootconf ; fi
++boot_tftp_recovery=tftpboot $loadaddr $bootfile && iminfo $loadaddr && ubi part ubi && run ubi_write_recovery ; if env exists noboot ; then else bootm $loadaddr#$bootconf ; fi
++boot_tftp_write_bl2=tftpboot $loadaddr $bootfile_bl2 && run boot_write_bl2
++boot_tftp_write_fip=tftpboot $loadaddr $bootfile_fip && run boot_write_fip
++boot_ubi=ubi part ubi && run boot_production ; run boot_recovery
++boot_write_bl2=mtd erase bl2 && mtd write spi-nand0 $loadaddr 0x0 0x20000 && mtd write spi-nand0 $loadaddr 0x20000 0x20000 && mtd write spi-nand0 $loadaddr 0x40000 0x20000 && mtd write spi-nand0 $loadaddr 0x60000 0x20000
++boot_write_fip=mtd erase fip && mtd write fip $loadaddr
++check_ubi=ubi part ubi || run ubi_format
++reset_factory=ubi part ubi ; ubi write 0x0 ubootenv 0x0 ; ubi write 0x0 ubootenv2 0x0 ; ubi remove rootfs_data
++ubi_format=ubi detach ; mtd erase ubi && ubi part ubi ; reset
++ubi_prepare_rootfs=if ubi check rootfs_data ; then else if env exists rootfs_data_max ; then ubi create rootfs_data $rootfs_data_max dynamic || ubi create rootfs_data - dynamic ; else ubi create rootfs_data - dynamic ; fi ; fi
++ubi_read_production=ubi read $loadaddr fit && iminfo $loadaddr && run ubi_prepare_rootfs
++ubi_read_recovery=ubi check recovery && ubi read $loadaddr recovery
++ubi_remove_rootfs=ubi check rootfs_data && ubi remove rootfs_data
++ubi_write_production=ubi check fit && env exists replacevol && ubi remove fit ; if ubi check fit ; then else run ubi_remove_rootfs ; ubi create fit $filesize dynamic 2 && ubi write $loadaddr fit $filesize ; fi
++ubi_write_recovery=ubi check recovery && env exists replacevol && ubi remove recovery ; if ubi check recovery ; then else run ubi_remove_rootfs ; ubi create recovery $filesize dynamic 3 && ubi write $loadaddr recovery $filesize ; fi
++_create_env=ubi create ubootenv 0x100000 dynamic 0 ; ubi create ubootenv2 0x100000 dynamic 1 ; ubi create fit 0x100000 dynamic 2 ; ubi create recovery 0x100000 dynamic 3
++_init_env=setenv _init_env ; if ubi check ubootenv && ubi check ubootenv2 ; then else run _create_env ; fi ; setenv _create_env ; saveenv || run ubi_format ; saveenv || run ubi_format
++_firstboot=setenv _firstboot ; run _switch_to_menu ; run check_ubi ; run _init_env ; run boot_first
++_switch_to_menu=setenv _switch_to_menu ; setenv bootdelay 3 ; setenv bootmenu_delay 3 ; setenv bootmenu_0 $bootmenu_0d ; setenv bootmenu_0d ; run _bootmenu_update_title
++_bootmenu_update_title=setenv _bootmenu_update_title ; setenv bootmenu_title "$bootmenu_title       [33m$ver[0m"
diff --git a/package/boot/uboot-mediatek/patches/405-dts-mt7623n-bpi-r2-fix-leds.patch b/package/boot/uboot-mediatek/patches/405-dts-mt7623n-bpi-r2-fix-leds.patch
new file mode 100644
index 0000000000..8748192902
--- /dev/null
+++ b/package/boot/uboot-mediatek/patches/405-dts-mt7623n-bpi-r2-fix-leds.patch
@@ -0,0 +1,25 @@
+--- a/arch/arm/dts/mt7623n-bananapi-bpi-r2.dts
++++ b/arch/arm/dts/mt7623n-bananapi-bpi-r2.dts
+@@ -50,19 +50,19 @@
+ 
+ 		blue {
+ 			label = "bpi-r2:pio:blue";
+-			gpios = <&gpio 241 GPIO_ACTIVE_HIGH>;
++			gpios = <&gpio 240 GPIO_ACTIVE_LOW>;
+ 			default-state = "off";
+ 		};
+ 
+ 		green {
+ 			label = "bpi-r2:pio:green";
+-			gpios = <&gpio 240 GPIO_ACTIVE_HIGH>;
++			gpios = <&gpio 241 GPIO_ACTIVE_LOW>;
+ 			default-state = "off";
+ 		};
+ 
+ 		red {
+ 			label = "bpi-r2:pio:red";
+-			gpios = <&gpio 239 GPIO_ACTIVE_HIGH>;
++			gpios = <&gpio 239 GPIO_ACTIVE_LOW>;
+ 			default-state = "off";
+ 		};
+ 	};
diff --git a/package/boot/uboot-mediatek/patches/410-add-linksys-e8450.patch b/package/boot/uboot-mediatek/patches/410-add-linksys-e8450.patch
new file mode 100644
index 0000000000..04646d7625
--- /dev/null
+++ b/package/boot/uboot-mediatek/patches/410-add-linksys-e8450.patch
@@ -0,0 +1,406 @@
+--- /dev/null
++++ b/configs/mt7622_linksys_e8450_defconfig
+@@ -0,0 +1,135 @@
++CONFIG_ARM=y
++CONFIG_POSITION_INDEPENDENT=y
++CONFIG_ARCH_MEDIATEK=y
++CONFIG_TARGET_MT7622=y
++CONFIG_SYS_TEXT_BASE=0x41e00000
++CONFIG_SYS_MALLOC_F_LEN=0x4000
++CONFIG_USE_DEFAULT_ENV_FILE=y
++CONFIG_BOARD_LATE_INIT=y
++CONFIG_BOOTP_SEND_HOSTNAME=y
++CONFIG_DEFAULT_ENV_FILE="linksys_e8450_env"
++CONFIG_NR_DRAM_BANKS=1
++CONFIG_DEBUG_UART_BASE=0x11002000
++CONFIG_DEBUG_UART_CLOCK=25000000
++CONFIG_DEFAULT_DEVICE_TREE="mt7622-linksys-e8450-ubi"
++CONFIG_DEBUG_UART=y
++CONFIG_MTDPARTS_DEFAULT="mtdparts=spi-nand0:512k(bl2),1280k(fip),1024k(factory),256k(reserved),-(ubi)"
++CONFIG_SMBIOS_PRODUCT_NAME=""
++CONFIG_AUTOBOOT_KEYED=y
++CONFIG_BOOTDELAY=30
++CONFIG_AUTOBOOT_MENU_SHOW=y
++CONFIG_CFB_CONSOLE_ANSI=y
++CONFIG_BUTTON=y
++CONFIG_BUTTON_GPIO=y
++CONFIG_GPIO_HOG=y
++CONFIG_CMD_ENV_FLAGS=y
++CONFIG_FIT=y
++CONFIG_FIT_ENABLE_SHA256_SUPPORT=y
++CONFIG_LED=y
++CONFIG_LED_BLINK=y
++CONFIG_LED_GPIO=y
++CONFIG_LOGLEVEL=7
++CONFIG_LOG=y
++CONFIG_DEFAULT_FDT_FILE="mt7622-linksys-e8450"
++CONFIG_SYS_PROMPT="MT7622> "
++CONFIG_CMD_BOOTMENU=y
++CONFIG_CMD_BOOTP=y
++CONFIG_CMD_BUTTON=y
++CONFIG_CMD_CDP=y
++CONFIG_CMD_DHCP=y
++CONFIG_CMD_DNS=y
++CONFIG_CMD_ECHO=y
++CONFIG_CMD_ENV_READMEM=y
++CONFIG_CMD_ERASEENV=y
++CONFIG_CMD_EXT4=y
++CONFIG_CMD_FAT=y
++CONFIG_CMD_FS_GENERIC=y
++CONFIG_CMD_FS_UUID=y
++CONFIG_CMD_GPIO=y
++CONFIG_CMD_GPT=y
++CONFIG_CMD_HASH=y
++CONFIG_CMD_ITEST=y
++CONFIG_CMD_LED=y
++CONFIG_CMD_LICENSE=y
++CONFIG_CMD_LINK_LOCAL=y
++# CONFIG_CMD_MBR is not set
++CONFIG_CMD_MTD=y
++CONFIG_CMD_MTDPART=y
++CONFIG_CMD_PCI=y
++CONFIG_CMD_SF_TEST=y
++CONFIG_CMD_PING=y
++CONFIG_CMD_PXE=y
++CONFIG_CMD_SMC=y
++CONFIG_CMD_TFTPBOOT=y
++CONFIG_CMD_TFTPSRV=y
++CONFIG_CMD_UBI=y
++CONFIG_CMD_UBI_RENAME=y
++CONFIG_CMD_UBIFS=y
++CONFIG_CMD_ASKENV=y
++CONFIG_CMD_PART=y
++CONFIG_CMD_PSTORE=y
++CONFIG_CMD_PSTORE_MEM_ADDR=0x42ff0000
++CONFIG_CMD_RARP=y
++CONFIG_CMD_SETEXPR=y
++CONFIG_CMD_SLEEP=y
++CONFIG_CMD_SNTP=y
++CONFIG_CMD_SOURCE=y
++CONFIG_CMD_USB=y
++CONFIG_CMD_UUID=y
++CONFIG_DISPLAY_CPUINFO=y
++CONFIG_DM_REGULATOR=y
++CONFIG_DM_REGULATOR_FIXED=y
++CONFIG_DM_REGULATOR_GPIO=y
++CONFIG_DM_USB=y
++CONFIG_HUSH_PARSER=y
++CONFIG_SYS_REDUNDAND_ENVIRONMENT=y
++CONFIG_SYS_RELOC_GD_ENV_ADDR=y
++CONFIG_ENV_IS_IN_UBI=y
++CONFIG_ENV_UBI_PART="ubi"
++CONFIG_ENV_UBI_VOLUME="ubootenv"
++CONFIG_ENV_UBI_VOLUME_REDUND="ubootenv2"
++CONFIG_ENV_VARS_UBOOT_RUNTIME_CONFIG=y
++CONFIG_VERSION_VARIABLE=y
++CONFIG_PARTITION_UUIDS=y
++CONFIG_NETCONSOLE=y
++CONFIG_REGMAP=y
++CONFIG_SYSCON=y
++CONFIG_CLK=y
++CONFIG_DM_MTD=y
++CONFIG_DM_GPIO=y
++CONFIG_PHY=y
++CONFIG_PHY_MTK_TPHY=y
++CONFIG_PHY_FIXED=y
++CONFIG_DM_ETH=y
++CONFIG_MEDIATEK_ETH=y
++CONFIG_PCI=y
++CONFIG_MTD=y
++CONFIG_MTD_UBI_FASTMAP=y
++CONFIG_DM_PCI=y
++CONFIG_PCIE_MEDIATEK=y
++CONFIG_PINCTRL=y
++CONFIG_PINCONF=y
++CONFIG_PINCTRL_MT7622=y
++CONFIG_POWER_DOMAIN=y
++CONFIG_PRE_CONSOLE_BUFFER=y
++CONFIG_PRE_CON_BUF_ADDR=0x4007EF00
++CONFIG_MTK_POWER_DOMAIN=y
++CONFIG_RAM=y
++CONFIG_DM_SERIAL=y
++CONFIG_MTK_SERIAL=y
++CONFIG_SPI=y
++CONFIG_DM_SPI=y
++CONFIG_MTK_SPI_NAND=y
++CONFIG_MTK_SPI_NAND_MTD=y
++CONFIG_SYSRESET_WATCHDOG=y
++CONFIG_WDT_MTK=y
++CONFIG_LZO=y
++CONFIG_ZSTD=y
++CONFIG_HEXDUMP=y
++CONFIG_RANDOM_UUID=y
++CONFIG_REGEX=y
++CONFIG_USB=y
++CONFIG_USB_HOST=y
++CONFIG_USB_XHCI_HCD=y
++CONFIG_USB_XHCI_MTK=y
++CONFIG_USB_STORAGE=y
+--- /dev/null
++++ b/arch/arm/dts/mt7622-linksys-e8450-ubi.dts
+@@ -0,0 +1,195 @@
++// SPDX-License-Identifier: GPL-2.0
++/*
++ * Copyright (c) 2019 MediaTek Inc.
++ * Author: Sam Shih <sam.shih@mediatek.com>
++ */
++
++/dts-v1/;
++#include "mt7622.dtsi"
++#include "mt7622-u-boot.dtsi"
++
++/ {
++	#address-cells = <1>;
++	#size-cells = <1>;
++	model = "mt7622-linksys-e8450-ubi";
++	compatible = "mediatek,mt7622", "linksys,e8450-ubi";
++	chosen {
++		stdout-path = &uart0;
++		tick-timer = &timer0;
++	};
++
++	aliases {
++		spi0 = &snand;
++	};
++
++	gpio-keys {
++		compatible = "gpio-keys";
++
++		factory {
++			label = "reset";
++			gpios = <&gpio 0 GPIO_ACTIVE_LOW>;
++		};
++
++		wps {
++			label = "wps";
++			gpios = <&gpio 102 GPIO_ACTIVE_LOW>;
++		};
++	};
++
++	gpio-leds {
++		compatible = "gpio-leds";
++
++		led_power: power_blue {
++			label = "power:blue";
++			gpios = <&gpio 95 GPIO_ACTIVE_LOW>;
++			default-state = "on";
++		};
++
++		power_orange {
++			label = "power:orange";
++			gpios = <&gpio 96 GPIO_ACTIVE_LOW>;
++			default-state = "off";
++		};
++
++		inet_blue {
++			label = "inet:blue";
++			gpios = <&gpio 97 GPIO_ACTIVE_LOW>;
++			default-state = "off";
++		};
++
++		inet_orange {
++			label = "inet:orange";
++			gpios = <&gpio 98 GPIO_ACTIVE_LOW>;
++			default-state = "off";
++		};
++	};
++
++	memory@40000000 {
++		device_type = "memory";
++		reg = <0x40000000 0x20000000>;
++	};
++
++	reg_1p8v: regulator-1p8v {
++		compatible = "regulator-fixed";
++		regulator-name = "fixed-1.8V";
++		regulator-min-microvolt = <1800000>;
++		regulator-max-microvolt = <1800000>;
++		regulator-boot-on;
++		regulator-always-on;
++	};
++
++	reg_3p3v: regulator-3p3v {
++		compatible = "regulator-fixed";
++		regulator-name = "fixed-3.3V";
++		regulator-min-microvolt = <3300000>;
++		regulator-max-microvolt = <3300000>;
++		regulator-boot-on;
++		regulator-always-on;
++	};
++
++	reg_5v: regulator-5v {
++		compatible = "regulator-fixed";
++		regulator-name = "fixed-5V";
++		regulator-min-microvolt = <5000000>;
++		regulator-max-microvolt = <5000000>;
++		regulator-boot-on;
++		regulator-always-on;
++	};
++};
++
++&pcie {
++	pinctrl-names = "default";
++	pinctrl-0 = <&pcie0_pins>, <&pcie1_pins>;
++	status = "okay";
++
++	pcie@0,0 {
++		status = "okay";
++	};
++
++	pcie@1,0 {
++		status = "okay";
++	};
++};
++
++&pinctrl {
++	pcie0_pins: pcie0-pins {
++		mux {
++			function = "pcie";
++			groups = "pcie0_pad_perst",
++				 "pcie0_1_waken",
++				 "pcie0_1_clkreq";
++		};
++	};
++
++	pcie1_pins: pcie1-pins {
++		mux {
++			function = "pcie";
++			groups = "pcie1_pad_perst",
++				 "pcie1_0_waken",
++				 "pcie1_0_clkreq";
++		};
++	};
++
++	snfi_pins: snfi-pins {
++		mux {
++			function = "flash";
++			groups = "snfi";
++		};
++	};
++
++	uart0_pins: uart0 {
++		mux {
++			function = "uart";
++			groups = "uart0_0_tx_rx" ;
++		};
++	};
++
++	watchdog_pins: watchdog-default {
++		mux {
++			function = "watchdog";
++			groups = "watchdog";
++		};
++	};
++};
++
++&snand {
++	pinctrl-names = "default";
++	pinctrl-0 = <&snfi_pins>;
++	status = "okay";
++	quad-spi;
++};
++
++&uart0 {
++	pinctrl-names = "default";
++	pinctrl-0 = <&uart0_pins>;
++	status = "okay";
++};
++
++&watchdog {
++	pinctrl-names = "default";
++	pinctrl-0 = <&watchdog_pins>;
++	status = "okay";
++};
++
++&eth {
++	status = "okay";
++	mediatek,gmac-id = <0>;
++	phy-mode = "sgmii";
++	mediatek,switch = "mt7531";
++	reset-gpios = <&gpio 54 GPIO_ACTIVE_HIGH>;
++
++	fixed-link {
++		speed = <1000>;
++		full-duplex;
++	};
++};
++
++&ssusb {
++	vusb33-supply = <&reg_3p3v>;
++	vbus-supply = <&reg_5v>;
++	status = "okay";
++};
++
++&u3phy {
++	status = "okay";
++};
+--- a/arch/arm/dts/Makefile
++++ b/arch/arm/dts/Makefile
+@@ -1104,6 +1104,7 @@ dtb-$(CONFIG_ARCH_MEDIATEK) += \
+ 	mt7622-rfb.dtb \
+ 	mt7623a-unielec-u7623-02-emmc.dtb \
+ 	mt7622-bananapi-bpi-r64.dtb \
++	mt7622-linksys-e8450-ubi.dtb \
+ 	mt7623n-bananapi-bpi-r2.dtb \
+ 	mt7629-rfb.dtb \
+ 	mt8183-pumpkin.dtb \
+--- /dev/null
++++ b/linksys_e8450_env
+@@ -0,0 +1,57 @@
++ethaddr_factory=mtd read spi-nand0 0x40080000 0x220000 0x20000 && env readmem -b ethaddr 0x4009fff4 0x6 ; setenv ethaddr_factory
++ipaddr=192.168.1.1
++serverip=192.168.1.254
++loadaddr=0x48000000
++bootcmd=if pstore check ; then run boot_recovery ; else run boot_ubi ; fi
++bootconf=config-1
++bootdelay=0
++bootfile=openwrt-mediatek-mt7622-linksys_e8450-ubi-initramfs-recovery.itb
++bootfile_bl2=openwrt-mediatek-mt7622-linksys_e8450-ubi-preloader.bin
++bootfile_fip=openwrt-mediatek-mt7622-linksys_e8450-ubi-bl31-uboot.fip
++bootfile_upg=openwrt-mediatek-mt7622-linksys_e8450-ubi-squashfs-sysupgrade.itb
++bootled_pwr=power:blue
++bootled_rec=inet:orange on
++bootmenu_confirm_return=askenv - Press ENTER to return to menu ; bootmenu 60
++bootmenu_default=0
++bootmenu_delay=0
++bootmenu_title=      [0;34m( ( ( [1;39mOpenWrt[0;34m ) ) )[0m
++bootmenu_0=Initialize environment.=run _firstboot
++bootmenu_0d=Run default boot command.=run boot_default
++bootmenu_1=Boot system via TFTP.=run boot_tftp ; run bootmenu_confirm_return
++bootmenu_2=Boot production system from flash.=run boot_production ; run bootmenu_confirm_return
++bootmenu_3=Boot recovery system from flash.=run boot_recovery ; run bootmenu_confirm_return
++bootmenu_4=Load production system via TFTP then write to flash.=setenv noboot 1 ; setenv replacevol 1 ; run boot_tftp_production ; setenv noboot ; setenv replacevol ; run bootmenu_confirm_return
++bootmenu_5=Load recovery system via TFTP then write to flash.=setenv noboot 1 ; setenv replacevol 1 ; run boot_tftp_recovery ; setenv noboot ; setenv replacevol ; run bootmenu_confirm_return
++bootmenu_6=[31mLoad BL31+U-Boot FIP via TFTP then write to flash.[0m=run boot_tftp_write_fip ; run bootmenu_confirm_return
++bootmenu_7=[31mLoad BL2 preloader via TFTP then write to flash.[0m=run boot_tftp_write_bl2 ; run bootmenu_confirm_return
++bootmenu_8=Reboot.=reset
++bootmenu_9=Reset all settings to factory defaults.=run reset_factory ; reset
++boot_first=if button reset ; then led $bootled_rec on ; run boot_tftp_recovery ; setenv flag_recover 1 ; run boot_default ; fi ; bootmenu
++boot_default=if env exists flag_recover ; then else run bootcmd ; fi ; run boot_recovery ; setenv replacevol 1 ; run boot_tftp_forever
++boot_production=led $bootled_pwr on ; run ubi_read_production && bootm $loadaddr#$bootconf ; led $bootled_pwr off
++boot_recovery=led $bootled_rec on ; run ubi_read_recovery ; bootm $loadaddr#$bootconf ; ubi remove recovery ; led $bootled_rec off
++boot_serial_write_bl2=loadx $loadaddr 115200 && run boot_write_bl2
++boot_serial_write_fip=loadx $loadaddr 115200 && run boot_write_fip
++boot_tftp=tftpboot $loadaddr $bootfile && bootm $loadaddr#$bootconf
++boot_tftp_forever=led $bootled_rec on ; while true ; do run boot_tftp_recovery ; sleep 1 ; done
++boot_tftp_production=tftpboot $loadaddr $bootfile_upg && iminfo $loadaddr && ubi part ubi && run ubi_write_production ubi_prepare_rootfs ; if env exists noboot ; then else bootm $loadaddr#$bootconf ; fi
++boot_tftp_recovery=tftpboot $loadaddr $bootfile && iminfo $loadaddr && ubi part ubi && run ubi_write_recovery ; if env exists noboot ; then else bootm $loadaddr#$bootconf ; fi
++boot_tftp_write_bl2=tftpboot $loadaddr $bootfile_bl2 && run boot_write_bl2
++boot_tftp_write_fip=tftpboot $loadaddr $bootfile_fip && run boot_write_fip
++boot_ubi=ubi part ubi && run boot_production ; run boot_recovery
++boot_write_bl2=mtd erase bl2 && mtd write spi-nand0 $loadaddr 0x0 0x20000 && mtd write spi-nand0 $loadaddr 0x20000 0x20000 && mtd write spi-nand0 $loadaddr 0x40000 0x20000 && mtd write spi-nand0 $loadaddr 0x60000 0x20000
++boot_write_fip=mtd erase fip && mtd write fip $loadaddr
++check_ubi=ubi part ubi || run ubi_format
++reset_factory=ubi part ubi ; ubi write 0x0 ubootenv 0x0 ; ubi write 0x0 ubootenv2 0x0 ; ubi remove rootfs_data
++ubi_format=ubi detach ; mtd erase ubi && ubi part ubi ; reset
++ubi_prepare_rootfs=if ubi check rootfs_data ; then else if env exists rootfs_data_max ; then ubi create rootfs_data $rootfs_data_max dynamic || ubi create rootfs_data - dynamic ; else ubi create rootfs_data - dynamic ; fi ; fi
++ubi_read_production=ubi read $loadaddr fit && iminfo $loadaddr && run ubi_prepare_rootfs
++ubi_read_recovery=ubi check recovery && ubi read $loadaddr recovery
++ubi_remove_rootfs=ubi check rootfs_data && ubi remove rootfs_data
++ubi_write_production=ubi check fit && env exists replacevol && ubi remove fit ; if ubi check fit ; then else run ubi_remove_rootfs ; ubi create fit $filesize dynamic && ubi write $loadaddr fit $filesize ; fi
++ubi_write_recovery=ubi check recovery && env exists replacevol && ubi remove recovery ; if ubi check recovery ; then else run ubi_remove_rootfs ; ubi create recovery $filesize dynamic && ubi write $loadaddr recovery $filesize ; fi
++_create_env=ubi create ubootenv 0x100000 dynamic ; ubi create ubootenv2 0x100000 dynamic
++_init_env=setenv _init_env ; if ubi check ubootenv && ubi check ubootenv2 ; then else run _create_env ; fi ; setenv _create_env ; saveenv || run ubi_format ; saveenv || run ubi_format
++_firstboot=setenv _firstboot ; run _switch_to_menu ; run ethaddr_factory ; run check_ubi ; run _init_env ; run boot_first
++_switch_to_menu=setenv _switch_to_menu ; setenv bootdelay 3 ; setenv bootmenu_delay 3 ; setenv bootmenu_0 $bootmenu_0d ; setenv bootmenu_0d ; run _bootmenu_update_title
++_bootmenu_update_title=setenv _bootmenu_update_title ; setenv bootmenu_title "$bootmenu_title       [33m$ver[0m"
diff --git a/package/boot/uboot-mediatek/patches/412-add-ubnt-unifi-6-lr.patch b/package/boot/uboot-mediatek/patches/412-add-ubnt-unifi-6-lr.patch
new file mode 100644
index 0000000000..6cb0a26c7f
--- /dev/null
+++ b/package/boot/uboot-mediatek/patches/412-add-ubnt-unifi-6-lr.patch
@@ -0,0 +1,453 @@
+--- /dev/null
++++ b/configs/mt7622_ubnt_unifi-6-lr_defconfig
+@@ -0,0 +1,140 @@
++CONFIG_ARM=y
++CONFIG_POSITION_INDEPENDENT=y
++CONFIG_ARCH_MEDIATEK=y
++CONFIG_TARGET_MT7622=y
++CONFIG_SYS_TEXT_BASE=0x41e00000
++CONFIG_SYS_MALLOC_F_LEN=0x4000
++CONFIG_USE_DEFAULT_ENV_FILE=y
++CONFIG_MTDPARTS_DEFAULT="mtdparts=nor0:128k(bl2),640k(fip),64k(u-boot-env),256k(factory),64k(eeprom),15232k(recovery),-(firmware)"
++CONFIG_ENV_IS_IN_MTD=y
++CONFIG_ENV_MTD_NAME="nor0"
++CONFIG_ENV_SIZE_REDUND=0x4000
++CONFIG_ENV_SIZE=0x4000
++CONFIG_ENV_OFFSET=0xc0000
++CONFIG_ENV_VARS_UBOOT_RUNTIME_CONFIG=y
++CONFIG_BOARD_LATE_INIT=y
++CONFIG_RESET_BUTTON_SETTLE_DELAY=400
++CONFIG_BOOTP_SEND_HOSTNAME=y
++CONFIG_DEFAULT_ENV_FILE="ubnt_unifi-6-lr_env"
++CONFIG_DEBUG_UART_BASE=0x11002000
++CONFIG_DEBUG_UART_CLOCK=25000000
++CONFIG_DEFAULT_DEVICE_TREE="mt7622-ubnt-unifi-6-lr"
++CONFIG_DEBUG_UART=y
++CONFIG_SMBIOS_PRODUCT_NAME=""
++CONFIG_AUTOBOOT_KEYED=y
++CONFIG_BOOTDELAY=30
++CONFIG_AUTOBOOT_MENU_SHOW=y
++CONFIG_CFB_CONSOLE_ANSI=y
++CONFIG_BUTTON=y
++CONFIG_BUTTON_GPIO=y
++CONFIG_GPIO_HOG=y
++CONFIG_CMD_ENV_FLAGS=y
++CONFIG_FIT=y
++CONFIG_FIT_ENABLE_SHA256_SUPPORT=y
++CONFIG_LOGLEVEL=7
++CONFIG_LOG=y
++CONFIG_DEFAULT_FDT_FILE="mt7622-ubnt-unifi-6-lr"
++CONFIG_SYS_PROMPT="MT7622> "
++# CONFIG_LEGACY_IMAGE_FORMAT is not set
++# CONFIG_BOOTM_PLAN9 is not set
++# CONFIG_BOOTM_RTEMS is not set
++# CONFIG_BOOTM_VXWORKS is not set
++# CONFIG_EFI is not set
++# CONFIG_EFI_LOADER is not set
++CONFIG_CMD_BOOTMENU=y
++# CONFIG_CMD_BOOTEFI is not set
++CONFIG_CMD_BOOTP=y
++CONFIG_CMD_BUTTON=y
++CONFIG_CMD_CDP=y
++CONFIG_CMD_DHCP=y
++CONFIG_CMD_DNS=y
++CONFIG_CMD_ECHO=y
++# CONFIG_CMD_ELF is not set
++# CONFIG_CMD_BOOTEFI_BOOTMGR is not set
++CONFIG_CMD_ENV_READMEM=y
++CONFIG_CMD_ERASEENV=y
++CONFIG_CMD_GPIO=y
++CONFIG_CMD_HASH=y
++CONFIG_CMD_ITEST=y
++CONFIG_CMD_LED=y
++CONFIG_CMD_LINK_LOCAL=y
++# CONFIG_CMD_MBR is not set
++CONFIG_CMD_MTD=y
++CONFIG_CMD_MTDPART=y
++# CONFIG_CMD_PCI is not set
++CONFIG_CMD_SF_TEST=y
++CONFIG_CMD_PING=y
++CONFIG_CMD_PXE=y
++CONFIG_CMD_SMC=y
++CONFIG_CMD_TFTPBOOT=y
++CONFIG_CMD_TFTPSRV=y
++# CONFIG_CMD_UNLZ4 is not set
++CONFIG_CMD_ASKENV=y
++CONFIG_CMD_PSTORE=y
++CONFIG_CMD_PSTORE_MEM_ADDR=0x42ff0000
++CONFIG_CMD_RARP=y
++CONFIG_CMD_SETEXPR=y
++CONFIG_CMD_SLEEP=y
++CONFIG_CMD_SOURCE=y
++CONFIG_CMD_UUID=y
++CONFIG_DISPLAY_CPUINFO=y
++CONFIG_DM_ETH=y
++CONFIG_DM_ETH_PHY=y
++CONFIG_DM_GPIO=y
++CONFIG_DM_MDIO=y
++CONFIG_DM_MTD=y
++CONFIG_DM_REGULATOR=y
++CONFIG_DM_REGULATOR_FIXED=y
++CONFIG_DM_REGULATOR_GPIO=y
++# CONFIG_DM_MMC is not set
++CONFIG_DM_SERIAL=y
++CONFIG_DM_SPI=y
++CONFIG_DM_SPI_FLASH=y
++CONFIG_HUSH_PARSER=y
++# CONFIG_PARTITION_UUIDS is not set
++CONFIG_SYS_RELOC_GD_ENV_ADDR=y
++# CONFIG_LED is not set
++# CONFIG_LZ4 is not set
++CONFIG_VERSION_VARIABLE=y
++CONFIG_NETCONSOLE=y
++CONFIG_REGMAP=y
++CONFIG_SYSCON=y
++CONFIG_CLK=y
++CONFIG_PHY=y
++CONFIG_PHY_FIXED=y
++CONFIG_PHYLIB_10G=y
++CONFIG_PHY_AQUANTIA=y
++CONFIG_PHY_ADDR_ENABLE=y
++CONFIG_PHY_ADDR=8
++CONFIG_MEDIATEK_ETH=y
++CONFIG_MTD=y
++# CONFIG_MMC is not set
++CONFIG_PINCTRL=y
++CONFIG_PINCONF=y
++CONFIG_PINCTRL_MT7622=y
++CONFIG_POWER_DOMAIN=y
++CONFIG_PRE_CONSOLE_BUFFER=y
++CONFIG_PRE_CON_BUF_ADDR=0x4007EF00
++CONFIG_MTK_POWER_DOMAIN=y
++CONFIG_RAM=y
++CONFIG_MTK_SERIAL=y
++CONFIG_SPI=y
++CONFIG_MTK_SNFI_SPI=y
++CONFIG_MTK_SNOR=y
++CONFIG_SYSRESET_WATCHDOG=y
++CONFIG_WDT_MTK=y
++CONFIG_HEXDUMP=y
++CONFIG_RANDOM_UUID=y
++CONFIG_REGEX=y
++CONFIG_SPI_FLASH=y
++CONFIG_SPI_FLASH_BAR=y
++CONFIG_SPI_FLASH_MTD=y
++CONFIG_SPI_FLASH_UNLOCK_ALL=y
++CONFIG_SPI_FLASH_EON=y
++CONFIG_SPI_FLASH_GIGADEVICE=y
++CONFIG_SPI_FLASH_MACRONIX=y
++CONFIG_SPI_FLASH_SPANSION=y
++CONFIG_SPI_FLASH_STMICRO=y
++CONFIG_SPI_FLASH_SST=y
++CONFIG_SPI_FLASH_WINBOND=y
++CONFIG_SPI_FLASH_XMC=y
+--- /dev/null
++++ b/arch/arm/dts/mt7622-ubnt-unifi-6-lr.dts
+@@ -0,0 +1,202 @@
++// SPDX-License-Identifier: GPL-2.0
++/*
++ * Copyright (c) 2019 MediaTek Inc.
++ * Author: Sam Shih <sam.shih@mediatek.com>
++ */
++
++/dts-v1/;
++#include "mt7622.dtsi"
++#include "mt7622-u-boot.dtsi"
++
++/ {
++	#address-cells = <1>;
++	#size-cells = <1>;
++	model = "mt7622-ubnt-unifi-6-lr";
++	compatible = "mediatek,mt7622", "ubnt,unifi-6-lr";
++
++	chosen {
++		stdout-path = &uart0;
++		tick-timer = &timer0;
++	};
++
++	aliases {
++		spi0 = &snor;
++	};
++
++	gpio-keys {
++		compatible = "gpio-keys";
++		u-boot,dm-pre-reloc;
++
++		reset {
++			label = "reset";
++			gpios = <&gpio 62 GPIO_ACTIVE_LOW>;
++			u-boot,dm-pre-reloc;
++		};
++	};
++
++	memory@40000000 {
++		device_type = "memory";
++		reg = <0x40000000 0x20000000>;
++	};
++
++	reg_1p8v: regulator-1p8v {
++		compatible = "regulator-fixed";
++		regulator-name = "fixed-1.8V";
++		regulator-min-microvolt = <1800000>;
++		regulator-max-microvolt = <1800000>;
++		regulator-boot-on;
++		regulator-always-on;
++	};
++
++	reg_3p3v: regulator-3p3v {
++		compatible = "regulator-fixed";
++		regulator-name = "fixed-3.3V";
++		regulator-min-microvolt = <3300000>;
++		regulator-max-microvolt = <3300000>;
++		regulator-boot-on;
++		regulator-always-on;
++	};
++
++	reg_5v: regulator-5v {
++		compatible = "regulator-fixed";
++		regulator-name = "fixed-5V";
++		regulator-min-microvolt = <5000000>;
++		regulator-max-microvolt = <5000000>;
++		regulator-boot-on;
++		regulator-always-on;
++	};
++};
++
++&pcie {
++	pinctrl-names = "default";
++	pinctrl-0 = <&pcie0_pins>, <&pcie1_pins>;
++	status = "okay";
++
++	pcie@0,0 {
++		status = "okay";
++	};
++
++	pcie@1,0 {
++		status = "okay";
++	};
++};
++
++&pinctrl {
++	eth_pins: eth-pins {
++		mux {
++			function = "eth";
++			groups = "mdc_mdio", "rgmii_via_gmac2";
++		};
++	};
++
++	pcie0_pins: pcie0-pins {
++		mux {
++			function = "pcie";
++			groups = "pcie0_pad_perst",
++				 "pcie0_1_waken",
++				 "pcie0_1_clkreq";
++		};
++	};
++
++	pcie1_pins: pcie1-pins {
++		mux {
++			function = "pcie";
++			groups = "pcie1_pad_perst",
++				 "pcie1_0_waken",
++				 "pcie1_0_clkreq";
++		};
++	};
++
++	snfi_pins: snfi-pins {
++		mux {
++			function = "flash";
++			groups = "snfi";
++		};
++	};
++
++	snor_pins: snor-pins {
++		mux {
++			function = "flash";
++			groups = "spi_nor";
++		};
++	};
++
++	uart0_pins: uart0 {
++		mux {
++			function = "uart";
++			groups = "uart0_0_tx_rx" ;
++		};
++	};
++
++	watchdog_pins: watchdog-default {
++		mux {
++			function = "watchdog";
++			groups = "watchdog";
++		};
++	};
++};
++
++&snfi {
++	pinctrl-names = "default", "snfi";
++	pinctrl-0 = <&snor_pins>;
++	pinctrl-1 = <&snfi_pins>;
++	status = "okay";
++
++	spi-flash@0 {
++		compatible = "jedec,spi-nor";
++		reg = <0>;
++		u-boot,dm-pre-reloc;
++	};
++};
++
++&snor {
++	pinctrl-names = "default";
++	pinctrl-0 = <&snor_pins>;
++	status = "okay";
++
++	spi-flash@0 {
++		compatible = "jedec,spi-nor";
++		reg = <0>;
++		spi-tx-bus-width = <1>;
++		spi-rx-bus-width = <4>;
++		u-boot,dm-pre-reloc;
++	};
++};
++
++&uart0 {
++	pinctrl-names = "default";
++	pinctrl-0 = <&uart0_pins>;
++	status = "okay";
++};
++
++&watchdog {
++	pinctrl-names = "default";
++	pinctrl-0 = <&watchdog_pins>;
++	status = "okay";
++};
++
++&eth {
++	status = "okay";
++	pinctrl-names = "default";
++	pinctrl-0 = <&eth_pins>;
++
++	mediatek,gmac-id = <0>;
++	phy-mode = "sgmii";
++	phy-handle = <&gphy>;
++
++	fixed-link {
++		speed = <1000>;
++		full-duplex;
++	};
++
++	mdio-bus {
++		#address-cells = <1>;
++		#size-cells = <0>;
++
++		gphy: ethernet-phy@8 {
++			/* Marvell AQRate AQR112W - no driver */
++			compatible = "ethernet-phy-ieee802.3-c45";
++			reg = <0x8>;
++		};
++	};
++};
+--- a/arch/arm/dts/Makefile
++++ b/arch/arm/dts/Makefile
+@@ -1105,6 +1105,7 @@ dtb-$(CONFIG_ARCH_MEDIATEK) += \
+ 	mt7623a-unielec-u7623-02-emmc.dtb \
+ 	mt7622-bananapi-bpi-r64.dtb \
+ 	mt7622-linksys-e8450-ubi.dtb \
++	mt7622-ubnt-unifi-6-lr.dtb \
+ 	mt7623n-bananapi-bpi-r2.dtb \
+ 	mt7629-rfb.dtb \
+ 	mt8183-pumpkin.dtb \
+--- /dev/null
++++ b/ubnt_unifi-6-lr_env
+@@ -0,0 +1,50 @@
++ethaddr_factory=mtd read nor0 $loadaddr 0x110000 0x10000 && env readmem -b ethaddr $loadaddr 0x6 ; setenv ethaddr_factory
++ipaddr=192.168.1.1
++serverip=192.168.1.254
++loadaddr=0x48000000
++bootcmd=if pstore check ; then run boot_recovery ; else run boot_nor ; fi
++bootdelay=0
++bootfile=openwrt-mediatek-mt7622-ubnt_unifi-6-lr-ubootmod-initramfs-recovery.itb
++bootfile_bl2=openwrt-mediatek-mt7622-ubnt_unifi-6-lr-ubootmod-preloader.bin
++bootfile_fip=openwrt-mediatek-mt7622-ubnt_unifi-6-lr-ubootmod-bl31-uboot.fip
++bootfile_upg=openwrt-mediatek-mt7622-ubnt_unifi-6-lr-ubootmod-squashfs-sysupgrade.itb
++bootmenu_confirm_return=askenv - Press ENTER to return to menu ; bootmenu 60
++bootmenu_default=0
++bootmenu_delay=0
++bootmenu_title=      [0;34m( ( ( [1;39mOpenWrt[0;34m ) ) )[0m
++bootmenu_0=Initialize environment.=run _firstboot
++bootmenu_0d=Run default boot command.=run boot_default
++bootmenu_1=Boot system via TFTP.=run boot_tftp ; run bootmenu_confirm_return
++bootmenu_2=Boot production system from flash.=run boot_production ; run bootmenu_confirm_return
++bootmenu_3=Boot recovery system from flash.=run boot_recovery ; run bootmenu_confirm_return
++bootmenu_4=Load production system via TFTP then write to flash.=setenv noboot 1 ; setenv replacevol 1 ; run boot_tftp_production ; setenv noboot ; setenv replacevol ; run bootmenu_confirm_return
++bootmenu_5=Load recovery system via TFTP then write to flash.=setenv noboot 1 ; setenv replacevol 1 ; run boot_tftp_recovery ; setenv noboot ; setenv replacevol ; run bootmenu_confirm_return
++bootmenu_6=[31mLoad BL31+U-Boot FIP via TFTP then write to flash.[0m=run boot_tftp_write_fip ; run bootmenu_confirm_return
++bootmenu_7=[31mLoad BL2 preloader via TFTP then write to flash.[0m=run boot_tftp_write_preloader ; run bootmenu_confirm_return
++bootmenu_8=Reboot.=reset
++bootmenu_9=Reset all settings to factory defaults.=run reset_factory ; reset
++boot_first=if button reset ; then run boot_tftp_recovery ; setenv flag_recover 1 ; run boot_default ; fi ; bootmenu
++boot_default=if env exists flag_recover ; then else run bootcmd ; fi ; run boot_recovery ; setenv replacevol 1 ; run boot_tftp_forever
++boot_production=run nor_read_production && bootm $loadaddr
++boot_recovery=run nor_read_recovery ; bootm $loadaddr
++boot_serial_write_fip=loadx $loadaddr 115200 && run boot_write_fip
++boot_serial_write_preloader=loadx $loadaddr 115200 && run boot_write_preloader
++boot_tftp_forever=while true ; do run boot_tftp_recovery ; sleep 1 ; done
++boot_tftp_production=tftpboot $loadaddr $bootfile_upg && env exists replacevol && iminfo $loadaddr && run nor_write_production ; if env exists noboot ; then else bootm $loadaddr ; fi
++boot_tftp_recovery=tftpboot $loadaddr $bootfile && env exists replacevol && iminfo $loadaddr && run nor_write_recovery ; if env exists noboot ; then else bootm $loadaddr ; fi
++boot_tftp=tftpboot $loadaddr $bootfile && bootm $loadaddr
++boot_tftp_write_fip=tftpboot $loadaddr $bootfile_fip && run boot_write_fip
++boot_tftp_write_preloader=tftpboot $loadaddr $bootfile_bl2 && run boot_write_preloader
++boot_nor=run boot_production ; run boot_recovery
++boot_write_fip=mtd erase nor0 0x20000 0x80000 && mtd write nor0 $loadaddr 0x20000 0x80000
++boot_write_preloader=mtd erase nor0 0x0 0x20000 && mtd write nor0 $loadaddr 0x0 0x20000
++reset_factory=mtd erase nor0 0xc0000 0x10000 && reset
++nor_read_production=mtd read nor0 $loadaddr 0x1000000 0x1000 && imsz $loadaddr image_size && mtd read nor0 $loadaddr 0x1000000 $image_size
++nor_read_recovery=mtd read nor0 $loadaddr 0x120000 0x1000 && imsz $loadaddr image_size && mtd read nor0 $loadaddr 0x120000 $image_size
++nor_pad_size=imsz $loadaddr image_size ; setexpr image_eb $image_size / 0x1000 ; setexpr tmp1 image_size % 0x1000 ; test 0x$tmp1 -gt 0 && setexpr image_eb $image_eb + 1 ; setexpr image_eb $image_eb * 0x1000
++nor_write_production=run nor_pad_size ; test 0x$image_eb -le 0x3000000 && mtd erase nor0 0x1000000 0x$image_eb && mtd write nor0 $loadaddr 0x1000000 $filesize
++nor_write_recovery=run nor_pad_size ; test 0x$image_eb -le 0xee0000 && mtd erase nor0 0x120000 0x$image_eb && mtd write nor0 $loadaddr 0x120000 $filesize
++_init_env=setenv _init_env ; saveenv
++_firstboot=setenv _firstboot ; run _switch_to_menu ; run ethaddr_factory ; run _init_env ; run boot_first
++_switch_to_menu=setenv _switch_to_menu ; setenv bootdelay 3 ; setenv bootmenu_delay 3 ; setenv bootmenu_0 $bootmenu_0d ; setenv bootmenu_0d ; run _bootmenu_update_title
++_bootmenu_update_title=setenv _bootmenu_update_title ; setenv bootmenu_title "$bootmenu_title       [33m$ver[0m"
+--- a/common/board_r.c
++++ b/common/board_r.c
+@@ -77,6 +77,7 @@
+ #ifdef CONFIG_EFI_SETUP_EARLY
+ #include <efi_loader.h>
+ #endif
++#include <spi_flash.h>
+ 
+ DECLARE_GLOBAL_DATA_PTR;
+ 
+@@ -416,6 +417,21 @@ static int initr_onenand(void)
+ }
+ #endif
+ 
++#if defined(CONFIG_SPI_FLASH)
++/* probe SPI FLASH */
++static int initr_spiflash(void)
++{
++	struct udevice *new;
++
++	spi_flash_probe_bus_cs(CONFIG_SF_DEFAULT_BUS,
++				CONFIG_SF_DEFAULT_CS,
++				CONFIG_SF_DEFAULT_SPEED,
++				CONFIG_SF_DEFAULT_MODE,
++				&new);
++	return 0;
++}
++#endif
++
+ #ifdef CONFIG_MMC
+ static int initr_mmc(void)
+ {
+@@ -705,6 +721,9 @@ static init_fnc_t init_sequence_r[] = {
+ #ifdef CONFIG_CMD_ONENAND
+ 	initr_onenand,
+ #endif
++#ifdef CONFIG_SPI_FLASH
++	initr_spiflash,
++#endif
+ #ifdef CONFIG_MMC
+ 	initr_mmc,
+ #endif
diff --git a/scripts/mkits.sh b/scripts/mkits.sh
index bb629d6fca..7533baf799 100755
--- a/scripts/mkits.sh
+++ b/scripts/mkits.sh
@@ -23,18 +23,30 @@ usage() {
 	printf "\n\t-c ==> set config name 'config'"
 	printf "\n\t-a ==> set load address to 'addr' (hex)"
 	printf "\n\t-e ==> set entry point to 'entry' (hex)"
+	printf "\n\t-f ==> set device tree compatible string"
+	printf "\n\t-i ==> include initrd Blob 'initrd'"
 	printf "\n\t-v ==> set kernel version to 'version'"
 	printf "\n\t-k ==> include kernel image 'kernel'"
 	printf "\n\t-D ==> human friendly Device Tree Blob 'name'"
 	printf "\n\t-n ==> fdt unit-address 'address'"
 	printf "\n\t-d ==> include Device Tree Blob 'dtb'"
-	printf "\n\t-o ==> create output file 'its_file'\n"
+	printf "\n\t-r ==> include RootFS blob 'rootfs'"
+	printf "\n\t-H ==> specify hash algo instead of SHA1"
+	printf "\n\t-o ==> create output file 'its_file'"
+	printf "\n\t-O ==> create config with dt overlay 'name:dtb'"
+	printf "\n\t\t(can be specified more than once)\n"
 	exit 1
 }
 
 FDTNUM=1
+ROOTFSNUM=1
+INITRDNUM=1
+HASH=sha1
+LOADABLES=
+DTOVERLAY=
+DTADDR=
 
-while getopts ":A:a:c:C:D:d:e:k:n:o:v:" OPTION
+while getopts ":A:a:c:C:D:d:e:f:i:k:n:o:O:v:r:S" OPTION
 do
 	case $OPTION in
 		A ) ARCH=$OPTARG;;
@@ -44,9 +56,14 @@ do
 		D ) DEVICE=$OPTARG;;
 		d ) DTB=$OPTARG;;
 		e ) ENTRY_ADDR=$OPTARG;;
+		f ) COMPATIBLE=$OPTARG;;
+		i ) INITRD=$OPTARG;;
 		k ) KERNEL=$OPTARG;;
 		n ) FDTNUM=$OPTARG;;
 		o ) OUTPUT=$OPTARG;;
+		O ) DTOVERLAY="$DTOVERLAY ${OPTARG}";;
+		r ) ROOTFS=$OPTARG;;
+		S ) HASH=$OPTARG;;
 		v ) VERSION=$OPTARG;;
 		* ) echo "Invalid option passed to '$0' (options:$*)"
 		usage;;
@@ -62,26 +79,120 @@ fi
 
 ARCH_UPPER=$(echo "$ARCH" | tr '[:lower:]' '[:upper:]')
 
+if [ -n "${COMPATIBLE}" ]; then
+	COMPATIBLE_PROP="compatible = \"${COMPATIBLE}\";"
+fi
+
+[ "$DTOVERLAY" ] && {
+	dtbsize=$(wc -c "$DTB" | cut -d' ' -f1)
+	DTADDR=$(printf "0x%08x" $(($LOAD_ADDR - $dtbsize)) )
+}
+
 # Conditionally create fdt information
 if [ -n "${DTB}" ]; then
 	FDT_NODE="
-		fdt@$FDTNUM {
+		fdt-$FDTNUM {
 			description = \"${ARCH_UPPER} OpenWrt ${DEVICE} device tree blob\";
+			${COMPATIBLE_PROP}
 			data = /incbin/(\"${DTB}\");
 			type = \"flat_dt\";
+			${DTADDR:+load = <${DTADDR}>;}
+			arch = \"${ARCH}\";
+			compression = \"none\";
+			hash@1 {
+				algo = \"crc32\";
+			};
+			hash@2 {
+				algo = \"${HASH}\";
+			};
+		};
+"
+	FDT_PROP="fdt = \"fdt-$FDTNUM\";"
+fi
+
+if [ -n "${INITRD}" ]; then
+	INITRD_NODE="
+		initrd-$INITRDNUM {
+			description = \"${ARCH_UPPER} OpenWrt ${DEVICE} initrd\";
+			${COMPATIBLE_PROP}
+			data = /incbin/(\"${INITRD}\");
+			type = \"ramdisk\";
+			arch = \"${ARCH}\";
+			os = \"linux\";
+			hash@1 {
+				algo = \"crc32\";
+			};
+			hash@2 {
+				algo = \"${HASH}\";
+			};
+		};
+"
+	INITRD_PROP="ramdisk=\"initrd-${INITRDNUM}\";"
+fi
+
+
+if [ -n "${ROOTFS}" ]; then
+	dd if="${ROOTFS}" of="${ROOTFS}.pagesync" bs=4096 conv=sync
+	ROOTFS_NODE="
+		rootfs-$ROOTFSNUM {
+			description = \"${ARCH_UPPER} OpenWrt ${DEVICE} rootfs\";
+			${COMPATIBLE_PROP}
+			data = /incbin/(\"${ROOTFS}.pagesync\");
+			type = \"filesystem\";
 			arch = \"${ARCH}\";
 			compression = \"none\";
 			hash@1 {
 				algo = \"crc32\";
 			};
 			hash@2 {
-				algo = \"sha1\";
+				algo = \"${HASH}\";
 			};
 		};
 "
-	FDT_PROP="fdt = \"fdt@$FDTNUM\";"
+	LOADABLES="${LOADABLES:+$LOADABLES, }\"rootfs-${ROOTFSNUM}\""
 fi
 
+# add DT overlay blobs
+FDTOVERLAY_NODE=""
+OVCONFIGS=""
+[ "$DTOVERLAY" ] && for overlay in $DTOVERLAY ; do
+	overlay_blob=${overlay##*:}
+	ovname=${overlay%%:*}
+	ovnode="fdt-$ovname"
+	ovsize=$(wc -c "$overlay_blob" | cut -d' ' -f1)
+	echo "$ovname ($overlay_blob) : $ovsize" >&2
+	DTADDR=$(printf "0x%08x" $(($DTADDR - $ovsize)))
+	FDTOVERLAY_NODE="$FDTOVERLAY_NODE
+
+		$ovnode {
+			description = \"${ARCH_UPPER} OpenWrt ${DEVICE} device tree overlay $ovname\";
+			${COMPATIBLE_PROP}
+			data = /incbin/(\"${overlay_blob}\");
+			type = \"flat_dt\";
+			arch = \"${ARCH}\";
+			load = <${DTADDR}>;
+			compression = \"none\";
+			hash@1 {
+				algo = \"crc32\";
+			};
+			hash@2 {
+				algo = \"${HASH}\";
+			};
+		};
+"
+	OVCONFIGS="$OVCONFIGS
+
+		config-$ovname {
+			description = \"OpenWrt ${DEVICE} with $ovname\";
+			kernel = \"kernel-1\";
+			fdt = \"fdt-$FDTNUM\", \"$ovnode\";
+			${LOADABLES:+loadables = ${LOADABLES};}
+			${COMPATIBLE_PROP}
+			${INITRD_PROP}
+		};
+	"
+done
+
 # Create a default, fully populated DTS file
 DATA="/dts-v1/;
 
@@ -90,7 +201,7 @@ DATA="/dts-v1/;
 	#address-cells = <1>;
 
 	images {
-		kernel@1 {
+		kernel-1 {
 			description = \"${ARCH_UPPER} OpenWrt Linux-${VERSION}\";
 			data = /incbin/(\"${KERNEL}\");
 			type = \"kernel\";
@@ -103,19 +214,26 @@ DATA="/dts-v1/;
 				algo = \"crc32\";
 			};
 			hash@2 {
-				algo = \"sha1\";
+				algo = \"$HASH\";
 			};
 		};
+${INITRD_NODE}
 ${FDT_NODE}
+${FDTOVERLAY_NODE}
+${ROOTFS_NODE}
 	};
 
 	configurations {
 		default = \"${CONFIG}\";
 		${CONFIG} {
-			description = \"OpenWrt\";
-			kernel = \"kernel@1\";
+			description = \"OpenWrt ${DEVICE}\";
+			kernel = \"kernel-1\";
 			${FDT_PROP}
+			${LOADABLES:+loadables = ${LOADABLES};}
+			${COMPATIBLE_PROP}
+			${INITRD_PROP}
 		};
+		${OVCONFIGS}
 	};
 };"
 
diff --git a/scripts/target-metadata.pl b/scripts/target-metadata.pl
index 78f77b16d5..beac95f726 100755
--- a/scripts/target-metadata.pl
+++ b/scripts/target-metadata.pl
@@ -44,6 +44,7 @@ sub target_config_features(@) {
 		/^rootfs-part$/ and $ret .= "\tselect USES_ROOTFS_PART\n";
 		/^boot-part$/ and $ret .= "\tselect USES_BOOT_PART\n";
 		/^testing-kernel$/ and $ret .= "\tselect HAS_TESTING_KERNEL\n";
+		/^dt-overlay$/ and $ret .= "\tselect HAS_DT_OVERLAY_SUPPORT\n";
 	}
 	return $ret;
 }
diff --git a/target/Config.in b/target/Config.in
index 43de4710df..b302a52160 100644
--- a/target/Config.in
+++ b/target/Config.in
@@ -16,6 +16,9 @@ config HAS_FPU
 config AUDIO_SUPPORT
 	bool
 
+config HAS_DT_OVERLAY_SUPPORT
+	bool
+
 config GPIO_SUPPORT
 	bool
 
diff --git a/target/linux/generic/config-5.4 b/target/linux/generic/config-5.4
index 73ba6afc6e..198a02260d 100644
--- a/target/linux/generic/config-5.4
+++ b/target/linux/generic/config-5.4
@@ -1705,6 +1705,7 @@ CONFIG_FILE_LOCKING=y
 # CONFIG_FIRMWARE_EDID is not set
 # CONFIG_FIRMWARE_IN_KERNEL is not set
 # CONFIG_FIRMWARE_MEMMAP is not set
+# CONFIG_FIT_PARTITION is not set
 # CONFIG_FIXED_PHY is not set
 CONFIG_FLATMEM=y
 CONFIG_FLATMEM_MANUAL=y
diff --git a/target/linux/generic/files/block/partitions/fit.c b/target/linux/generic/files/block/partitions/fit.c
new file mode 100644
index 0000000000..9bb6e74950
--- /dev/null
+++ b/target/linux/generic/files/block/partitions/fit.c
@@ -0,0 +1,254 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ *  fs/partitions/fit.c
+ *  Copyright (C) 2021  Daniel Golle
+ *
+ *  headers extracted from U-Boot mkimage sources
+ *  (C) Copyright 2008 Semihalf
+ *  (C) Copyright 2000-2005
+ *  Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+ *
+ *  based on existing partition parsers
+ *  Copyright (C) 1991-1998  Linus Torvalds
+ *  Re-organised Feb 1998 Russell King
+ */
+
+#define pr_fmt(fmt) fmt
+
+#include <linux/types.h>
+#include <linux/of.h>
+#include <linux/of_device.h>
+#include <linux/of_fdt.h>
+#include <linux/libfdt.h>
+
+#include "check.h"
+
+#define FIT_IMAGES_PATH		"/images"
+#define FIT_CONFS_PATH		"/configurations"
+
+/* hash/signature/key node */
+#define FIT_HASH_NODENAME	"hash"
+#define FIT_ALGO_PROP		"algo"
+#define FIT_VALUE_PROP		"value"
+#define FIT_IGNORE_PROP		"uboot-ignore"
+#define FIT_SIG_NODENAME	"signature"
+#define FIT_KEY_REQUIRED	"required"
+#define FIT_KEY_HINT		"key-name-hint"
+
+/* cipher node */
+#define FIT_CIPHER_NODENAME	"cipher"
+#define FIT_ALGO_PROP		"algo"
+
+/* image node */
+#define FIT_DATA_PROP		"data"
+#define FIT_DATA_POSITION_PROP	"data-position"
+#define FIT_DATA_OFFSET_PROP	"data-offset"
+#define FIT_DATA_SIZE_PROP	"data-size"
+#define FIT_TIMESTAMP_PROP	"timestamp"
+#define FIT_DESC_PROP		"description"
+#define FIT_ARCH_PROP		"arch"
+#define FIT_TYPE_PROP		"type"
+#define FIT_OS_PROP		"os"
+#define FIT_COMP_PROP		"compression"
+#define FIT_ENTRY_PROP		"entry"
+#define FIT_LOAD_PROP		"load"
+
+/* configuration node */
+#define FIT_KERNEL_PROP		"kernel"
+#define FIT_FILESYSTEM_PROP	"filesystem"
+#define FIT_RAMDISK_PROP	"ramdisk"
+#define FIT_FDT_PROP		"fdt"
+#define FIT_LOADABLE_PROP	"loadables"
+#define FIT_DEFAULT_PROP	"default"
+#define FIT_SETUP_PROP		"setup"
+#define FIT_FPGA_PROP		"fpga"
+#define FIT_FIRMWARE_PROP	"firmware"
+#define FIT_STANDALONE_PROP	"standalone"
+
+#define FIT_MAX_HASH_LEN	HASH_MAX_DIGEST_SIZE
+
+#define MIN_FREE_SECT		16
+#define REMAIN_VOLNAME		"rootfs_data"
+
+int parse_fit_partitions(struct parsed_partitions *state, u64 fit_start_sector, u64 sectors, int *slot, int add_remain)
+{
+	struct address_space *mapping = state->bdev->bd_inode->i_mapping;
+	struct page *page;
+	void *fit, *init_fit;
+	struct partition_meta_info *info;
+	char tmp[sizeof(info->volname)];
+	u64 dsize, dsectors, imgmaxsect = 0;
+	u32 size, image_pos, image_len;
+	const u32 *image_offset_be, *image_len_be, *image_pos_be;
+	int ret = 1, node, images, config;
+	const char *image_name, *image_type, *image_description, *config_default,
+		*config_description, *config_loadables;
+	int image_name_len, image_type_len, image_description_len, config_default_len,
+		config_description_len, config_loadables_len;
+	sector_t start_sect, nr_sects;
+	size_t label_min;
+
+	if (fit_start_sector % (1<<(PAGE_SHIFT - SECTOR_SHIFT)))
+		return -ERANGE;
+
+	page = read_mapping_page(mapping, fit_start_sector >> (PAGE_SHIFT - SECTOR_SHIFT), NULL);
+	if (!page)
+		return -ENOMEM;
+
+	init_fit = page_address(page);
+
+	if (!init_fit) {
+		put_page(page);
+		return -EFAULT;
+	}
+
+	if (fdt_check_header(init_fit)) {
+		put_page(page);
+		return 0;
+	}
+
+	dsectors = get_capacity(state->bdev->bd_disk);
+	if (sectors)
+		dsectors = (dsectors>sectors)?sectors:dsectors;
+
+	dsize = dsectors << SECTOR_SHIFT;
+	printk(KERN_DEBUG "FIT: volume size: %llu sectors (%llu bytes)\n", dsectors, dsize);
+
+	size = fdt_totalsize(init_fit);
+	printk(KERN_DEBUG "FIT: FDT structure size: %u bytes\n", size);
+	if (size > PAGE_SIZE) {
+		printk(KERN_ERR "FIT: FDT structure beyond page boundaries, use 'mkimage -E ...'!\n");
+		put_page(page);
+		return -ENOTSUPP;
+	}
+
+	if (size >= dsize) {
+		put_page(page);
+		state->access_beyond_eod = (size >= dsize);
+		return 0;
+	}
+
+	fit = kmemdup(init_fit, size, GFP_KERNEL);
+	put_page(page);
+	if (!fit)
+		return -ENOMEM;
+
+	config = fdt_path_offset(fit, FIT_CONFS_PATH);
+	if (config < 0) {
+		printk(KERN_ERR "FIT: Cannot find %s node: %d\n", FIT_CONFS_PATH, images);
+		ret = -ENOENT;
+		goto ret_out;
+	}
+
+	config_default = fdt_getprop(fit, config, FIT_DEFAULT_PROP, &config_default_len);
+
+	if (!config_default) {
+		printk(KERN_ERR "FIT: Cannot find default configuration\n");
+		ret = -ENOENT;
+		goto ret_out;
+	}
+
+	node = fdt_subnode_offset(fit, config, config_default);
+	if (node < 0) {
+		printk(KERN_ERR "FIT: Cannot find %s node: %d\n", config_default, node);
+		ret = -ENOENT;
+		goto ret_out;
+	}
+
+	config_description = fdt_getprop(fit, node, FIT_DESC_PROP, &config_description_len);
+	config_loadables = fdt_getprop(fit, node, FIT_LOADABLE_PROP, &config_loadables_len);
+
+	printk(KERN_DEBUG "FIT: Default configuration: %s%s%s%s\n", config_default,
+		config_description?" (":"", config_description?:"", config_description?")":"");
+
+	images = fdt_path_offset(fit, FIT_IMAGES_PATH);
+	if (images < 0) {
+		printk(KERN_ERR "FIT: Cannot find %s node: %d\n", FIT_IMAGES_PATH, images);
+		ret = -EINVAL;
+		goto ret_out;
+	}
+
+	fdt_for_each_subnode(node, fit, images) {
+		image_name = fdt_get_name(fit, node, &image_name_len);
+		image_type = fdt_getprop(fit, node, FIT_TYPE_PROP, &image_type_len);
+		image_offset_be = fdt_getprop(fit, node, FIT_DATA_OFFSET_PROP, NULL);
+		image_pos_be = fdt_getprop(fit, node, FIT_DATA_POSITION_PROP, NULL);
+		image_len_be = fdt_getprop(fit, node, FIT_DATA_SIZE_PROP, NULL);
+		if (!image_name || !image_type || !image_len_be)
+			continue;
+
+		image_len = be32_to_cpu(*image_len_be);
+		if (!image_len)
+			continue;
+
+		if (image_offset_be)
+			image_pos = be32_to_cpu(*image_offset_be) + size;
+		else if (image_pos_be)
+			image_pos = be32_to_cpu(*image_pos_be);
+		else
+			continue;
+
+		image_description = fdt_getprop(fit, node, FIT_DESC_PROP, &image_description_len);
+
+		printk(KERN_DEBUG "FIT: %16s sub-image 0x%08x - 0x%08x '%s' %s%s%s\n",
+			image_type, image_pos, image_pos + image_len, image_name,
+			image_description?"(":"", image_description?:"", image_description?") ":"");
+
+		if (strcmp(image_type, FIT_FILESYSTEM_PROP))
+			continue;
+
+		if (image_pos & ((1 << PAGE_SHIFT)-1)) {
+			printk(KERN_ERR "FIT: image %s start not aligned to page boundaries, skipping\n", image_name);
+			continue;
+		}
+
+		if (image_len & ((1 << PAGE_SHIFT)-1)) {
+			printk(KERN_ERR "FIT: sub-image %s end not aligned to page boundaries, skipping\n", image_name);
+			continue;
+		}
+
+		start_sect = image_pos >> SECTOR_SHIFT;
+		nr_sects = image_len >> SECTOR_SHIFT;
+		imgmaxsect = (imgmaxsect < (start_sect + nr_sects))?(start_sect + nr_sects):imgmaxsect;
+
+		if (start_sect + nr_sects > dsectors) {
+			state->access_beyond_eod = 1;
+			continue;
+		}
+
+		put_partition(state, ++(*slot), fit_start_sector + start_sect, nr_sects);
+		state->parts[*slot].flags = 0;
+		info = &state->parts[*slot].info;
+
+		label_min = min_t(int, sizeof(info->volname) - 1, image_name_len);
+		strncpy(info->volname, image_name, label_min);
+		info->volname[label_min] = '\0';
+
+		snprintf(tmp, sizeof(tmp), "(%s)", info->volname);
+		strlcat(state->pp_buf, tmp, PAGE_SIZE);
+
+		state->parts[*slot].has_info = true;
+
+		if (config_loadables && !strcmp(image_name, config_loadables)) {
+			printk(KERN_DEBUG "FIT: selecting configured loadable %s to be root filesystem\n", image_name);
+			state->parts[*slot].flags |= ADDPART_FLAG_ROOTDEV;
+		}
+	}
+
+	if (add_remain && (imgmaxsect + MIN_FREE_SECT) < dsectors) {
+		put_partition(state, ++(*slot), fit_start_sector + imgmaxsect, dsectors - imgmaxsect);
+		state->parts[*slot].flags = 0;
+		info = &state->parts[*slot].info;
+		strcpy(info->volname, REMAIN_VOLNAME);
+		snprintf(tmp, sizeof(tmp), "(%s)", REMAIN_VOLNAME);
+		strlcat(state->pp_buf, tmp, PAGE_SIZE);
+	}
+ret_out:
+	kfree(fit);
+	return ret;
+}
+
+int fit_partition(struct parsed_partitions *state) {
+	int slot = 0;
+	return parse_fit_partitions(state, 0, 0, &slot, 0);
+}
\ No newline at end of file
diff --git a/target/linux/generic/hack-5.4/400-block-fit-partition-parser.patch b/target/linux/generic/hack-5.4/400-block-fit-partition-parser.patch
new file mode 100644
index 0000000000..888424c023
--- /dev/null
+++ b/target/linux/generic/hack-5.4/400-block-fit-partition-parser.patch
@@ -0,0 +1,200 @@
+--- a/block/partitions/Kconfig
++++ b/block/partitions/Kconfig
+@@ -101,6 +101,13 @@ config ATARI_PARTITION
+ 	  Say Y here if you would like to use hard disks under Linux which
+ 	  were partitioned under the Atari OS.
+ 
++config FIT_PARTITION
++	bool "Flattened-Image-Tree (FIT) partition support" if PARTITION_ADVANCED
++	default n
++	help
++	  Say Y here if your system needs to mount the filesystem part of
++	  a Flattened-Image-Tree (FIT) image commonly used with Das U-Boot.
++
+ config IBM_PARTITION
+ 	bool "IBM disk label and partition support"
+ 	depends on PARTITION_ADVANCED && S390
+--- a/block/partitions/Makefile
++++ b/block/partitions/Makefile
+@@ -9,6 +9,7 @@ obj-$(CONFIG_ACORN_PARTITION) += acorn.o
+ obj-$(CONFIG_AMIGA_PARTITION) += amiga.o
+ obj-$(CONFIG_ATARI_PARTITION) += atari.o
+ obj-$(CONFIG_AIX_PARTITION) += aix.o
++obj-$(CONFIG_FIT_PARTITION) += fit.o
+ obj-$(CONFIG_CMDLINE_PARTITION) += cmdline.o
+ obj-$(CONFIG_MAC_PARTITION) += mac.o
+ obj-$(CONFIG_LDM_PARTITION) += ldm.o
+--- a/drivers/mtd/ubi/block.c
++++ b/drivers/mtd/ubi/block.c
+@@ -396,7 +396,7 @@ int ubiblock_create(struct ubi_volume_in
+ 	dev->leb_size = vi->usable_leb_size;
+ 
+ 	/* Initialize the gendisk of this ubiblock device */
+-	gd = alloc_disk(1);
++	gd = alloc_disk(0);
+ 	if (!gd) {
+ 		pr_err("UBI: block: alloc_disk failed\n");
+ 		ret = -ENODEV;
+@@ -413,6 +413,7 @@ int ubiblock_create(struct ubi_volume_in
+ 		goto out_put_disk;
+ 	}
+ 	gd->private_data = dev;
++	gd->flags |= GENHD_FL_EXT_DEVT;
+ 	sprintf(gd->disk_name, "ubiblock%d_%d", dev->ubi_num, dev->vol_id);
+ 	set_capacity(gd, disk_capacity);
+ 	dev->gd = gd;
+--- a/block/partition-generic.c
++++ b/block/partition-generic.c
+@@ -18,6 +18,10 @@
+ #include <linux/ctype.h>
+ #include <linux/genhd.h>
+ #include <linux/blktrace_api.h>
++#ifdef CONFIG_FIT_PARTITION
++#include <linux/root_dev.h>
++#endif
++
+ 
+ #include "partitions/check.h"
+ 
+@@ -180,6 +184,18 @@ ssize_t part_fail_store(struct device *d
+ }
+ #endif
+ 
++static ssize_t part_name_show(struct device *dev,
++			      struct device_attribute *attr, char *buf)
++{
++	struct hd_struct *p = dev_to_part(dev);
++
++	if (p->info && p->info->volname)
++		return sprintf(buf, "%s\n", p->info->volname);
++
++	buf[0] = '\0';
++	return 0;
++}
++
+ static DEVICE_ATTR(partition, 0444, part_partition_show, NULL);
+ static DEVICE_ATTR(start, 0444, part_start_show, NULL);
+ static DEVICE_ATTR(size, 0444, part_size_show, NULL);
+@@ -188,6 +204,7 @@ static DEVICE_ATTR(alignment_offset, 044
+ static DEVICE_ATTR(discard_alignment, 0444, part_discard_alignment_show, NULL);
+ static DEVICE_ATTR(stat, 0444, part_stat_show, NULL);
+ static DEVICE_ATTR(inflight, 0444, part_inflight_show, NULL);
++static DEVICE_ATTR(name, 0444, part_name_show, NULL);
+ #ifdef CONFIG_FAIL_MAKE_REQUEST
+ static struct device_attribute dev_attr_fail =
+ 	__ATTR(make-it-fail, 0644, part_fail_show, part_fail_store);
+@@ -202,6 +219,7 @@ static struct attribute *part_attrs[] =
+ 	&dev_attr_discard_alignment.attr,
+ 	&dev_attr_stat.attr,
+ 	&dev_attr_inflight.attr,
++	&dev_attr_name.attr,
+ #ifdef CONFIG_FAIL_MAKE_REQUEST
+ 	&dev_attr_fail.attr,
+ #endif
+@@ -634,6 +652,10 @@ rescan:
+ 		if (state->parts[p].flags & ADDPART_FLAG_RAID)
+ 			md_autodetect_dev(part_to_dev(part)->devt);
+ #endif
++#ifdef CONFIG_FIT_PARTITION
++		if ((state->parts[p].flags & ADDPART_FLAG_ROOTDEV) && ROOT_DEV == 0)
++			ROOT_DEV = part_to_dev(part)->devt;
++#endif
+ 	}
+ 	free_partitions(state);
+ 	return 0;
+--- a/block/partitions/check.c
++++ b/block/partitions/check.c
+@@ -33,6 +33,7 @@
+ #include "ibm.h"
+ #include "ultrix.h"
+ #include "efi.h"
++#include "fit.h"
+ #include "karma.h"
+ #include "sysv68.h"
+ #include "cmdline.h"
+@@ -73,6 +74,9 @@ static int (*check_part[])(struct parsed
+ #ifdef CONFIG_EFI_PARTITION
+ 	efi_partition,		/* this must come before msdos */
+ #endif
++#ifdef CONFIG_FIT_PARTITION
++	fit_partition,
++#endif
+ #ifdef CONFIG_SGI_PARTITION
+ 	sgi_partition,
+ #endif
+--- a/include/linux/genhd.h
++++ b/include/linux/genhd.h
+@@ -614,6 +614,7 @@ struct unixware_disklabel {
+ #define ADDPART_FLAG_NONE	0
+ #define ADDPART_FLAG_RAID	1
+ #define ADDPART_FLAG_WHOLEDISK	2
++#define ADDPART_FLAG_ROOTDEV	4
+ 
+ extern int blk_alloc_devt(struct hd_struct *part, dev_t *devt);
+ extern void blk_free_devt(dev_t devt);
+--- /dev/null
++++ b/block/partitions/fit.h
+@@ -0,0 +1,3 @@
++/* SPDX-License-Identifier: GPL-2.0-only */
++int fit_partition(struct parsed_partitions *);
++int parse_fit_partitions(struct parsed_partitions *state, u64 start_sector, u64 nr_sectors, int *slot, int add_remain);
+--- a/block/partitions/efi.c
++++ b/block/partitions/efi.c
+@@ -679,7 +679,7 @@ int efi_partition(struct parsed_partitio
+ {
+ 	gpt_header *gpt = NULL;
+ 	gpt_entry *ptes = NULL;
+-	u32 i;
++	u32 i, slot = 0;
+ 	unsigned ssz = bdev_logical_block_size(state->bdev) / 512;
+ 
+ 	if (!find_valid_gpt(state, &gpt, &ptes) || !gpt || !ptes) {
+@@ -698,16 +698,18 @@ int efi_partition(struct parsed_partitio
+ 		u64 size = le64_to_cpu(ptes[i].ending_lba) -
+ 			   le64_to_cpu(ptes[i].starting_lba) + 1ULL;
+ 
+-		if (!is_pte_valid(&ptes[i], last_lba(state->bdev)))
++		if (!is_pte_valid(&ptes[i], last_lba(state->bdev))) {
++			++slot;
+ 			continue;
++		}
+ 
+-		put_partition(state, i+1, start * ssz, size * ssz);
++		put_partition(state, ++slot, start * ssz, size * ssz);
+ 
+ 		/* If this is a RAID volume, tell md */
+ 		if (!efi_guidcmp(ptes[i].partition_type_guid, PARTITION_LINUX_RAID_GUID))
+-			state->parts[i + 1].flags = ADDPART_FLAG_RAID;
++			state->parts[slot].flags = ADDPART_FLAG_RAID;
+ 
+-		info = &state->parts[i + 1].info;
++		info = &state->parts[slot].info;
+ 		efi_guid_to_str(&ptes[i].unique_partition_guid, info->uuid);
+ 
+ 		/* Naively convert UTF16-LE to 7 bits. */
+@@ -721,7 +723,12 @@ int efi_partition(struct parsed_partitio
+ 			info->volname[label_count] = c;
+ 			label_count++;
+ 		}
+-		state->parts[i + 1].has_info = true;
++		state->parts[slot].has_info = true;
++#ifdef CONFIG_FIT_PARTITION
++		/* If this is a U-Boot FIT volume it may have subpartitions */
++		if (!efi_guidcmp(ptes[i].partition_type_guid, PARTITION_LINUX_FIT_GUID))
++			(void) parse_fit_partitions(state, start * ssz, size * ssz, &slot, 1);
++#endif
+ 	}
+ 	kfree(ptes);
+ 	kfree(gpt);
+--- a/block/partitions/efi.h
++++ b/block/partitions/efi.h
+@@ -52,6 +52,9 @@
+ #define PARTITION_LINUX_LVM_GUID \
+     EFI_GUID( 0xe6d6d379, 0xf507, 0x44c2, \
+               0xa2, 0x3c, 0x23, 0x8f, 0x2a, 0x3d, 0xf9, 0x28)
++#define PARTITION_LINUX_FIT_GUID \
++    EFI_GUID( 0xcae9be83, 0xb15f, 0x49cc, \
++              0x86, 0x3f, 0x08, 0x1b, 0x74, 0x4a, 0x2d, 0x93)
+ 
+ typedef struct _gpt_header {
+ 	__le64 signature;
\ No newline at end of file
diff --git a/target/linux/generic/pending-5.4/491-ubi-auto-create-ubiblock-device-for-rootfs.patch b/target/linux/generic/pending-5.4/491-ubi-auto-create-ubiblock-device-for-rootfs.patch
index 61fcbac92e..798256641d 100644
--- a/target/linux/generic/pending-5.4/491-ubi-auto-create-ubiblock-device-for-rootfs.patch
+++ b/target/linux/generic/pending-5.4/491-ubi-auto-create-ubiblock-device-for-rootfs.patch
@@ -8,7 +8,7 @@ Signed-off-by: Daniel Golle <daniel@makrotopia.org>
 
 --- a/drivers/mtd/ubi/block.c
 +++ b/drivers/mtd/ubi/block.c
-@@ -652,6 +652,44 @@ static void __init ubiblock_create_from_
+@@ -652,6 +652,47 @@ static void __init ubiblock_create_from_
  	}
  }
  
@@ -33,6 +33,9 @@ Signed-off-by: Daniel Golle <daniel@makrotopia.org>
 +	for (ubi_num = 0; ubi_num < UBI_MAX_DEVICES; ubi_num++) {
 +		desc = ubi_open_volume_nm(ubi_num, "rootfs", UBI_READONLY);
 +		if (IS_ERR(desc))
++			desc = ubi_open_volume_nm(ubi_num, "fit", UBI_READONLY);;
++
++		if (IS_ERR(desc))
 +			continue;
 +
 +		ubi_get_volume_info(desc, &vi);
@@ -63,4 +66,4 @@ Signed-off-by: Daniel Golle <daniel@makrotopia.org>
 +
  	/*
  	 * Block devices are only created upon user requests, so we ignore
- 	 * existing volumes.
+ 	 * existing volumes.
\ No newline at end of file
diff --git a/target/linux/mediatek/Makefile b/target/linux/mediatek/Makefile
index c8ab5e01e6..100c21525a 100644
--- a/target/linux/mediatek/Makefile
+++ b/target/linux/mediatek/Makefile
@@ -6,7 +6,7 @@ ARCH:=arm
 BOARD:=mediatek
 BOARDNAME:=MediaTek Ralink ARM
 SUBTARGETS:=mt7622 mt7623 mt7629
-FEATURES:=squashfs nand ramdisk fpu
+FEATURES:=dt-overlay emmc fpu gpio nand pci pcie rootfs-part separate_ramdisk squashfs usb
 
 KERNEL_PATCHVER:=5.4
 KERNEL_TESTING_PATCHVER:=5.4
diff --git a/target/linux/mediatek/files-5.4/arch/arm64/boot/dts/mediatek/mt7622-bananapi-bpi-r64-rootdisk.dts b/target/linux/mediatek/files-5.4/arch/arm64/boot/dts/mediatek/mt7622-bananapi-bpi-r64-rootdisk.dts
deleted file mode 100644
index 36d908652d..0000000000
--- a/target/linux/mediatek/files-5.4/arch/arm64/boot/dts/mediatek/mt7622-bananapi-bpi-r64-rootdisk.dts
+++ /dev/null
@@ -1,591 +0,0 @@
-/*
- * Copyright (c) 2018 MediaTek Inc.
- * Author: Ryder Lee <ryder.lee@mediatek.com>
- *
- * SPDX-License-Identifier: (GPL-2.0-only OR MIT)
- */
-
-/dts-v1/;
-#include <dt-bindings/input/input.h>
-#include <dt-bindings/gpio/gpio.h>
-
-#include "mt7622.dtsi"
-#include "mt6380.dtsi"
-
-/ {
-	model = "Bananapi BPI-R64";
-	compatible = "bananapi,bpi-r64-rootdisk", "mediatek,mt7622";
-
-	aliases {
-		serial0 = &uart0;
-	};
-
-	chosen {
-		stdout-path = "serial0:115200n8";
-		bootargs = "earlycon=uart8250,mmio32,0x11002000 console=ttyS0,115200n1 swiotlb=512 root=/dev/mmcblk0p7 rootfstype=squashfs,f2fs";
-	};
-
-	cpus {
-		cpu@0 {
-			proc-supply = <&mt6380_vcpu_reg>;
-			sram-supply = <&mt6380_vm_reg>;
-		};
-
-		cpu@1 {
-			proc-supply = <&mt6380_vcpu_reg>;
-			sram-supply = <&mt6380_vm_reg>;
-		};
-	};
-
-	gpio-keys {
-		compatible = "gpio-keys";
-
-		factory {
-			label = "factory";
-			linux,code = <BTN_0>;
-			gpios = <&pio 0 GPIO_ACTIVE_HIGH>;
-		};
-
-		wps {
-			label = "wps";
-			linux,code = <KEY_WPS_BUTTON>;
-			gpios = <&pio 102 GPIO_ACTIVE_HIGH>;
-		};
-	};
-
-	leds {
-		compatible = "gpio-leds";
-
-		green {
-			label = "bpi-r64:pio:green";
-			gpios = <&pio 89 GPIO_ACTIVE_HIGH>;
-		};
-
-		red {
-			label = "bpi-r64:pio:red";
-			gpios = <&pio 88 GPIO_ACTIVE_HIGH>;
-		};
-	};
-
-	memory {
-		reg = <0 0x40000000 0 0x40000000>;
-	};
-
-	reg_1p8v: regulator-1p8v {
-		compatible = "regulator-fixed";
-		regulator-name = "fixed-1.8V";
-		regulator-min-microvolt = <1800000>;
-		regulator-max-microvolt = <1800000>;
-		regulator-always-on;
-	};
-
-	reg_3p3v: regulator-3p3v {
-		compatible = "regulator-fixed";
-		regulator-name = "fixed-3.3V";
-		regulator-min-microvolt = <3300000>;
-		regulator-max-microvolt = <3300000>;
-		regulator-boot-on;
-		regulator-always-on;
-	};
-
-	reg_5v: regulator-5v {
-		compatible = "regulator-fixed";
-		regulator-name = "fixed-5V";
-		regulator-min-microvolt = <5000000>;
-		regulator-max-microvolt = <5000000>;
-		regulator-boot-on;
-		regulator-always-on;
-	};
-};
-
-&bch {
-	status = "disabled";
-};
-
-&btif {
-	status = "okay";
-};
-
-&cir {
-	pinctrl-names = "default";
-	pinctrl-0 = <&irrx_pins>;
-	status = "okay";
-};
-
-&eth {
-	status = "okay";
-	gmac0: mac@0 {
-		compatible = "mediatek,eth-mac";
-		reg = <0>;
-		phy-mode = "2500base-x";
-
-		fixed-link {
-			speed = <2500>;
-			full-duplex;
-			pause;
-		};
-	};
-
-	gmac1: mac@1 {
-		compatible = "mediatek,eth-mac";
-		reg = <1>;
-		phy-mode = "rgmii";
-
-		fixed-link {
-			speed = <1000>;
-			full-duplex;
-			pause;
-		};
-	};
-
-	mdio: mdio-bus {
-		#address-cells = <1>;
-		#size-cells = <0>;
-
-		switch@1f {
-			compatible = "mediatek,mt7531";
-			reg = <0x1f>;
-			reset-gpios = <&pio 54 0>;
-
-			ports {
-				#address-cells = <1>;
-				#size-cells = <0>;
-
-				wan: port@0 {
-					reg = <0>;
-					label = "wan";
-				};
-
-				port@1 {
-					reg = <1>;
-					label = "lan0";
-				};
-
-				port@2 {
-					reg = <2>;
-					label = "lan1";
-				};
-
-				port@3 {
-					reg = <3>;
-					label = "lan2";
-				};
-
-				port@4 {
-					reg = <4>;
-					label = "lan3";
-				};
-
-				port@6 {
-					reg = <6>;
-					label = "cpu";
-					ethernet = <&gmac0>;
-					phy-mode = "2500base-x";
-
-					fixed-link {
-						speed = <2500>;
-						full-duplex;
-						pause;
-					};
-				};
-			};
-		};
-
-	};
-};
-
-&i2c1 {
-	pinctrl-names = "default";
-	pinctrl-0 = <&i2c1_pins>;
-	status = "okay";
-};
-
-&i2c2 {
-	pinctrl-names = "default";
-	pinctrl-0 = <&i2c2_pins>;
-	status = "okay";
-};
-
-&mmc0 {
-	pinctrl-names = "default", "state_uhs";
-	pinctrl-0 = <&emmc_pins_default>;
-	pinctrl-1 = <&emmc_pins_uhs>;
-	status = "okay";
-	bus-width = <8>;
-	max-frequency = <50000000>;
-	cap-mmc-highspeed;
-	mmc-hs200-1_8v;
-	vmmc-supply = <&reg_3p3v>;
-	vqmmc-supply = <&reg_1p8v>;
-	assigned-clocks = <&topckgen CLK_TOP_MSDC30_0_SEL>;
-	assigned-clock-parents = <&topckgen CLK_TOP_UNIV48M>;
-	non-removable;
-};
-
-&mmc1 {
-	pinctrl-names = "default", "state_uhs";
-	pinctrl-0 = <&sd0_pins_default>;
-	pinctrl-1 = <&sd0_pins_uhs>;
-	status = "okay";
-	bus-width = <4>;
-	max-frequency = <50000000>;
-	cap-sd-highspeed;
-	r_smpl = <1>;
-	cd-gpios = <&pio 81 GPIO_ACTIVE_LOW>;
-	vmmc-supply = <&reg_3p3v>;
-	vqmmc-supply = <&reg_3p3v>;
-	assigned-clocks = <&topckgen CLK_TOP_MSDC30_1_SEL>;
-	assigned-clock-parents = <&topckgen CLK_TOP_UNIV48M>;
-};
-
-&nandc {
-	pinctrl-names = "default";
-	pinctrl-0 = <&parallel_nand_pins>;
-	status = "disabled";
-};
-
-&nor_flash {
-	pinctrl-names = "default";
-	pinctrl-0 = <&spi_nor_pins>;
-	status = "disabled";
-
-	flash@0 {
-		compatible = "jedec,spi-nor";
-		reg = <0>;
-	};
-};
-
-&pcie0 {
-	pinctrl-names = "default";
-	pinctrl-0 = <&pcie0_pins>;
-	status = "okay";
-};
-
-&pcie1 {
-	pinctrl-names = "default";
-	pinctrl-0 = <&pcie1_pins>;
-	status = "okay";
-};
-
-&pio {
-	/* Attention: GPIO 90 is used to switch between PCIe@1,0 and
-	 * SATA functions. i.e. output-high: PCIe, output-low: SATA
-	 */
-	asm_sel {
-		gpio-hog;
-		gpios = <90 GPIO_ACTIVE_HIGH>;
-		output-high;
-	};
-
-	/* eMMC is shared pin with parallel NAND */
-	emmc_pins_default: emmc-pins-default {
-		mux {
-			function = "emmc", "emmc_rst";
-			groups = "emmc";
-		};
-
-		/* "NDL0","NDL1","NDL2","NDL3","NDL4","NDL5","NDL6","NDL7",
-		 * "NRB","NCLE" pins are used as DAT0,DAT1,DAT2,DAT3,DAT4,
-		 * DAT5,DAT6,DAT7,CMD,CLK for eMMC respectively
-		 */
-		conf-cmd-dat {
-			pins = "NDL0", "NDL1", "NDL2",
-			       "NDL3", "NDL4", "NDL5",
-			       "NDL6", "NDL7", "NRB";
-			input-enable;
-			bias-pull-up;
-		};
-
-		conf-clk {
-			pins = "NCLE";
-			bias-pull-down;
-		};
-	};
-
-	emmc_pins_uhs: emmc-pins-uhs {
-		mux {
-			function = "emmc";
-			groups = "emmc";
-		};
-
-		conf-cmd-dat {
-			pins = "NDL0", "NDL1", "NDL2",
-			       "NDL3", "NDL4", "NDL5",
-			       "NDL6", "NDL7", "NRB";
-			input-enable;
-			drive-strength = <4>;
-			bias-pull-up;
-		};
-
-		conf-clk {
-			pins = "NCLE";
-			drive-strength = <4>;
-			bias-pull-down;
-		};
-	};
-
-	eth_pins: eth-pins {
-		mux {
-			function = "eth";
-			groups = "mdc_mdio", "rgmii_via_gmac2";
-		};
-	};
-
-	i2c1_pins: i2c1-pins {
-		mux {
-			function = "i2c";
-			groups =  "i2c1_0";
-		};
-	};
-
-	i2c2_pins: i2c2-pins {
-		mux {
-			function = "i2c";
-			groups =  "i2c2_0";
-		};
-	};
-
-	i2s1_pins: i2s1-pins {
-		mux {
-			function = "i2s";
-			groups =  "i2s_out_mclk_bclk_ws",
-				  "i2s1_in_data",
-				  "i2s1_out_data";
-		};
-
-		conf {
-			pins = "I2S1_IN", "I2S1_OUT", "I2S_BCLK",
-			       "I2S_WS", "I2S_MCLK";
-			drive-strength = <12>;
-			bias-pull-down;
-		};
-	};
-
-	irrx_pins: irrx-pins {
-		mux {
-			function = "ir";
-			groups =  "ir_1_rx";
-		};
-	};
-
-	irtx_pins: irtx-pins {
-		mux {
-			function = "ir";
-			groups =  "ir_1_tx";
-		};
-	};
-
-	/* Parallel nand is shared pin with eMMC */
-	parallel_nand_pins: parallel-nand-pins {
-		mux {
-			function = "flash";
-			groups = "par_nand";
-		};
-	};
-
-	pcie0_pins: pcie0-pins {
-		mux {
-			function = "pcie";
-			groups = "pcie0_pad_perst",
-				 "pcie0_1_waken",
-				 "pcie0_1_clkreq";
-		};
-	};
-
-	pcie1_pins: pcie1-pins {
-		mux {
-			function = "pcie";
-			groups = "pcie1_pad_perst",
-				 "pcie1_0_waken",
-				 "pcie1_0_clkreq";
-		};
-	};
-
-	pmic_bus_pins: pmic-bus-pins {
-		mux {
-			function = "pmic";
-			groups = "pmic_bus";
-		};
-	};
-
-	pwm7_pins: pwm1-2-pins {
-		mux {
-			function = "pwm";
-			groups = "pwm_ch7_2";
-		};
-	};
-
-	wled_pins: wled-pins {
-		mux {
-			function = "led";
-			groups = "wled";
-		};
-	};
-
-	sd0_pins_default: sd0-pins-default {
-		mux {
-			function = "sd";
-			groups = "sd_0";
-		};
-
-		/* "I2S2_OUT, "I2S4_IN"", "I2S3_IN", "I2S2_IN",
-		 *  "I2S4_OUT", "I2S3_OUT" are used as DAT0, DAT1,
-		 *  DAT2, DAT3, CMD, CLK for SD respectively.
-		 */
-		conf-cmd-data {
-			pins = "I2S2_OUT", "I2S4_IN", "I2S3_IN",
-			       "I2S2_IN","I2S4_OUT";
-			input-enable;
-			drive-strength = <8>;
-			bias-pull-up;
-		};
-		conf-clk {
-			pins = "I2S3_OUT";
-			drive-strength = <12>;
-			bias-pull-down;
-		};
-		conf-cd {
-			pins = "TXD3";
-			bias-pull-up;
-		};
-	};
-
-	sd0_pins_uhs: sd0-pins-uhs {
-		mux {
-			function = "sd";
-			groups = "sd_0";
-		};
-
-		conf-cmd-data {
-			pins = "I2S2_OUT", "I2S4_IN", "I2S3_IN",
-			       "I2S2_IN","I2S4_OUT";
-			input-enable;
-			bias-pull-up;
-		};
-
-		conf-clk {
-			pins = "I2S3_OUT";
-			bias-pull-down;
-		};
-	};
-
-	/* Serial NAND is shared pin with SPI-NOR */
-	serial_nand_pins: serial-nand-pins {
-		mux {
-			function = "flash";
-			groups = "snfi";
-		};
-	};
-
-	spic0_pins: spic0-pins {
-		mux {
-			function = "spi";
-			groups = "spic0_0";
-		};
-	};
-
-	spic1_pins: spic1-pins {
-		mux {
-			function = "spi";
-			groups = "spic1_0";
-		};
-	};
-
-	/* SPI-NOR is shared pin with serial NAND */
-	spi_nor_pins: spi-nor-pins {
-		mux {
-			function = "flash";
-			groups = "spi_nor";
-		};
-	};
-
-	/* serial NAND is shared pin with SPI-NOR */
-	serial_nand_pins: serial-nand-pins {
-		mux {
-			function = "flash";
-			groups = "snfi";
-		};
-	};
-
-	uart0_pins: uart0-pins {
-		mux {
-			function = "uart";
-			groups = "uart0_0_tx_rx" ;
-		};
-	};
-
-	uart2_pins: uart2-pins {
-		mux {
-			function = "uart";
-			groups = "uart2_1_tx_rx" ;
-		};
-	};
-
-	watchdog_pins: watchdog-pins {
-		mux {
-			function = "watchdog";
-			groups = "watchdog";
-		};
-	};
-};
-
-&pwm {
-	pinctrl-names = "default";
-	pinctrl-0 = <&pwm7_pins>;
-	status = "okay";
-};
-
-&pwrap {
-	pinctrl-names = "default";
-	pinctrl-0 = <&pmic_bus_pins>;
-
-	status = "okay";
-};
-
-&sata {
-	status = "disable";
-};
-
-&sata_phy {
-	status = "disable";
-};
-
-&spi0 {
-	pinctrl-names = "default";
-	pinctrl-0 = <&spic0_pins>;
-	status = "okay";
-};
-
-&spi1 {
-	pinctrl-names = "default";
-	pinctrl-0 = <&spic1_pins>;
-	status = "okay";
-};
-
-&ssusb {
-	vusb33-supply = <&reg_3p3v>;
-	vbus-supply = <&reg_5v>;
-	status = "okay";
-};
-
-&u3phy {
-	status = "okay";
-};
-
-&uart0 {
-	pinctrl-names = "default";
-	pinctrl-0 = <&uart0_pins>;
-	status = "okay";
-};
-
-&uart2 {
-	pinctrl-names = "default";
-	pinctrl-0 = <&uart2_pins>;
-	status = "okay";
-};
-
-&watchdog {
-	pinctrl-names = "default";
-	pinctrl-0 = <&watchdog_pins>;
-	status = "okay";
-};
diff --git a/target/linux/mediatek/files-5.4/arch/arm64/boot/dts/mediatek/mt7622-elecom-wrc-2533gent.dts b/target/linux/mediatek/files-5.4/arch/arm64/boot/dts/mediatek/mt7622-elecom-wrc-2533gent.dts
deleted file mode 100644
index 2ac1c6a671..0000000000
--- a/target/linux/mediatek/files-5.4/arch/arm64/boot/dts/mediatek/mt7622-elecom-wrc-2533gent.dts
+++ /dev/null
@@ -1,608 +0,0 @@
-/*
- * Copyright (c) 2017 MediaTek Inc.
- * Author: Ming Huang <ming.huang@mediatek.com>
- *	   Sean Wang <sean.wang@mediatek.com>
- *
- * SPDX-License-Identifier: (GPL-2.0-only OR MIT)
- */
-
-/dts-v1/;
-#include <dt-bindings/input/input.h>
-#include <dt-bindings/gpio/gpio.h>
-
-#include "mt7622.dtsi"
-#include "mt6380.dtsi"
-
-/ {
-	model = "Elecom WRC-2533";
-	compatible = "elecom,wrc-2533gent", "mediatek,mt7622";
-
-	aliases {
-		led-boot = &led_power;
-		led-failsafe = &led_power;
-		led-running = &led_power;
-		led-upgrade = &led_power;
-		serial0 = &uart0;
-	};
-
-	chosen {
-		stdout-path = "serial0:115200n8";
-		bootargs = "earlycon=uart8250,mmio32,0x11002000 swiotlb=512 console=ttyS0,115200n8";
-	};
-
-	cpus {
-		cpu@0 {
-			proc-supply = <&mt6380_vcpu_reg>;
-			sram-supply = <&mt6380_vm_reg>;
-		};
-
-		cpu@1 {
-			proc-supply = <&mt6380_vcpu_reg>;
-			sram-supply = <&mt6380_vm_reg>;
-		};
-	};
-
-	gpio-keys {
-		compatible = "gpio-keys";
-		poll-interval = <100>;
-
-		wps {
-			label = "wps";
-			linux,code = <KEY_WPS_BUTTON>;
-			gpios = <&pio 0 GPIO_ACTIVE_HIGH>;
-		};
-
-		factory {
-			label = "factory";
-			linux,code = <KEY_WPS_BUTTON>;
-			gpios = <&pio 102 GPIO_ACTIVE_LOW>;
-		};
-
-		switch0 {
-			label = "switch0";
-			gpios = <&pio 1 GPIO_ACTIVE_LOW>;
-			linux,code = <BTN_0>;
-			linux,input-type = <EV_SW>;
-		};
-
-		switch1 {
-			label = "switch1";
-			gpios = <&pio 16 GPIO_ACTIVE_LOW>;
-			linux,code = <BTN_1>;
-			linux,input-type = <EV_SW>;
-		};
-
-		switch2 {
-			label = "switch2";
-			gpios = <&pio 17 GPIO_ACTIVE_LOW>;
-			linux,code = <BTN_2>;
-			linux,input-type = <EV_SW>;
-		};
-
-		switch3 {
-			label = "switch3";
-			gpios = <&pio 18 GPIO_ACTIVE_LOW>;
-			linux,code = <BTN_3>;
-			linux,input-type = <EV_SW>;
-		};
-	};
-
-	leds {
-		compatible = "gpio-leds";
-
-		led_power: power_g {
-			label = "wrc-2533:green:power";
-			gpios = <&pio 2 GPIO_ACTIVE_HIGH>;
-		};
-
-		power_b {
-			label = "wrc-2533:blue:power";
-			gpios = <&pio 19 GPIO_ACTIVE_HIGH>;
-		};
-
-		power_r {
-			label = "wrc-2533:red:power";
-			gpios = <&pio 73 GPIO_ACTIVE_HIGH>;
-		};
-
-		usb {
-			label = "wrc-2533:blue:usb";
-			gpios = <&pio 74 GPIO_ACTIVE_HIGH>;
-		};
-
-		wps {
-			label = "wrc-2533:red:wps";
-			gpios = <&pio 76 GPIO_ACTIVE_LOW>;
-		};
-
-		wifi2 {
-			label = "wrc-2533:blue:wifi2g";
-			gpios = <&pio 85 GPIO_ACTIVE_LOW>;
-		};
-
-		wifi5 {
-			label = "wrc-2533:blue:wifi5g";
-			gpios = <&pio 91 GPIO_ACTIVE_LOW>;
-		};
-	};
-
-	reg_usb_vbus: regulator {
-		compatible = "regulator-fixed";
-		regulator-name = "usb_vbus";
-		regulator-min-microvolt = <5000000>;
-		regulator-max-microvolt = <5000000>;
-		gpio = <&pio 22 GPIO_ACTIVE_LOW>;
-		enable-active-high;
-	};
-
-	memory {
-		reg = <0 0x40000000 0 0x3F000000>;
-	};
-
-	reg_1p8v: regulator-1p8v {
-		compatible = "regulator-fixed";
-		regulator-name = "fixed-1.8V";
-		regulator-min-microvolt = <1800000>;
-		regulator-max-microvolt = <1800000>;
-		regulator-always-on;
-	};
-
-	reg_3p3v: regulator-3p3v {
-		compatible = "regulator-fixed";
-		regulator-name = "fixed-3.3V";
-		regulator-min-microvolt = <3300000>;
-		regulator-max-microvolt = <3300000>;
-		regulator-boot-on;
-		regulator-always-on;
-	};
-
-	rtkgsw: rtkgsw@0 {
-		compatible = "mediatek,rtk-gsw";
-		mediatek,ethsys = <&ethsys>;
-		mediatek,mdio = <&mdio>;
-		mediatek,reset-pin = <&pio 54 0>;
-		status = "okay";
-	};
-};
-
-&pcie0 {
-	pinctrl-names = "default";
-	pinctrl-0 = <&pcie0_pins>;
-	status = "okay";
-};
-
-&slot0 {
-	mt7615@0,0 {
-		reg = <0x0000 0 0 0 0>;
-		mediatek,mtd-eeprom = <&factory 0x05000>;
-	};
-};
-
-&pio {
-	/* eMMC is shared pin with parallel NAND */
-	emmc_pins_default: emmc-pins-default {
-		mux {
-			function = "emmc", "emmc_rst";
-			groups = "emmc";
-		};
-
-		/* "NDL0","NDL1","NDL2","NDL3","NDL4","NDL5","NDL6","NDL7",
-		 * "NRB","NCLE" pins are used as DAT0,DAT1,DAT2,DAT3,DAT4,
-		 * DAT5,DAT6,DAT7,CMD,CLK for eMMC respectively
-		 */
-		conf-cmd-dat {
-			pins = "NDL0", "NDL1", "NDL2",
-			       "NDL3", "NDL4", "NDL5",
-			       "NDL6", "NDL7", "NRB";
-			input-enable;
-			bias-pull-up;
-		};
-
-		conf-clk {
-			pins = "NCLE";
-			bias-pull-down;
-		};
-	};
-
-	emmc_pins_uhs: emmc-pins-uhs {
-		mux {
-			function = "emmc";
-			groups = "emmc";
-		};
-
-		conf-cmd-dat {
-			pins = "NDL0", "NDL1", "NDL2",
-			       "NDL3", "NDL4", "NDL5",
-			       "NDL6", "NDL7", "NRB";
-			input-enable;
-			drive-strength = <4>;
-			bias-pull-up;
-		};
-
-		conf-clk {
-			pins = "NCLE";
-			drive-strength = <4>;
-			bias-pull-down;
-		};
-	};
-
-	eth_pins: eth-pins {
-		mux {
-			function = "eth";
-			groups = "mdc_mdio", "rgmii_via_gmac2";
-		};
-	};
-
-	i2c1_pins: i2c1-pins {
-		mux {
-			function = "i2c";
-			groups =  "i2c1_0";
-		};
-	};
-
-	i2c2_pins: i2c2-pins {
-		mux {
-			function = "i2c";
-			groups =  "i2c2_0";
-		};
-	};
-
-	i2s1_pins: i2s1-pins {
-		mux {
-			function = "i2s";
-			groups =  "i2s_out_mclk_bclk_ws",
-				  "i2s1_in_data",
-				  "i2s1_out_data";
-		};
-
-		conf {
-			pins = "I2S1_IN", "I2S1_OUT", "I2S_BCLK",
-			       "I2S_WS", "I2S_MCLK";
-			drive-strength = <12>;
-			bias-pull-down;
-		};
-	};
-
-	irrx_pins: irrx-pins {
-		mux {
-			function = "ir";
-			groups =  "ir_1_rx";
-		};
-	};
-
-	irtx_pins: irtx-pins {
-		mux {
-			function = "ir";
-			groups =  "ir_1_tx";
-		};
-	};
-
-	/* Parallel nand is shared pin with eMMC */
-	parallel_nand_pins: parallel-nand-pins {
-		mux {
-			function = "flash";
-			groups = "par_nand";
-		};
-	};
-
-	pcie0_pins: pcie0-pins {
-		mux {
-			function = "pcie";
-			groups = "pcie0_pad_perst",
-				 "pcie0_1_waken",
-				 "pcie0_1_clkreq";
-		};
-	};
-
-	pcie1_pins: pcie1-pins {
-		mux {
-			function = "pcie";
-			groups = "pcie1_pad_perst",
-				 "pcie1_0_waken",
-				 "pcie1_0_clkreq";
-		};
-	};
-
-	pmic_bus_pins: pmic-bus-pins {
-		mux {
-			function = "pmic";
-			groups = "pmic_bus";
-		};
-	};
-
-	pwm7_pins: pwm1-2-pins {
-		mux {
-			function = "pwm";
-			groups = "pwm_ch7_2";
-		};
-	};
-
-	wled_pins: wled-pins {
-		mux {
-			function = "led";
-			groups = "wled";
-		};
-	};
-
-	sd0_pins_default: sd0-pins-default {
-		mux {
-			function = "sd";
-			groups = "sd_0";
-		};
-
-		/* "I2S2_OUT, "I2S4_IN"", "I2S3_IN", "I2S2_IN",
-		 *  "I2S4_OUT", "I2S3_OUT" are used as DAT0, DAT1,
-		 *  DAT2, DAT3, CMD, CLK for SD respectively.
-		 */
-		conf-cmd-data {
-			pins = "I2S2_OUT", "I2S4_IN", "I2S3_IN",
-			       "I2S2_IN","I2S4_OUT";
-			input-enable;
-			drive-strength = <8>;
-			bias-pull-up;
-		};
-		conf-clk {
-			pins = "I2S3_OUT";
-			drive-strength = <12>;
-			bias-pull-down;
-		};
-		conf-cd {
-			pins = "TXD3";
-			bias-pull-up;
-		};
-	};
-
-	sd0_pins_uhs: sd0-pins-uhs {
-		mux {
-			function = "sd";
-			groups = "sd_0";
-		};
-
-		conf-cmd-data {
-			pins = "I2S2_OUT", "I2S4_IN", "I2S3_IN",
-			       "I2S2_IN","I2S4_OUT";
-			input-enable;
-			bias-pull-up;
-		};
-
-		conf-clk {
-			pins = "I2S3_OUT";
-			bias-pull-down;
-		};
-	};
-
-	/* Serial NAND is shared pin with SPI-NOR */
-	serial_nand_pins: serial-nand-pins {
-		mux {
-			function = "flash";
-			groups = "snfi";
-		};
-	};
-
-	spic0_pins: spic0-pins {
-		mux {
-			function = "spi";
-			groups = "spic0_0";
-		};
-	};
-
-	spic1_pins: spic1-pins {
-		mux {
-			function = "spi";
-			groups = "spic1_0";
-		};
-	};
-
-	/* SPI-NOR is shared pin with serial NAND */
-	spi_nor_pins: spi-nor-pins {
-		mux {
-			function = "flash";
-			groups = "spi_nor";
-		};
-	};
-
-	/* serial NAND is shared pin with SPI-NOR */
-	serial_nand_pins: serial-nand-pins {
-		mux {
-			function = "flash";
-			groups = "snfi";
-		};
-	};
-
-	uart0_pins: uart0-pins {
-		mux {
-			function = "uart";
-			groups = "uart0_0_tx_rx" ;
-		};
-	};
-
-	uart2_pins: uart2-pins {
-		mux {
-			function = "uart";
-			groups = "uart2_1_tx_rx" ;
-		};
-	};
-
-	watchdog_pins: watchdog-pins {
-		mux {
-			function = "watchdog";
-			groups = "watchdog";
-		};
-	};
-};
-
-&bch {
-	status = "okay";
-};
-
-&btif {
-	status = "disabled";
-};
-
-&cir {
-	pinctrl-names = "default";
-	pinctrl-0 = <&irrx_pins>;
-	status = "okay";
-};
-
-&eth {
-	status = "okay";
-	pinctrl-names = "default";
-	pinctrl-0 = <&eth_pins>;
-	gmac0: mac@0 {
-		compatible = "mediatek,eth-mac";
-		reg = <0>;
-		phy-mode = "sgmii";
-		fixed-link {
-			speed = <1000>;
-			full-duplex;
-			pause;
-		};
-	};
-
-	gmac1: mac@1 {
-		compatible = "mediatek,eth-mac";
-		reg = <1>;
-		phy-mode = "rgmii";
-		fixed-link {
-			speed = <1000>;
-			full-duplex;
-			pause;
-		};
-	};
-
-	mdio: mdio-bus {
-		#address-cells = <1>;
-		#size-cells = <0>;
-	};
-};
-
-&i2c1 {
-	pinctrl-names = "default";
-	pinctrl-0 = <&i2c1_pins>;
-	status = "okay";
-};
-
-&i2c2 {
-	pinctrl-names = "default";
-	pinctrl-0 = <&i2c2_pins>;
-	status = "okay";
-};
-
-&pwm {
-	pinctrl-names = "default";
-	pinctrl-0 = <&pwm7_pins>;
-	status = "okay";
-};
-
-&pwrap {
-	pinctrl-names = "default";
-	pinctrl-0 = <&pmic_bus_pins>;
-
-	status = "okay";
-};
-
-&snfi {
-	pinctrl-names = "default";
-	pinctrl-0 = <&serial_nand_pins>;
-	status = "okay";
-
-	spi_nand@0 {
-		#address-cells = <1>;
-		#size-cells = <1>;
-		compatible = "spi-nand";
-		spi-max-frequency = <104000000>;
-		reg = <0>;
-
-		partitions {
-			compatible = "fixed-partitions";
-			#address-cells = <1>;
-			#size-cells = <1>;
-
-			partition@0 {
-				label = "Preloader";
-				reg = <0x00000 0x0080000>;
-				read-only;
-			};
-
-			partition@80000 {
-				label = "ATF";
-				reg = <0x80000 0x0040000>;
-				read-only;
-			};
-
-			partition@c0000 {
-				label = "uboot";
-				reg = <0xc0000 0x0080000>;
-				read-only;
-			};
-
-			partition@140000 {
-				label = "uboot-env";
-				reg = <0x140000 0x0080000>;
-				read-only;
-			};
-
-			factory: partition@1c0000 {
-				label = "factory";
-				reg = <0x1c0000 0x0040000>;
-				read-only;
-			};
-
-			partition@200000 {
-				label = "firmware";
-				reg = <0x200000 0x2000000>;
-			};
-
-			partition@2200000 {
-				label = "reserved";
-				reg = <0x2200000 0x4000000>;
-			};
-		};
-	};
-};
-
-&spi0 {
-	pinctrl-names = "default";
-	pinctrl-0 = <&spic0_pins>;
-	status = "okay";
-};
-
-&spi1 {
-	pinctrl-names = "default";
-	pinctrl-0 = <&spic1_pins>;
-	status = "okay";
-};
-
-&ssusb {
-	vusb33-supply = <&reg_3p3v>;
-	vbus-supply = <&reg_usb_vbus>;
-	status = "okay";
-};
-
-&u3phy {
-	status = "okay";
-};
-
-&uart0 {
-	pinctrl-names = "default";
-	pinctrl-0 = <&uart0_pins>;
-	status = "okay";
-};
-
-&uart2 {
-	pinctrl-names = "default";
-	pinctrl-0 = <&uart2_pins>;
-	status = "okay";
-};
-
-&watchdog {
-	pinctrl-names = "default";
-	pinctrl-0 = <&watchdog_pins>;
-	status = "okay";
-};
-
-&wmac {
-	mediatek,mtd-eeprom = <&factory 0x0000>;
-	status = "okay";
-};
diff --git a/target/linux/mediatek/files-5.4/arch/arm64/boot/dts/mediatek/mt7622-rfb1-ubi.dts b/target/linux/mediatek/files-5.4/arch/arm64/boot/dts/mediatek/mt7622-rfb1-ubi.dts
deleted file mode 100644
index 8b58c1e12f..0000000000
--- a/target/linux/mediatek/files-5.4/arch/arm64/boot/dts/mediatek/mt7622-rfb1-ubi.dts
+++ /dev/null
@@ -1,644 +0,0 @@
-/*
- * Copyright (c) 2018 MediaTek Inc.
- * Author: Ryder Lee <ryder.lee@mediatek.com>
- *
- * SPDX-License-Identifier: (GPL-2.0-only OR MIT)
- */
-
-/dts-v1/;
-#include <dt-bindings/input/input.h>
-#include <dt-bindings/gpio/gpio.h>
-
-#include "mt7622.dtsi"
-#include "mt6380.dtsi"
-
-/ {
-	model = "MT7622_MT7531 RFB";
-	compatible = "mediatek,mt7622,ubi";
-
-	aliases {
-		serial0 = &uart0;
-	};
-
-	chosen {
-		stdout-path = "serial0:115200n8";
-		bootargs = "earlycon=uart8250,mmio32,0x11002000 console=ttyS0,115200n1 swiotlb=512";
-	};
-
-	cpus {
-		cpu@0 {
-			proc-supply = <&mt6380_vcpu_reg>;
-			sram-supply = <&mt6380_vm_reg>;
-		};
-
-		cpu@1 {
-			proc-supply = <&mt6380_vcpu_reg>;
-			sram-supply = <&mt6380_vm_reg>;
-		};
-	};
-
-	gpio-keys {
-		compatible = "gpio-keys";
-
-		factory {
-			label = "factory";
-			linux,code = <BTN_0>;
-			gpios = <&pio 0 GPIO_ACTIVE_HIGH>;
-		};
-
-		wps {
-			label = "wps";
-			linux,code = <KEY_WPS_BUTTON>;
-			gpios = <&pio 102 GPIO_ACTIVE_HIGH>;
-		};
-	};
-
-	gsw: gsw@0 {
-		compatible = "mediatek,mt753x";
-		mediatek,ethsys = <&ethsys>;
-		#address-cells = <1>;
-		#size-cells = <0>;
-	};
-
-	leds {
-		compatible = "gpio-leds";
-
-		green {
-			label = "bpi-r64:pio:green";
-			gpios = <&pio 89 GPIO_ACTIVE_HIGH>;
-		};
-
-		red {
-			label = "bpi-r64:pio:red";
-			gpios = <&pio 88 GPIO_ACTIVE_HIGH>;
-		};
-	};
-
-	memory {
-		reg = <0 0x40000000 0 0x40000000>;
-	};
-
-	reg_1p8v: regulator-1p8v {
-		compatible = "regulator-fixed";
-		regulator-name = "fixed-1.8V";
-		regulator-min-microvolt = <1800000>;
-		regulator-max-microvolt = <1800000>;
-		regulator-always-on;
-	};
-
-	reg_3p3v: regulator-3p3v {
-		compatible = "regulator-fixed";
-		regulator-name = "fixed-3.3V";
-		regulator-min-microvolt = <3300000>;
-		regulator-max-microvolt = <3300000>;
-		regulator-boot-on;
-		regulator-always-on;
-	};
-
-	reg_5v: regulator-5v {
-		compatible = "regulator-fixed";
-		regulator-name = "fixed-5V";
-		regulator-min-microvolt = <5000000>;
-		regulator-max-microvolt = <5000000>;
-		regulator-boot-on;
-		regulator-always-on;
-	};
-};
-
-&bch {
-	status = "okay";
-};
-
-&btif {
-	status = "okay";
-};
-
-&cir {
-	pinctrl-names = "default";
-	pinctrl-0 = <&irrx_pins>;
-	status = "okay";
-};
-
-&eth {
-	status = "okay";
-	gmac0: mac@0 {
-		compatible = "mediatek,eth-mac";
-		reg = <0>;
-		phy-mode = "2500base-x";
-
-		fixed-link {
-			speed = <2500>;
-			full-duplex;
-			pause;
-		};
-	};
-
-	gmac1: mac@1 {
-		compatible = "mediatek,eth-mac";
-		reg = <1>;
-		phy-mode = "rgmii";
-
-		fixed-link {
-			speed = <1000>;
-			full-duplex;
-			pause;
-		};
-	};
-
-	mdio: mdio-bus {
-		#address-cells = <1>;
-		#size-cells = <0>;
-	};
-};
-
-&gsw {
-	mediatek,mdio = <&mdio>;
-	mediatek,portmap = "llllw";
-	mediatek,mdio_master_pinmux = <0>;
-	reset-gpios = <&pio 54 0>;
-	interrupt-parent = <&pio>;
-	interrupts = <53 IRQ_TYPE_LEVEL_HIGH>;
-	status = "okay";
-
-	port5: port@5 {
-		compatible = "mediatek,mt753x-port";
-		reg = <5>;
-		phy-mode = "rgmii";
-		fixed-link {
-			speed = <1000>;
-			full-duplex;
-		};
-	};
-
-	port6: port@6 {
-		compatible = "mediatek,mt753x-port";
-		reg = <6>;
-		phy-mode = "sgmii";
-		fixed-link {
-			speed = <2500>;
-			full-duplex;
-		};
-	};
-};
-
-&i2c1 {
-	pinctrl-names = "default";
-	pinctrl-0 = <&i2c1_pins>;
-	status = "okay";
-};
-
-&i2c2 {
-	pinctrl-names = "default";
-	pinctrl-0 = <&i2c2_pins>;
-	status = "okay";
-};
-
-&mmc0 {
-	pinctrl-names = "default", "state_uhs";
-	pinctrl-0 = <&emmc_pins_default>;
-	pinctrl-1 = <&emmc_pins_uhs>;
-	status = "okay";
-	bus-width = <8>;
-	max-frequency = <50000000>;
-	cap-mmc-highspeed;
-	mmc-hs200-1_8v;
-	vmmc-supply = <&reg_3p3v>;
-	vqmmc-supply = <&reg_1p8v>;
-	assigned-clocks = <&topckgen CLK_TOP_MSDC30_0_SEL>;
-	assigned-clock-parents = <&topckgen CLK_TOP_UNIV48M>;
-	non-removable;
-};
-
-&mmc1 {
-	pinctrl-names = "default", "state_uhs";
-	pinctrl-0 = <&sd0_pins_default>;
-	pinctrl-1 = <&sd0_pins_uhs>;
-	status = "okay";
-	bus-width = <4>;
-	max-frequency = <50000000>;
-	cap-sd-highspeed;
-	r_smpl = <1>;
-	cd-gpios = <&pio 81 GPIO_ACTIVE_LOW>;
-	vmmc-supply = <&reg_3p3v>;
-	vqmmc-supply = <&reg_3p3v>;
-	assigned-clocks = <&topckgen CLK_TOP_MSDC30_1_SEL>;
-	assigned-clock-parents = <&topckgen CLK_TOP_UNIV48M>;
-};
-
-&nandc {
-	pinctrl-names = "default";
-	pinctrl-0 = <&parallel_nand_pins>;
-	status = "disabled";
-};
-
-&nor_flash {
-	pinctrl-names = "default";
-	pinctrl-0 = <&spi_nor_pins>;
-	status = "disabled";
-
-	flash@0 {
-		compatible = "jedec,spi-nor";
-		reg = <0>;
-	};
-};
-
-&pcie0 {
-	pinctrl-names = "default";
-	pinctrl-0 = <&pcie0_pins>;
-	status = "okay";
-};
-
-&pcie1 {
-	pinctrl-names = "default";
-	pinctrl-0 = <&pcie1_pins>;
-	status = "okay";
-};
-
-&pio {
-	/* Attention: GPIO 90 is used to switch between PCIe@1,0 and
-	 * SATA functions. i.e. output-high: PCIe, output-low: SATA
-	 */
-	asm_sel {
-		gpio-hog;
-		gpios = <90 GPIO_ACTIVE_HIGH>;
-		output-high;
-	};
-
-	/* eMMC is shared pin with parallel NAND */
-	emmc_pins_default: emmc-pins-default {
-		mux {
-			function = "emmc", "emmc_rst";
-			groups = "emmc";
-		};
-
-		/* "NDL0","NDL1","NDL2","NDL3","NDL4","NDL5","NDL6","NDL7",
-		 * "NRB","NCLE" pins are used as DAT0,DAT1,DAT2,DAT3,DAT4,
-		 * DAT5,DAT6,DAT7,CMD,CLK for eMMC respectively
-		 */
-		conf-cmd-dat {
-			pins = "NDL0", "NDL1", "NDL2",
-			       "NDL3", "NDL4", "NDL5",
-			       "NDL6", "NDL7", "NRB";
-			input-enable;
-			bias-pull-up;
-		};
-
-		conf-clk {
-			pins = "NCLE";
-			bias-pull-down;
-		};
-	};
-
-	emmc_pins_uhs: emmc-pins-uhs {
-		mux {
-			function = "emmc";
-			groups = "emmc";
-		};
-
-		conf-cmd-dat {
-			pins = "NDL0", "NDL1", "NDL2",
-			       "NDL3", "NDL4", "NDL5",
-			       "NDL6", "NDL7", "NRB";
-			input-enable;
-			drive-strength = <4>;
-			bias-pull-up;
-		};
-
-		conf-clk {
-			pins = "NCLE";
-			drive-strength = <4>;
-			bias-pull-down;
-		};
-	};
-
-	eth_pins: eth-pins {
-		mux {
-			function = "eth";
-			groups = "mdc_mdio", "rgmii_via_gmac2";
-		};
-	};
-
-	i2c1_pins: i2c1-pins {
-		mux {
-			function = "i2c";
-			groups =  "i2c1_0";
-		};
-	};
-
-	i2c2_pins: i2c2-pins {
-		mux {
-			function = "i2c";
-			groups =  "i2c2_0";
-		};
-	};
-
-	i2s1_pins: i2s1-pins {
-		mux {
-			function = "i2s";
-			groups =  "i2s_out_mclk_bclk_ws",
-				  "i2s1_in_data",
-				  "i2s1_out_data";
-		};
-
-		conf {
-			pins = "I2S1_IN", "I2S1_OUT", "I2S_BCLK",
-			       "I2S_WS", "I2S_MCLK";
-			drive-strength = <12>;
-			bias-pull-down;
-		};
-	};
-
-	irrx_pins: irrx-pins {
-		mux {
-			function = "ir";
-			groups =  "ir_1_rx";
-		};
-	};
-
-	irtx_pins: irtx-pins {
-		mux {
-			function = "ir";
-			groups =  "ir_1_tx";
-		};
-	};
-
-	/* Parallel nand is shared pin with eMMC */
-	parallel_nand_pins: parallel-nand-pins {
-		mux {
-			function = "flash";
-			groups = "par_nand";
-		};
-	};
-
-	pcie0_pins: pcie0-pins {
-		mux {
-			function = "pcie";
-			groups = "pcie0_pad_perst",
-				 "pcie0_1_waken",
-				 "pcie0_1_clkreq";
-		};
-	};
-
-	pcie1_pins: pcie1-pins {
-		mux {
-			function = "pcie";
-			groups = "pcie1_pad_perst",
-				 "pcie1_0_waken",
-				 "pcie1_0_clkreq";
-		};
-	};
-
-	pmic_bus_pins: pmic-bus-pins {
-		mux {
-			function = "pmic";
-			groups = "pmic_bus";
-		};
-	};
-
-	pwm7_pins: pwm1-2-pins {
-		mux {
-			function = "pwm";
-			groups = "pwm_ch7_2";
-		};
-	};
-
-	wled_pins: wled-pins {
-		mux {
-			function = "led";
-			groups = "wled";
-		};
-	};
-
-	sd0_pins_default: sd0-pins-default {
-		mux {
-			function = "sd";
-			groups = "sd_0";
-		};
-
-		/* "I2S2_OUT, "I2S4_IN"", "I2S3_IN", "I2S2_IN",
-		 *  "I2S4_OUT", "I2S3_OUT" are used as DAT0, DAT1,
-		 *  DAT2, DAT3, CMD, CLK for SD respectively.
-		 */
-		conf-cmd-data {
-			pins = "I2S2_OUT", "I2S4_IN", "I2S3_IN",
-			       "I2S2_IN","I2S4_OUT";
-			input-enable;
-			drive-strength = <8>;
-			bias-pull-up;
-		};
-		conf-clk {
-			pins = "I2S3_OUT";
-			drive-strength = <12>;
-			bias-pull-down;
-		};
-		conf-cd {
-			pins = "TXD3";
-			bias-pull-up;
-		};
-	};
-
-	sd0_pins_uhs: sd0-pins-uhs {
-		mux {
-			function = "sd";
-			groups = "sd_0";
-		};
-
-		conf-cmd-data {
-			pins = "I2S2_OUT", "I2S4_IN", "I2S3_IN",
-			       "I2S2_IN","I2S4_OUT";
-			input-enable;
-			bias-pull-up;
-		};
-
-		conf-clk {
-			pins = "I2S3_OUT";
-			bias-pull-down;
-		};
-	};
-
-	/* Serial NAND is shared pin with SPI-NOR */
-	serial_nand_pins: serial-nand-pins {
-		mux {
-			function = "flash";
-			groups = "snfi";
-		};
-	};
-
-	spic0_pins: spic0-pins {
-		mux {
-			function = "spi";
-			groups = "spic0_0";
-		};
-	};
-
-	spic1_pins: spic1-pins {
-		mux {
-			function = "spi";
-			groups = "spic1_0";
-		};
-	};
-
-	/* SPI-NOR is shared pin with serial NAND */
-	spi_nor_pins: spi-nor-pins {
-		mux {
-			function = "flash";
-			groups = "spi_nor";
-		};
-	};
-
-	/* serial NAND is shared pin with SPI-NOR */
-	serial_nand_pins: serial-nand-pins {
-		mux {
-			function = "flash";
-			groups = "snfi";
-		};
-	};
-
-	uart0_pins: uart0-pins {
-		mux {
-			function = "uart";
-			groups = "uart0_0_tx_rx" ;
-		};
-	};
-
-	uart2_pins: uart2-pins {
-		mux {
-			function = "uart";
-			groups = "uart2_1_tx_rx" ;
-		};
-	};
-
-	watchdog_pins: watchdog-pins {
-		mux {
-			function = "watchdog";
-			groups = "watchdog";
-		};
-	};
-};
-
-&pwm {
-	pinctrl-names = "default";
-	pinctrl-0 = <&pwm7_pins>;
-	status = "okay";
-};
-
-&pwrap {
-	pinctrl-names = "default";
-	pinctrl-0 = <&pmic_bus_pins>;
-
-	status = "okay";
-};
-
-&sata {
-	status = "disable";
-};
-
-&sata_phy {
-	status = "disable";
-};
-
-&snfi {
-	pinctrl-names = "default";
-	pinctrl-0 = <&serial_nand_pins>;
-	status = "okay";
-
-	spi_nand@0 {
-		#address-cells = <1>;
-		#size-cells = <1>;
-		compatible = "spi-nand";
-		spi-max-frequency = <104000000>;
-		reg = <0>;
-
-		partitions {
-			compatible = "fixed-partitions";
-			#address-cells = <1>;
-			#size-cells = <1>;
-
-			partition@0 {
-				label = "Preloader";
-				reg = <0x00000 0x0080000>;
-				read-only;
-			};
-
-			partition@80000 {
-				label = "ATF";
-				reg = <0x80000 0x0040000>;
-			};
-
-			partition@c0000 {
-				label = "Bootloader";
-				reg = <0xc0000 0x0080000>;
-			};
-
-			partition@140000 {
-				label = "Config";
-				reg = <0x140000 0x0080000>;
-			};
-
-			factory: partition@1c0000 {
-				label = "Factory";
-				reg = <0x1c0000 0x0040000>;
-			};
-
-			partition@200000 {
-				label = "kernel";
-				reg = <0x200000 0x400000>;
-			};
-
-			partition@600000 {
-				label = "ubi";
-				reg = <0x600000 0x1C00000>;
-			};
-
-			partition@2200000 {
-				label = "User_data";
-				reg = <0x2200000 0x4000000>;
-			};
-		};
-	};
-};
-
-&spi0 {
-	pinctrl-names = "default";
-	pinctrl-0 = <&spic0_pins>;
-	status = "okay";
-};
-
-&spi1 {
-	pinctrl-names = "default";
-	pinctrl-0 = <&spic1_pins>;
-	status = "okay";
-};
-
-&ssusb {
-	vusb33-supply = <&reg_3p3v>;
-	vbus-supply = <&reg_5v>;
-	status = "okay";
-};
-
-&u3phy {
-	status = "okay";
-};
-
-&uart0 {
-	pinctrl-names = "default";
-	pinctrl-0 = <&uart0_pins>;
-	status = "okay";
-};
-
-&uart2 {
-	pinctrl-names = "default";
-	pinctrl-0 = <&uart2_pins>;
-	status = "okay";
-};
-
-&watchdog {
-	pinctrl-names = "default";
-	pinctrl-0 = <&watchdog_pins>;
-	status = "okay";
-};
-
-&wmac {
-	mediatek,mtd-eeprom = <&factory 0x0000>;
-	status = "okay";
-};
diff --git a/target/linux/mediatek/files-5.4/arch/arm64/boot/dts/mediatek/mt7622-ubnt-unifi-6-lr.dts b/target/linux/mediatek/files-5.4/arch/arm64/boot/dts/mediatek/mt7622-ubnt-unifi-6-lr.dts
deleted file mode 100644
index 1f410b1d47..0000000000
--- a/target/linux/mediatek/files-5.4/arch/arm64/boot/dts/mediatek/mt7622-ubnt-unifi-6-lr.dts
+++ /dev/null
@@ -1,327 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0-or-later OR MIT
-
-/dts-v1/;
-#include <dt-bindings/input/input.h>
-#include <dt-bindings/gpio/gpio.h>
-#include <dt-bindings/leds/common.h>
-
-#include "mt7622.dtsi"
-#include "mt6380.dtsi"
-
-/ {
-	model = "Ubiquiti UniFi 6 LR";
-	compatible = "ubnt,unifi-6-lr", "mediatek,mt7622";
-
-	aliases {
-		led-boot = &led_blue;
-		led-failsafe = &led_blue;
-		led-running = &led_blue;
-		led-upgrade = &led_blue;
-		label-mac-device = &gmac0;
-		serial0 = &uart0;
-	};
-
-	chosen {
-		stdout-path = "serial0:115200n8";
-		bootargs = "earlycon=uart8250,mmio32,0x11002000 swiotlb=512 console=ttyS0,115200n8";
-	};
-
-	cpus {
-		cpu@0 {
-			proc-supply = <&mt6380_vcpu_reg>;
-			sram-supply = <&mt6380_vm_reg>;
-		};
-
-		cpu@1 {
-			proc-supply = <&mt6380_vcpu_reg>;
-			sram-supply = <&mt6380_vm_reg>;
-		};
-	};
-
-	gpio-keys {
-		compatible = "gpio-keys";
-
-		reset {
-			label = "reset";
-			linux,code = <KEY_RESTART>;
-			gpios = <&pio 62 GPIO_ACTIVE_LOW>;
-		};
-	};
-
-	memory {
-		reg = <0 0x40000000 0 0x3f000000>;
-	};
-
-	reg_1p8v: regulator-1p8v {
-		compatible = "regulator-fixed";
-		regulator-name = "fixed-1.8V";
-		regulator-min-microvolt = <1800000>;
-		regulator-max-microvolt = <1800000>;
-		regulator-always-on;
-	};
-
-	reg_3p3v: regulator-3p3v {
-		compatible = "regulator-fixed";
-		regulator-name = "fixed-3.3V";
-		regulator-min-microvolt = <3300000>;
-		regulator-max-microvolt = <3300000>;
-		regulator-boot-on;
-		regulator-always-on;
-	};
-};
-
-&pcie0 {
-	pinctrl-names = "default";
-	pinctrl-0 = <&pcie0_pins>;
-	status = "okay";
-};
-
-&slot0 {
-	wifi@0,0 {
-		reg = <0x0 0 0 0 0>;
-		mediatek,mtd-eeprom = <&factory 0x20000>;
-		mtd-mac-address = <&eeprom 0x6>;
-		ieee80211-freq-limit = <5000000 6000000>;
-	};
-};
-
-&pio {
-	eth_pins: eth-pins {
-		mux {
-			function = "eth";
-			groups = "mdc_mdio", "rgmii_via_gmac2";
-		};
-	};
-
-	pcie0_pins: pcie0-pins {
-		mux {
-			function = "pcie";
-			groups = "pcie0_pad_perst",
-				 "pcie0_1_waken",
-				 "pcie0_1_clkreq";
-		};
-	};
-
-	pcie1_pins: pcie1-pins {
-		mux {
-			function = "pcie";
-			groups = "pcie1_pad_perst",
-				 "pcie1_0_waken",
-				 "pcie1_0_clkreq";
-		};
-	};
-
-	pmic_bus_pins: pmic-bus-pins {
-		mux {
-			function = "pmic";
-			groups = "pmic_bus";
-		};
-	};
-
-	spi_nor_pins: spi-nor-pins {
-		mux {
-			function = "flash";
-			groups = "spi_nor";
-		};
-	};
-
-	uart0_pins: uart0-pins {
-		mux {
-			function = "uart";
-			groups = "uart0_0_tx_rx" ;
-		};
-	};
-
-	uart3_pins: uart3-pins {
-		mux {
-			function = "uart";
-			groups = "uart3_1_tx_rx" ;
-		};
-	};
-
-	i2c0_pins: i2c0-pins {
-		mux {
-			function = "i2c";
-			groups =  "i2c0";
-		};
-	};
-
-	watchdog_pins: watchdog-pins {
-		mux {
-			function = "watchdog";
-			groups = "watchdog";
-		};
-	};
-};
-
-&bch {
-	status = "okay";
-};
-
-&btif {
-	status = "disabled";
-};
-
-&eth {
-	status = "okay";
-	pinctrl-names = "default";
-	pinctrl-0 = <&eth_pins>;
-
-	gmac0: mac@0 {
-		compatible = "mediatek,eth-mac";
-		reg = <0>;
-
-		phy-mode = "2500base-x";
-		mtd-mac-address = <&eeprom 0x0>;
-
-		fixed-link {
-			speed = <2500>;
-			full-duplex;
-		};
-	};
-
-	mdio: mdio-bus {
-		#address-cells = <1>;
-		#size-cells = <0>;
-
-		ethernet-phy@8 {
-			/* Marvell AQRate AQR112W - no driver */
-			compatible = "ethernet-phy-ieee802.3-c45";
-			reg = <0x8>;
-		};
-	};
-};
-
-&pwrap {
-	pinctrl-names = "default";
-	pinctrl-0 = <&pmic_bus_pins>;
-
-	status = "okay";
-};
-
-&nor_flash {
-	pinctrl-names = "default";
-	pinctrl-0 = <&spi_nor_pins>;
-
-	status = "okay";
-
-	flash@0 {
-		compatible = "jedec,spi-nor";
-		reg = <0>;
-		spi-max-frequency = <50000000>;
-
-		partitions {
-			compatible = "fixed-partitions";
-			#address-cells = <1>;
-			#size-cells = <1>;
-
-			partition@0 {
-				label = "preloader";
-				reg = <0x0 0x40000>;
-				read-only;
-			};
-
-			partition@40000 {
-				label = "atf";
-				reg = <0x40000 0x20000>;
-				read-only;
-			};
-
-			partition@60000 {
-				label = "u-boot";
-				reg = <0x60000 0x60000>;
-				read-only;
-			};
-
-			partition@c0000 {
-				label = "u-boot-env";
-				reg = <0xc0000 0x10000>;
-			};
-
-			factory: partition@d0000 {
-				label = "factory";
-				reg = <0xd0000 0x40000>;
-				read-only;
-			};
-
-			eeprom: partition@110000 {
-				label = "eeprom";
-				reg = <0x110000 0x10000>;
-				read-only;
-			};
-
-			partition@120000 {
-				label = "bs";
-				reg = <0x120000 0x10000>;
-			};
-
-			partition@130000 {
-				label = "cfg";
-				reg = <0x130000 0x100000>;
-				read-only;
-			};
-
-			partition@230000 {
-				compatible = "denx,fit";
-				label = "firmware";
-				reg = <0x230000 0x1ee0000>;
-			};
-
-			partition@2110000 {
-				label = "kernel1";
-				reg = <0x2110000 0x1ee0000>;
-			};
-		};
-	};
-};
-
-&uart0 {
-	pinctrl-names = "default";
-	pinctrl-0 = <&uart0_pins>;
-	status = "okay";
-};
-
-&uart3 {
-	pinctrl-names = "default";
-	pinctrl-0 = <&uart3_pins>;
-	status = "okay";
-
-	/* MT7915 Bluetooth */
-};
-
-&i2c0 {
-	pinctrl-names = "default";
-	pinctrl-0 = <&i2c0_pins>;
-	status = "okay";
-
-	led-controller@30 {
-		compatible = "ubnt,ledbar";
-		reg = <0x30>;
-
-		enable-gpio = <&pio 59 0>;
-
-		red {
-			label = "red";
-		};
-
-		green {
-			label = "green";
-		};
-
-		led_blue: blue {
-			label = "blue";
-		};
-	};
-};
-
-&watchdog {
-	pinctrl-names = "default";
-	pinctrl-0 = <&watchdog_pins>;
-	status = "okay";
-};
-
-&wmac {
-	mediatek,mtd-eeprom = <&factory 0x0>;
-	mtd-mac-address = <&eeprom 0x0>;
-	status = "okay";
-};
diff --git a/target/linux/mediatek/image/Makefile b/target/linux/mediatek/image/Makefile
index 45e83cece5..7aa7a7285c 100644
--- a/target/linux/mediatek/image/Makefile
+++ b/target/linux/mediatek/image/Makefile
@@ -23,7 +23,7 @@ define Device/Default
   KERNEL = kernel-bin | lzma | \
 	fit lzma $$(KDIR)/image-$$(firstword $$(DEVICE_DTS)).dtb
   KERNEL_INITRAMFS = kernel-bin | lzma | \
-	fit lzma $$(KDIR)/image-$$(firstword $$(DEVICE_DTS)).dtb
+	fit lzma $$(KDIR)/image-$$(firstword $$(DEVICE_DTS)).dtb with-initrd
   FILESYSTEMS := squashfs
   DEVICE_DTS_DIR := $(DTS_DIR)
   IMAGES := sysupgrade.bin
diff --git a/target/linux/mediatek/image/mt7622.mk b/target/linux/mediatek/image/mt7622.mk
index bf706930e4..a4e4cb45a9 100644
--- a/target/linux/mediatek/image/mt7622.mk
+++ b/target/linux/mediatek/image/mt7622.mk
@@ -1,26 +1,65 @@
+DTS_DIR := $(DTS_DIR)/mediatek
+
 KERNEL_LOADADDR := 0x44080000
 
-define Device/bpi_bananapi-r64
-  DEVICE_VENDOR := Bpi
-  DEVICE_MODEL := Banana Pi R64
-  DEVICE_DTS := mt7622-bananapi-bpi-r64
-  DEVICE_DTS_DIR := $(DTS_DIR)/mediatek
-  SUPPORTED_DEVICES := bananapi,bpi-r64
-  DEVICE_PACKAGES := kmod-usb-ohci kmod-usb2 kmod-usb3 kmod-ata-ahci-mtk
+define Build/bl2
+	cat $(STAGING_DIR_IMAGE)/mt7622-$1-bl2.img >> $@
 endef
-TARGET_DEVICES += bpi_bananapi-r64
 
-define Device/bpi_bananapi-r64-rootdisk
-  DEVICE_VENDOR := Bpi
-  DEVICE_MODEL := Banana Pi R64 (rootdisk)
-  DEVICE_DTS := mt7622-bananapi-bpi-r64-rootdisk
-  DEVICE_DTS_DIR := $(DTS_DIR)/mediatek
-  SUPPORTED_DEVICES := bananapi,bpi-r64
-  DEVICE_PACKAGES := kmod-usb-ohci kmod-usb2 kmod-usb3 kmod-ata-ahci-mtk
-  IMAGES := sysupgrade-emmc.bin.gz
-  IMAGE/sysupgrade-emmc.bin.gz := sysupgrade-emmc | gzip | append-metadata
+define Build/bl31-uboot
+	cat $(STAGING_DIR_IMAGE)/mt7622_$1-u-boot.fip >> $@
+endef
+
+define Build/mt7622-gpt
+	cp $@ $@.tmp 2>/dev/null || true
+	ptgen -g -o $@.tmp -a 1 -l 1024 \
+		$(if $(findstring sdmmc,$1), \
+			-H \
+			-t 0x83	-N bl2		-r	-p 512k@512k \
+		) \
+			-t 0xef	-N fip		-r	-p 2M@2M \
+			-t 0x83	-N ubootenv	-r	-p 1M@4M \
+				-N recovery	-r	-p 32M@6M \
+		$(if $(findstring sdmmc,$1), \
+				-N install	-r	-p 7M@38M \
+			-t 0x2e -N production		-p $(CONFIG_TARGET_ROOTFS_PARTSIZE)M@45M \
+		) \
+		$(if $(findstring emmc,$1), \
+			-t 0x2e -N production		-p $(CONFIG_TARGET_ROOTFS_PARTSIZE)M@40M \
+		)
+	cat $@.tmp >> $@
+	rm $@.tmp
+endef
+
+
+define Device/bananapi_bpi-r64
+  DEVICE_VENDOR := Bananapi
+  DEVICE_MODEL := BPi-R64
+  DEVICE_DTS := mt7622-bananapi-bpi-r64
+  DEVICE_DTS_OVERLAY := mt7622-bananapi-bpi-r64-pcie1 mt7622-bananapi-bpi-r64-sata
+  DEVICE_PACKAGES := kmod-ata-ahci-mtk kmod-btmtkuart kmod-usb3 e2fsprogs mkf2fs f2fsck
+  ARTIFACTS := emmc-preloader.bin emmc-bl31-uboot.fip sdcard.img.gz snand-preloader.bin snand-bl31-uboot.fip
+  IMAGES := sysupgrade.itb
+  KERNEL_INITRAMFS_SUFFIX := -recovery.itb
+  ARTIFACT/emmc-preloader.bin	:= bl2 emmc-2ddr
+  ARTIFACT/emmc-bl31-uboot.fip	:= bl31-uboot bananapi_bpi-r64-emmc
+  ARTIFACT/snand-preloader.bin	:= bl2 snand-2ddr
+  ARTIFACT/snand-bl31-uboot.fip	:= bl31-uboot bananapi_bpi-r64-snand
+  ARTIFACT/sdcard.img.gz	:= mt7622-gpt sdmmc |\
+				   pad-to 512k | bl2 sdmmc-2ddr |\
+				   pad-to 2048k | bl31-uboot bananapi_bpi-r64-sdmmc |\
+				   pad-to 6144k | append-image-stage initramfs-recovery.itb |\
+				   pad-to 38912k | mt7622-gpt emmc |\
+				   pad-to 39424k | bl2 emmc-2ddr |\
+				   pad-to 40960k | bl31-uboot bananapi_bpi-r64-emmc |\
+				   pad-to 43008k | bl2 snand-2ddr |\
+				   pad-to 43520k | bl31-uboot bananapi_bpi-r64-snand |\
+				   pad-to 46080k | append-image squashfs-sysupgrade.itb | gzip
+  KERNEL			:= kernel-bin | gzip
+  KERNEL_INITRAMFS		:= kernel-bin | lzma | fit lzma $$(DTS_DIR)/$$(DEVICE_DTS).dtb with-initrd | pad-to 128k
+  IMAGE/sysupgrade.itb		:= append-kernel | fit gzip $$(DTS_DIR)/$$(DEVICE_DTS).dtb external-static-with-rootfs | append-metadata
 endef
-TARGET_DEVICES += bpi_bananapi-r64-rootdisk
+TARGET_DEVICES += bananapi_bpi-r64
 
 define Device/elecom_wrc-2533gent
   DEVICE_VENDOR := Elecom
@@ -30,7 +69,7 @@ define Device/elecom_wrc-2533gent
   DEVICE_PACKAGES := kmod-usb-ohci kmod-usb2 kmod-usb3 kmod-mt7615e \
 	kmod-mt7615-firmware kmod-btmtkuart swconfig
 endef
-TARGET_DEVICES += elecom_wrc-2533gent
+#TARGET_DEVICES += elecom_wrc-2533gent
 
 define Device/mediatek_mt7622-rfb1
   DEVICE_VENDOR := MediaTek
@@ -39,7 +78,7 @@ define Device/mediatek_mt7622-rfb1
   DEVICE_DTS_DIR := $(DTS_DIR)/mediatek
   DEVICE_PACKAGES := kmod-usb-ohci kmod-usb2 kmod-usb3 kmod-ata-ahci-mtk
 endef
-TARGET_DEVICES += mediatek_mt7622-rfb1
+#TARGET_DEVICES += mediatek_mt7622-rfb1
 
 define Device/mediatek_mt7622-ubi
   DEVICE_VENDOR := MediaTek
@@ -57,7 +96,7 @@ define Device/mediatek_mt7622-ubi
   IMAGE/sysupgrade.bin := sysupgrade-tar
   DEVICE_PACKAGES := kmod-usb-ohci kmod-usb2 kmod-usb3 kmod-ata-ahci-mtk
 endef
-TARGET_DEVICES += mediatek_mt7622-ubi
+#TARGET_DEVICES += mediatek_mt7622-ubi
 
 define Device/ubnt_unifi-6-lr
   DEVICE_VENDOR := Ubiquiti
@@ -66,4 +105,4 @@ define Device/ubnt_unifi-6-lr
   DEVICE_DTS_DIR := $(DTS_DIR)/mediatek
   DEVICE_PACKAGES := kmod-mt7915e
 endef
-TARGET_DEVICES += ubnt_unifi-6-lr
+#TARGET_DEVICES += ubnt_unifi-6-lr
diff --git a/target/linux/mediatek/mt7622/base-files-old/etc/board.d/02_network b/target/linux/mediatek/mt7622/base-files-old/etc/board.d/02_network
new file mode 100755
index 0000000000..52717ad727
--- /dev/null
+++ b/target/linux/mediatek/mt7622/base-files-old/etc/board.d/02_network
@@ -0,0 +1,65 @@
+
+. /lib/functions.sh
+. /lib/functions/uci-defaults.sh
+. /lib/functions/system.sh
+
+mediatek_setup_interfaces()
+{
+	local board="$1"
+
+	case $board in
+	bananapi,bpi-r64|\
+	linksys,e8450|\
+	linksys,e8450-ubi|\
+	mediatek,mt7622-rfb1|\
+	mediatek,mt7622-rfb1-ubi|\
+	ruijie,rg-ew3200gx-pro)
+		ucidef_set_interfaces_lan_wan "lan1 lan2 lan3 lan4" wan
+		;;
+	buffalo,wsr-2533dhp2)
+		ucidef_add_switch "switch0" \
+			"0:lan" "1:lan" "2:lan" "3:lan" "4:wan" "6@eth0"
+		;;
+	ubnt,unifi-6-lr|\
+	ubnt,unifi-6-lr-ubootmod)
+		ucidef_set_interface_lan "eth0"
+		;;
+	xiaomi,redmi-router-ax6s)
+		ucidef_set_interfaces_lan_wan "lan1 lan2 lan3" wan
+		;;
+	*)
+		ucidef_add_switch "switch0" \
+				  "0:lan" "1:lan" "2:lan" "3:lan" "4:wan" "6u@eth0" "5u@eth1"
+		;;
+	esac
+}
+
+mediatek_setup_macs()
+{
+	local board="$1"
+	local lan_mac=""
+	local wan_mac=""
+	local label_mac=""
+
+	case $board in
+	ruijie,rg-ew3200gx-pro)
+		lan_mac=$(macaddr_add $(get_mac_label) 1)
+		;;
+	xiaomi,redmi-router-ax6s)
+		wan_mac=$(mtd_get_mac_ascii bdata ethaddr_wan)
+		label_mac=$wan_mac
+		;;
+	esac
+
+	[ -n "$lan_mac" ] && ucidef_set_interface_macaddr "lan" $lan_mac
+	[ -n "$wan_mac" ] && ucidef_set_interface_macaddr "wan" $wan_mac
+	[ -n "$label_mac" ] && ucidef_set_label_macaddr $label_mac
+}
+
+board_config_update
+board=$(board_name)
+mediatek_setup_interfaces $board
+mediatek_setup_macs $board
+board_config_flush
+
+exit 0
\ No newline at end of file
diff --git a/target/linux/mediatek/mt7622/base-files/lib/preinit/79_move_config b/target/linux/mediatek/mt7622/base-files-old/lib/preinit/79_move_config
similarity index 100%
rename from target/linux/mediatek/mt7622/base-files/lib/preinit/79_move_config
rename to target/linux/mediatek/mt7622/base-files-old/lib/preinit/79_move_config
diff --git a/target/linux/mediatek/mt7622/base-files-old/lib/upgrade/platform.sh b/target/linux/mediatek/mt7622/base-files-old/lib/upgrade/platform.sh
new file mode 100755
index 0000000000..249db23d6f
--- /dev/null
+++ b/target/linux/mediatek/mt7622/base-files-old/lib/upgrade/platform.sh
@@ -0,0 +1,107 @@
+RAMFS_COPY_BIN='fw_printenv fw_setenv blockdev'
+RAMFS_COPY_DATA='/etc/fw_env.config /var/lock/fw_printenv.lock'
+
+get_cmdline_var() {
+	local var=$1
+	local cmdlinevar tmp
+	local cmdline="$(cat /proc/cmdline)"
+
+	for cmdlinevar in $cmdline; do
+		tmp=${cmdlinevar##${var}}
+		[ "=" = "${tmp:0:1}" ] && echo ${tmp:1}
+	done
+}
+
+get_rootdev() {
+	local rootvol rootdev
+	rootvol=$(get_cmdline_var root)
+	rootvol=$(basename $rootvol)
+	[ -e /sys/class/block/$rootvol/partition ] || {
+		echo $rootvol
+		return
+	}
+	rootdev=$(busybox readlink -f /sys/class/block/$rootvol)
+	rootdev=$(basename ${rootdev%%/${rootvol}})
+	[ -e /sys/class/block/$rootdev ] && echo $rootdev
+}
+
+get_partition() {
+	for partname in /sys/class/block/$1/*/name; do
+		[ "$(cat ${partname})" = "$2" ] && {
+			basename ${partname%%/name}
+			break
+		}
+	done
+}
+
+platform_do_upgrade() {
+	local board=$(board_name)
+	local file_type=$(identify $1)
+
+	case "$board" in
+	bananapi,bpi-r64)
+		local rootdev=$(get_rootdev)
+		local fitpart=$(get_partition $rootdev production)
+		[ "$fitpart" ] || exit 1
+		dd if=/dev/zero of=/dev/$fitpart bs=4096 count=1 2>/dev/null
+		blockdev --rereadpt /dev/$rootdev
+		get_image "$1" | dd of=/dev/$fitpart
+		echo $rootdev > /tmp/sysupgrade.rootdev
+		;;
+	linksys,e8450-ubi|\
+	mediatek,mt7622,ubi)
+		CI_KERNPART="fit"
+		nand_do_upgrade "$1"
+		;;
+	linksys,e8450)
+		if grep -q mtdparts=slave /proc/cmdline; then
+			PART_NAME=firmware2
+		else
+			PART_NAME=firmware1
+		fi
+		default_do_upgrade "$1"
+		;;
+	*)
+		default_do_upgrade "$1"
+		;;
+	esac
+}
+
+PART_NAME=firmware
+
+platform_check_image() {
+	local board=$(board_name)
+	local magic="$(get_magic_long "$1")"
+
+	[ "$#" -gt 1 ] && return 1
+
+	case "$board" in
+	*)
+		[ "$magic" != "d00dfeed" ] && {
+			echo "Invalid image type."
+			return 1
+		}
+		return 0
+		;;
+	esac
+
+	return 0
+}
+
+platform_copy_config_mmc() {
+	local rootdev=$(cat /tmp/sysupgrade.rootdev)
+	blockdev --rereadpt /dev/$rootdev
+	local datadev=$(get_partition $rootdev rootfs_data)
+	[ "$datadev" ] || echo "no rootfs_data partition, cannot keep configuration." >&2
+	dd if="$UPGRADE_BACKUP" of=/dev/$datadev
+	sync
+	sleep 4
+}
+
+platform_copy_config() {
+	case "$(board_name)" in
+	bananapi,bpi-r64)
+		platform_copy_config_mmc
+		;;
+	esac
+}
\ No newline at end of file
diff --git a/target/linux/mediatek/mt7622/base-files/etc/board.d/01_leds b/target/linux/mediatek/mt7622/base-files/etc/board.d/01_leds
new file mode 100644
index 0000000000..65a81df8da
--- /dev/null
+++ b/target/linux/mediatek/mt7622/base-files/etc/board.d/01_leds
@@ -0,0 +1,17 @@
+. /lib/functions/leds.sh
+. /lib/functions/uci-defaults.sh
+
+board=$(board_name)
+
+board_config_update
+
+case $board in
+linksys,e8450|\
+linksys,e8450-ubi)
+	ucidef_set_led_netdev "wan" "WAN" "inet:blue" "wan"
+	;;
+esac
+
+board_config_flush
+
+exit 0
diff --git a/target/linux/mediatek/mt7622/base-files/etc/board.d/02_network b/target/linux/mediatek/mt7622/base-files/etc/board.d/02_network
old mode 100755
new mode 100644
index 3a409c8ec9..f1daa2fae1
--- a/target/linux/mediatek/mt7622/base-files/etc/board.d/02_network
+++ b/target/linux/mediatek/mt7622/base-files/etc/board.d/02_network
@@ -1,4 +1,3 @@
-#!/bin/sh
 
 . /lib/functions.sh
 . /lib/functions/uci-defaults.sh
@@ -9,13 +8,16 @@ mediatek_setup_interfaces()
 	local board="$1"
 
 	case $board in
-	bananapi,bpi-r64-rootdisk|\
-	bananapi,bpi-r64)
-		ucidef_set_interfaces_lan_wan "lan0 lan1 lan2 lan3" wan
-		;;
+	bananapi,bpi-r64|\
+	linksys,e8450|\
+	linksys,e8450-ubi|\
 	mediatek,mt7622-rfb1)
 		ucidef_set_interfaces_lan_wan "lan1 lan2 lan3 lan4" wan
 		;;
+	buffalo,wsr-2533dhp2)
+		ucidef_add_switch "switch0" \
+			"0:lan" "1:lan" "2:lan" "3:lan" "4:wan" "6@eth0"
+		;;
 	ubnt,unifi-6-lr)
 		ucidef_set_interfaces_lan "eth0"
 		;;
@@ -26,18 +28,9 @@ mediatek_setup_interfaces()
 	esac
 }
 
-mediatek_setup_macs()
-{
-	local board="$1"
-
-	case $board in
-	esac
-}
-
 board_config_update
 board=$(board_name)
 mediatek_setup_interfaces $board
-mediatek_setup_macs $board
 board_config_flush
 
 exit 0
diff --git a/target/linux/mediatek/mt7622/base-files/etc/init.d/bootcount b/target/linux/mediatek/mt7622/base-files/etc/init.d/bootcount
new file mode 100755
index 0000000000..bc4eeb6530
--- /dev/null
+++ b/target/linux/mediatek/mt7622/base-files/etc/init.d/bootcount
@@ -0,0 +1,11 @@
+#!/bin/sh /etc/rc.common
+
+START=99
+
+boot() {
+	case $(board_name) in
+	linksys,e8450)
+		mtd erase senv || true
+		;;
+	esac
+}
diff --git a/target/linux/mediatek/mt7622/base-files/etc/uci-defaults/09_fix_crc b/target/linux/mediatek/mt7622/base-files/etc/uci-defaults/09_fix_crc
new file mode 100644
index 0000000000..81cb6b18b7
--- /dev/null
+++ b/target/linux/mediatek/mt7622/base-files/etc/uci-defaults/09_fix_crc
@@ -0,0 +1,10 @@
+. /lib/functions.sh
+
+kernel_size=$(sed -n 's/mtd[0-9]*: \([0-9a-f]*\).*"\(kernel\|linux\)".*/\1/p' /proc/mtd)
+
+case "$(board_name)" in
+buffalo,wsr-2533dhp2)
+	mtd -M 0x44485032 ${kernel_size:+-c 0x$kernel_size} fixtrx firmware && exit 0
+	exit 1
+	;;
+esac
diff --git a/target/linux/mediatek/mt7622/base-files/lib/upgrade/buffalo.sh b/target/linux/mediatek/mt7622/base-files/lib/upgrade/buffalo.sh
new file mode 100644
index 0000000000..844cc4ed95
--- /dev/null
+++ b/target/linux/mediatek/mt7622/base-files/lib/upgrade/buffalo.sh
@@ -0,0 +1,126 @@
+# ======== dev note ========
+# for following buffalo MT7622 devices:
+#
+# - WSR-2533DHP2 (trx magic: "DHP2")
+# - WSR-2533DHP3 (trx magic: "DHP3")
+# - WSR-3200AX4S (trx magic: "DHP3")
+#
+# sysupgrade-tar image:
+#
+# This is for normal upgrading for OpenWrt.
+# use nand_do_upgrade with CI_KERNPART="firmware"
+#
+# - if the size of new kernel is not equal with the current kernel's
+#   -> block upgrade and print a message about using TRX + UBI
+#      formatted image
+#   (should be flashed the new ubi contains rootfs + rootfs_data
+#   with the offset (=new padded kernel's end) if this case? But
+#   it maybe too hard for writing scripts...)
+#
+# TRX + UBI formatted image:
+#
+# This is for upgrading if the new kernel is larger than the
+# current kernel.
+#
+# ex:
+#   - stock firmware is installed in the flash and booted with
+#     OpenWrt initramfs image
+#   - kernel partition is increased from 4MiB in OpenWrt in the
+#     future
+#
+# packing TRX + UBI formatted image by tar is needed for image validation
+# with the metadata in the future?
+# ====== dev note end ======
+#
+# The mtd partitions "firmware" and "Kernel2" on NAND flash are os-image
+# partitions. These partitions are called as "Image1/Image2" in U-Boot
+# on WSR-2533DHP2, and they are checked conditions when booting.
+# "Image1" is always used for booting.
+#
+# == U-Boot Behaviors ==
+# - "Image1"/"Image2" images are good, images are different or
+#   "Image2" image is broken
+#   -> writes os-image to "Image2" from "Image1"
+#
+# - "Image1" image is broken
+#   -> writes os-image to "Image1" from "Image2"
+#
+# - "Image1"/"Image2" images are broken
+#   -> fall to U-Boot command line
+
+buffalo_check_image() {
+	local board="$1"
+	local boardname="$(echo $board | tr ',' '_')"
+	local magic="$2"
+	local fw_image="$3"
+
+	# return error state if TRX + UBI formatted image specified
+	# to notify about configurations
+	if [ "$magic" = "44485032" -o "$magic" = "44485033" ]; then
+		echo "Your configurations won't be saved if factory-uboot.bin image specified."
+		echo "But if you want to upgrade, please execute sysupgrade with \"-F\" option."
+		return 1
+	fi
+
+	# check if valid tar file specifed
+	if ! tar tf "$fw_image" &>/dev/null; then
+		echo "Specified file is not a tar archive: $fw_image"
+		return 1
+	fi
+
+	local control_len=$( (tar xf $fw_image sysupgrade-$boardname/CONTROL -O | wc -c) 2> /dev/null)
+
+	# check if valid sysupgrade tar archive
+	if [ "$control_len" = "0" ]; then
+		echo "Invalid sysupgrade file: $fw_image"
+		return 1
+	fi
+
+	local kern_part_len=$(grep "\"linux\"" /proc/mtd | sed "s/mtd[0-9]*:[ \t]*\([^ \t]*\).*/\1/")
+	[ -z "$kern_part_len" ] && {
+		echo "Unable to get \"linux\" partition size"
+		return 1
+	}
+	kern_part_len=$((0x$kern_part_len))
+
+	# this also checks if the sysupgrade image is for correct models
+	local kern_bin_len=$( (tar xf $fw_image sysupgrade-${boardname}/kernel -O | wc -c) 2> /dev/null)
+	if [ -z "$kern_bin_len" ]; then
+		echo "Failed to get new kernel size, is valid sysupgrade image specified for the device?"
+		return 1
+	fi
+
+	# kernel binary has a trx header (len: 28 (0x1c))
+	kern_bin_len=$((kern_bin_len - 28))
+
+	if [ "$kern_bin_len" != "$kern_part_len" ]; then
+		echo -n "The length of new kernel is invalid for current "
+		echo "\"linux\" partition, please use factory-uboot.bin image."
+		echo "\"linux\" partition: $kern_part_len, new kernel: $kern_bin_len"
+		return 1
+	fi
+}
+
+# for TRX + UBI formatted image
+buffalo_upgrade_ubinized() {
+	sync
+	echo 3 > /proc/sys/vm/drop_caches
+
+	local mtdnum="$( find_mtd_index "ubi" )"
+	# if no "ubi", don't return error for the purpose of recovery
+	# ex: recovery after accidental erasing "firmware" partition
+	if [ ! "$mtdnum" ]; then
+		echo "cannot find ubi mtd partition \"ubi\", skip detachment"
+	else
+		ubidetach -m "$mtdnum"
+	fi
+
+	# erase all data in "firmware"
+	mtd erase "${PART_NAME}"
+	# write TRX + UBI formatted image to "firmware"
+	get_image "$1" | mtd $MTD_ARGS write - "${PART_NAME:-firmware}"
+	if [ $? -ne 0 ]; then
+		echo "Failed to write the specified image."
+		exit 1
+	fi
+}
diff --git a/target/linux/mediatek/mt7622/base-files/lib/upgrade/platform.sh b/target/linux/mediatek/mt7622/base-files/lib/upgrade/platform.sh
index 8144476943..e6afb9547c 100755
--- a/target/linux/mediatek/mt7622/base-files/lib/upgrade/platform.sh
+++ b/target/linux/mediatek/mt7622/base-files/lib/upgrade/platform.sh
@@ -1,13 +1,53 @@
+REQUIRE_IMAGE_METADATA=1
+RAMFS_COPY_BIN='fw_printenv fw_setenv fwtool'
+RAMFS_COPY_DATA='/etc/fw_env.config /var/lock/fw_printenv.lock'
+
 platform_do_upgrade() {
 	local board=$(board_name)
+	local file_type=$(identify $1)
 
 	case "$board" in
-	bananapi,bpi-r64-rootdisk)
-		#2097152=0x200000 is the offset in bytes from the start
-		#of eMMC and to the location of the kernel
-		get_image "$1" | dd of=/dev/mmcblk0 bs=2097152 seek=1 conv=fsync
+	bananapi,bpi-r64)
+		export_bootdevice
+		export_partdevice rootdev 0
+		case "$rootdev" in
+		mmc*)
+			CI_ROOTDEV="$rootdev"
+			CI_KERNPART="production"
+			emmc_do_upgrade "$1"
+			;;
+		*)
+			CI_KERNPART="fit"
+			nand_do_upgrade "$1"
+			;;
+		esac
+		;;
+	buffalo,wsr-2533dhp2)
+		local magic="$(get_magic_long "$1")"
+
+		# use "mtd write" if the magic is "DHP2 (0x44485032)"
+		# or "DHP3 (0x44485033)"
+		if [ "$magic" = "44485032" -o "$magic" = "44485033" ]; then
+			buffalo_upgrade_ubinized "$1"
+		else
+			CI_KERNPART="firmware"
+			nand_do_upgrade "$1"
+		fi
 		;;
+	linksys,e8450-ubi|\
 	mediatek,mt7622,ubi)
+		CI_KERNPART="fit"
+		nand_do_upgrade "$1"
+		;;
+	linksys,e8450)
+		if grep -q mtdparts=slave /proc/cmdline; then
+			PART_NAME=firmware2
+		else
+			PART_NAME=firmware1
+		fi
+		default_do_upgrade "$1"
+		;;
+	totolink,a8000ru)
 		nand_do_upgrade "$1"
 		;;
 	*)
@@ -25,6 +65,12 @@ platform_check_image() {
 	[ "$#" -gt 1 ] && return 1
 
 	case "$board" in
+	buffalo,wsr-2533dhp2)
+		buffalo_check_image "$board" "$magic" "$1" || return 1
+		;;
+	totolink,a8000ru)
+		nand_do_platform_check "$board" "$1"
+		;;
 	*)
 		[ "$magic" != "d00dfeed" ] && {
 			echo "Invalid image type."
@@ -37,18 +83,14 @@ platform_check_image() {
 	return 0
 }
 
-platform_copy_config_emmc() {
-	mkdir -p /recovery
-	mount -o rw,noatime /dev/mmcblk0p6 /recovery
-	cp -af "$UPGRADE_BACKUP" "/recovery/$BACKUP_FILE"
-	sync
-	umount /recovery
-}
-
 platform_copy_config() {
 	case "$(board_name)" in
-	bananapi,bpi-r64-rootdisk)
-		platform_copy_config_emmc
+	bananapi,bpi-r64)
+		export_bootdevice
+		export_partdevice rootdev 0
+		if echo $rootdev | grep -q mmc; then
+			emmc_copy_config
+		fi
 		;;
 	esac
 }
diff --git a/target/linux/mediatek/mt7622/config-5.4 b/target/linux/mediatek/mt7622/config-5.4
index 282cd0bab5..c6fb4e47ef 100644
--- a/target/linux/mediatek/mt7622/config-5.4
+++ b/target/linux/mediatek/mt7622/config-5.4
@@ -227,6 +227,7 @@ CONFIG_EDAC_SUPPORT=y
 CONFIG_EFI_EARLYCON=y
 CONFIG_EINT_MTK=y
 CONFIG_FIXED_PHY=y
+# CONFIG_FIT_PARTITION is not set
 CONFIG_FIX_EARLYCON_MEM=y
 # CONFIG_FLATMEM_MANUAL is not set
 CONFIG_FONT_8x16=y
diff --git a/target/linux/mediatek/mt7622/target.mk b/target/linux/mediatek/mt7622/target.mk
index cb5a6b48cd..5403bf5f87 100644
--- a/target/linux/mediatek/mt7622/target.mk
+++ b/target/linux/mediatek/mt7622/target.mk
@@ -2,7 +2,7 @@ ARCH:=aarch64
 SUBTARGET:=mt7622
 BOARDNAME:=MT7622
 CPU_TYPE:=cortex-a53
-DEFAULT_PACKAGES += kmod-mt7615e kmod-mt7615-firmware wpad-basic-wolfssl
+DEFAULT_PACKAGES += kmod-mt7615e kmod-mt7615-firmware wpad-basic-wolfssl blockdev uboot-envtools
 KERNELNAME:=Image dtbs
 
 define Target/Description
diff --git a/target/linux/mediatek/patches-5.4/900-dts-mt7622-bpi-r64-aliases-for-dtoverlay.patch b/target/linux/mediatek/patches-5.4/900-dts-mt7622-bpi-r64-aliases-for-dtoverlay.patch
new file mode 100644
index 0000000000..4c6df93089
--- /dev/null
+++ b/target/linux/mediatek/patches-5.4/900-dts-mt7622-bpi-r64-aliases-for-dtoverlay.patch
@@ -0,0 +1,80 @@
+--- a/arch/arm64/boot/dts/mediatek/mt7622-bananapi-bpi-r64.dts
++++ b/arch/arm64/boot/dts/mediatek/mt7622-bananapi-bpi-r64.dts
+@@ -279,14 +279,14 @@
+ &pcie1 {
+ 	pinctrl-names = "default";
+ 	pinctrl-0 = <&pcie1_pins>;
+-	status = "okay";
++	status = "disabled";
+ };
+ 
+ &pio {
+ 	/* Attention: GPIO 90 is used to switch between PCIe@1,0 and
+ 	 * SATA functions. i.e. output-high: PCIe, output-low: SATA
+ 	 */
+-	asm_sel {
++	asmsel: asm_sel {
+ 		gpio-hog;
+ 		gpios = <90 GPIO_ACTIVE_HIGH>;
+ 		output-high;
+--- /dev/null
++++ b/arch/arm64/boot/dts/mediatek/mt7622-bananapi-bpi-r64-sata.dts
+@@ -0,0 +1,31 @@
++/* SPDX-License-Identifier: (GPL-2.0-only OR MIT) */
++
++#include <dt-bindings/gpio/gpio.h>
++
++/dts-v1/;
++/plugin/;
++
++/ {
++	compatible = "bananapi,bpi-r64", "mediatek,mt7622";
++
++	fragment@0 {
++		target = <&asmsel>;
++		__overlay__ {
++			gpios = <90 GPIO_ACTIVE_LOW>;
++		};
++	};
++
++	fragment@1 {
++		target = <&sata>;
++		__overlay__ {
++			status = "okay";
++		};
++	};
++
++	fragment@2 {
++		target = <&sata_phy>;
++		__overlay__ {
++			status = "okay";
++		};
++	};
++};
+--- /dev/null
++++ b/arch/arm64/boot/dts/mediatek/mt7622-bananapi-bpi-r64-pcie1.dts
+@@ -0,0 +1,24 @@
++/* SPDX-License-Identifier: (GPL-2.0-only OR MIT) */
++
++#include <dt-bindings/gpio/gpio.h>
++
++/dts-v1/;
++/plugin/;
++
++/ {
++	compatible = "bananapi,bpi-r64", "mediatek,mt7622";
++
++	fragment@0 {
++		target = <&asmsel>;
++		__overlay__ {
++			gpios = <90 GPIO_ACTIVE_HIGH>;
++		};
++	};
++
++	fragment@1 {
++		target = <&pcie1>;
++		__overlay__ {
++			status = "okay";
++		};
++	};
++};
diff --git a/tools/firmware-utils/Makefile b/tools/firmware-utils/Makefile
index cec8398a27..285722c3c2 100644
--- a/tools/firmware-utils/Makefile
+++ b/tools/firmware-utils/Makefile
@@ -24,81 +24,80 @@ endef
 
 define Host/Compile
 	mkdir -p $(HOST_BUILD_DIR)/bin
-	$(call cc,add_header)
-	$(call cc,addpattern)
-	$(call cc,asustrx)
+	$(call cc,add_header,-Wall)
+	$(call cc,addpattern,-Wall)
+	$(call cc,asustrx,-Wall)
 	$(call cc,bcm4908asus,-Wall)
 	$(call cc,bcm4908kernel,-Wall)
 	$(call cc,buffalo-enc buffalo-lib,-Wall)
 	$(call cc,buffalo-tag buffalo-lib,-Wall)
 	$(call cc,buffalo-tftp buffalo-lib,-Wall)
-	$(call cc,dgfirmware)
+	$(call cc,dgfirmware,-Wall)
 	$(call cc,dgn3500sum,-Wall)
 	$(call cc,dns313-header,-Wall)
 	$(call cc,edimax_fw_header,-Wall)
-	$(call cc,encode_crc)
+	$(call cc,encode_crc,-Wall)
 	$(call cc,fix-u-media-header cyg_crc32,-Wall)
-	$(call cc,hcsmakeimage bcmalgo)
-	$(call cc,imagetag imagetag_cmdline cyg_crc32)
+	$(call cc,hcsmakeimage bcmalgo,-Wall)
+	$(call cc,imagetag imagetag_cmdline cyg_crc32,-Wall)
 	$(call cc,jcgimage,-lz -Wall)
-	$(call cc,lxlfw)
-	$(call cc,lzma2eva,-lz)
-	$(call cc,makeamitbin)
-	$(call cc,mkbrncmdline)
-	$(call cc,mkbrnimg)
+	$(call cc,lxlfw,-Wall)
+	$(call cc,lzma2eva,-lz -Wall)
+	$(call cc,makeamitbin,-Wall)
+	$(call cc,mkbrncmdline,-Wall)
+	$(call cc,mkbrnimg,-Wall)
 	$(call cc,mkbuffaloimg,-Wall)
 	$(call cc,mkcameofw,-Wall)
-	$(call cc,mkcasfw)
-	$(call cc,mkchkimg)
-	$(call cc,mkcsysimg)
-	$(call cc,mkdapimg)
-	$(call cc,mkdapimg2)
+	$(call cc,mkcasfw,-Wall)
+	$(call cc,mkchkimg,-Wall)
+	$(call cc,mkcsysimg,-Wall)
+	$(call cc,mkdapimg,-Wall)
+	$(call cc,mkdapimg2,-Wall)
 	$(call cc,mkdhpimg buffalo-lib,-Wall)
 	$(call cc,mkdlinkfw mkdlinkfw-lib,-lz -Wall --std=c99)
-	$(call cc,mkdniimg)
-	$(call cc,mkedimaximg)
+	$(call cc,mkdniimg,-Wall)
+	$(call cc,mkedimaximg,-Wall)
 	$(call cc,mkfwimage,-lz -Wall -Werror -Wextra -D_FILE_OFFSET_BITS=64)
-	$(call cc,mkfwimage2,-lz)
-	$(call cc,mkheader_gemtek,-lz)
-	$(call cc,mkhilinkfw,-lcrypto)
+	$(call cc,mkfwimage2,-lz -Wall)
+	$(call cc,mkheader_gemtek,-lz -Wall)
+	$(call cc,mkhilinkfw,-lcrypto -Wall)
 	$(call cc,mkmerakifw sha1,-Wall)
 	$(call cc,mkmerakifw-old,-Wall)
-	$(call cc,mkmylofw)
-	$(call cc,mkplanexfw sha1)
+	$(call cc,mkmylofw,-Wall)
+	$(call cc,mkplanexfw sha1,-Wall)
 	$(call cc,mkporayfw,-Wall)
-	$(call cc,mkrasimage,--std=gnu99)
-	$(call cc,mkrtn56uimg,-lz)
+	$(call cc,mkrasimage,--std=gnu99 -Wall)
+	$(call cc,mkrtn56uimg,-lz -Wall)
 	$(call cc,mksenaofw md5,-Wall --std=gnu99)
 	$(call cc,mksercommfw,-Wall)
-	$(call cc,mktitanimg)
+	$(call cc,mktitanimg,-Wall)
 	$(call cc,mktplinkfw mktplinkfw-lib md5,-Wall -fgnu89-inline)
-	$(call cc,mktplinkfw2 mktplinkfw-lib md5,-fgnu89-inline)
+	$(call cc,mktplinkfw2 mktplinkfw-lib md5,-Wall -fgnu89-inline)
 	$(call cc,mkwrggimg md5,-Wall)
 	$(call cc,mkwrgimg md5,-Wall)
-	$(call cc,mkzcfw cyg_crc32)
-	$(call cc,mkzynfw)
-	$(call cc,motorola-bin)
-	$(call cc,nand_ecc)
+	$(call cc,mkzcfw cyg_crc32,-Wall)
+	$(call cc,mkzynfw,-Wall)
+	$(call cc,motorola-bin,-Wall)
+	$(call cc,nand_ecc,-Wall)
 	$(call cc,nec-enc,-Wall --std=gnu99)
-	$(call cc,osbridge-crc)
+	$(call cc,osbridge-crc,-Wall)
 	$(call cc,oseama md5,-Wall)
-	$(call cc,otrx)
+	$(call cc,otrx,-Wall)
 	$(call cc,pc1crypt)
-	$(call cc,ptgen cyg_crc32)
-	$(call cc,seama md5)
+	$(call cc,ptgen cyg_crc32,-Wall)
+	$(call cc,seama md5,-Wall)
 	$(call cc,sign_dlink_ru md5,-Wall)
-	$(call cc,spw303v)
+	$(call cc,spw303v,-Wall)
 	$(call cc,srec2bin)
 	$(call cc,tplink-safeloader md5,-Wall --std=gnu99)
-	$(call cc,trx)
-	$(call cc,trx2edips)
-	$(call cc,trx2usr)
+	$(call cc,trx,-Wall)
+	$(call cc,trx2edips,-Wall)
+	$(call cc,trx2usr,-Wall)
 	$(call cc,uimage_padhdr,-Wall -lz)
-	$(call cc,wrt400n cyg_crc32)
-	$(call cc,xorimage)
+	$(call cc,wrt400n cyg_crc32,-Wall)
+	$(call cc,xorimage,-Wall)
 	$(call cc,zyimage,-Wall)
-	$(call cc,zytrx,-Wall)
-	$(call cc,zyxbcm)
+	$(call cc,zyxbcm,-Wall)
 endef
 
 define Host/Install
diff --git a/tools/firmware-utils/src/add_header.c b/tools/firmware-utils/src/add_header.c
index 37775c3e0c..726e54c6bf 100644
--- a/tools/firmware-utils/src/add_header.c
+++ b/tools/firmware-utils/src/add_header.c
@@ -65,7 +65,7 @@ static uint32_t crc32buf(unsigned char *buf, size_t len)
 }
 
 struct header {
-	unsigned char model[16];
+	char model[16];
 	uint32_t crc;
 };
 
diff --git a/tools/firmware-utils/src/asustrx.c b/tools/firmware-utils/src/asustrx.c
index 67f2680b31..04af9a184a 100644
--- a/tools/firmware-utils/src/asustrx.c
+++ b/tools/firmware-utils/src/asustrx.c
@@ -132,7 +132,7 @@ static void parse_options(int argc, char **argv) {
 			productid = optarg;
 			break;
 		case 'v':
-			if (sscanf(optarg, "%hu.%hu.%hu.%hu", &version[0], &version[1], &version[2], &version[3]) != 4)
+			if (sscanf(optarg, "%hhu.%hhu.%hhu.%hhu", &version[0], &version[1], &version[2], &version[3]) != 4)
 				fprintf(stderr, "Version %s doesn't match suppored 4-digits format\n", optarg);
 			break;
 		}
@@ -150,7 +150,8 @@ static void usage() {
 int main(int argc, char **argv) {
 	struct trx_header hdr;
 	struct asustrx_tail tail = { };
-	FILE *in, *out;
+	FILE *out = NULL;
+	FILE *in = NULL;
 	uint8_t buf[1024];
 	size_t bytes;
 	size_t length = 0;
diff --git a/tools/firmware-utils/src/bcmalgo.c b/tools/firmware-utils/src/bcmalgo.c
index e7d3b113be..c0865a183b 100644
--- a/tools/firmware-utils/src/bcmalgo.c
+++ b/tools/firmware-utils/src/bcmalgo.c
@@ -98,7 +98,6 @@ uint16_t get_hcs ( ldr_header_t* hd )
 	uint8_t hcs_minor;
 	uint8_t hcs_major;
 	uint16_t n = 0xffff;
-	uint16_t m = 0;
 	int state = 0;
 	int i,j;
 	for ( i = 0; i < 0x54; i++ )
@@ -226,7 +225,7 @@ int dump_header ( ldr_header_t* hd )
 	printf ( "HNW:\t\t0x%04X\n",reverse_endian16 ( hd->her_znaet_chto ) ); //Hell knows what
 	printf ( "CRC:\t\t0x%08X\n",reverse_endian32 ( hd->crc ) );
 	printf ( "=== Binary Header Dump===\n" );
-	int i,j;
+	int i;
 	uint8_t* head = ( uint8_t* ) hd;
 	for ( i=0;i<=sizeof ( ldr_header_t );i++ )
 	{
diff --git a/tools/firmware-utils/src/cyg_crc.h b/tools/firmware-utils/src/cyg_crc.h
index 7b59803446..68669715cf 100644
--- a/tools/firmware-utils/src/cyg_crc.h
+++ b/tools/firmware-utils/src/cyg_crc.h
@@ -74,34 +74,34 @@ typedef uint16_t cyg_uint16;
 // Compute a CRC, using the POSIX 1003 definition
 
 __externC cyg_uint32
-cyg_posix_crc32(unsigned char *s, int len);
+cyg_posix_crc32(void *s, int len);
 
 // Gary S. Brown's 32 bit CRC
 
 __externC cyg_uint32
-cyg_crc32(unsigned char *s, int len);
+cyg_crc32(void *s, int len);
 
 // Gary S. Brown's 32 bit CRC, but accumulate the result from a
 // previous CRC calculation
 
 __externC cyg_uint32
-cyg_crc32_accumulate(cyg_uint32 crc, unsigned char *s, int len);
+cyg_crc32_accumulate(cyg_uint32 crc, void *s, int len);
 
 // Ethernet FCS Algorithm
 
 __externC cyg_uint32
-cyg_ether_crc32(unsigned char *s, int len);
+cyg_ether_crc32(void *s, int len);
 
 // Ethernet FCS algorithm, but accumulate the result from a previous
 // CRC calculation.
 
 __externC cyg_uint32
-cyg_ether_crc32_accumulate(cyg_uint32 crc, unsigned char *s, int len);
+cyg_ether_crc32_accumulate(cyg_uint32 crc, void *s, int len);
 
 // 16 bit CRC with polynomial x^16+x^12+x^5+1
 
 __externC cyg_uint16
-cyg_crc16(unsigned char *s, int len);
+cyg_crc16(void *s, int len);
 
 #endif // _SERVICES_CRC_CRC_H_
 
diff --git a/tools/firmware-utils/src/cyg_crc16.c b/tools/firmware-utils/src/cyg_crc16.c
index 8b3735289f..3861ff03e8 100644
--- a/tools/firmware-utils/src/cyg_crc16.c
+++ b/tools/firmware-utils/src/cyg_crc16.c
@@ -96,8 +96,9 @@ static const cyg_uint16 crc16_tab[] = {
 };
 
 cyg_uint16
-cyg_crc16(unsigned char *buf, int len)
+cyg_crc16(void *ptr, int len)
 {
+    unsigned char *buf = ptr;
     int i;
     cyg_uint16 cksum;
 
diff --git a/tools/firmware-utils/src/cyg_crc32.c b/tools/firmware-utils/src/cyg_crc32.c
index 9462598ae6..f13221e946 100644
--- a/tools/firmware-utils/src/cyg_crc32.c
+++ b/tools/firmware-utils/src/cyg_crc32.c
@@ -127,8 +127,9 @@ static const cyg_uint32 crc32_tab[] = {
 /* This is the standard Gary S. Brown's 32 bit CRC algorithm, but
    accumulate the CRC into the result of a previous CRC. */
 cyg_uint32 
-cyg_crc32_accumulate(cyg_uint32 crc32val, unsigned char *s, int len)
+cyg_crc32_accumulate(cyg_uint32 crc32val, void *ptr, int len)
 {
+  unsigned char *s = ptr;
   int i;
 
   for (i = 0;  i < len;  i++) {
@@ -139,7 +140,7 @@ cyg_crc32_accumulate(cyg_uint32 crc32val, unsigned char *s, int len)
 
 /* This is the standard Gary S. Brown's 32 bit CRC algorithm */
 cyg_uint32
-cyg_crc32(unsigned char *s, int len)
+cyg_crc32(void *s, int len)
 {
   return (cyg_crc32_accumulate(0,s,len));
 }
@@ -148,8 +149,9 @@ cyg_crc32(unsigned char *s, int len)
    result from a previous CRC calculation. This uses the Ethernet FCS
    algorithm.*/
 cyg_uint32
-cyg_ether_crc32_accumulate(cyg_uint32 crc32val, unsigned char *s, int len)
+cyg_ether_crc32_accumulate(cyg_uint32 crc32val, void *ptr, int len)
 {
+  unsigned char *s = ptr;
   int i;
 
   if (s == 0) return 0L;
@@ -164,7 +166,7 @@ cyg_ether_crc32_accumulate(cyg_uint32 crc32val, unsigned char *s, int len)
 /* Return a 32-bit CRC of the contents of the buffer, using the
    Ethernet FCS algorithm. */
 cyg_uint32
-cyg_ether_crc32(unsigned char *s, int len)
+cyg_ether_crc32(void *s, int len)
 {
   return cyg_ether_crc32_accumulate(0,s,len);
 }
diff --git a/tools/firmware-utils/src/dgn3500sum.c b/tools/firmware-utils/src/dgn3500sum.c
index eb80e6c01b..e86621bc1f 100644
--- a/tools/firmware-utils/src/dgn3500sum.c
+++ b/tools/firmware-utils/src/dgn3500sum.c
@@ -104,7 +104,7 @@ int main(int argc, char** argv)
   char *endptr, *buffer, *p;
   int count;  // size of file in bytes
   unsigned short sum = 0, sum1 = 0;
-  char sumbuf[9];
+  char sumbuf[8 + 8 + 1];
 
   if(argc < 3) {
     printf("ERROR: Argument missing!\n\nUsage %s filename starting offset in hex [PID code]\n\n", argv[0]);
diff --git a/tools/firmware-utils/src/dns313-header.c b/tools/firmware-utils/src/dns313-header.c
index 3c72b09bfb..42dd67771d 100644
--- a/tools/firmware-utils/src/dns313-header.c
+++ b/tools/firmware-utils/src/dns313-header.c
@@ -102,9 +102,11 @@ static const uint32_t crc32_table[256] = {
 };
 
 static uint32_t crc32(uint32_t crc,
-		      const unsigned char *buf,
+		      const void *data,
 		      unsigned int len)
 {
+	const uint8_t *buf = data;
+
 	crc = crc ^ 0xffffffffUL;
 	do {
 		crc = crc32_table[((int)crc ^ (*buf++)) & 0xff] ^ (crc >> 8);
@@ -112,7 +114,7 @@ static uint32_t crc32(uint32_t crc,
 	return crc ^ 0xffffffffUL;
 }
 
-static void be_wr(unsigned char *buf, uint32_t val)
+static void be_wr(char *buf, uint32_t val)
 {
 	buf[0] = (val >> 24) & 0xFFU;
 	buf[1] = (val >> 16) & 0xFFU;
@@ -126,16 +128,13 @@ int main(int argc, char **argv)
 	int fdout;
 	struct stat sb;
 	uint32_t filesize;
-	uint32_t padding;
 	int ret = 0;
 	const char *pathin;
 	const char *pathout;
-	unsigned char *buffer;
-	unsigned char *infop;
+	char *buffer;
 	uint32_t sum;
 	size_t bufsize;
 	size_t bytes;
-	int i;
 
 	if (argc < 3) {
 		printf("Too few arguments.\n");
@@ -150,12 +149,11 @@ int main(int argc, char **argv)
 		return ret;
 
 	filesize = sb.st_size;
-	padding = filesize % 4;
 	printf("INFILE: %s, size: %08x bytes\n", pathin, filesize);
 	/* File + extended header size */
 	bufsize = filesize + HEADER_SIZE;
 
-	printf("Allocate %08x bytes\n", bufsize);
+	printf("Allocate %08zx bytes\n", bufsize);
 	buffer = malloc(bufsize);
 	if (!buffer) {
 		printf("OOM: could not allocate buffer\n");
@@ -180,9 +178,6 @@ int main(int argc, char **argv)
 	}
 	close(fdin);
 
-	/* PREP HEADER AND FOOTER */
-	infop = buffer;
-
 	be_wr(buffer + OFFSET_MAGIC, IH_MAGIC);
 
 	/* FIXME: use actual time */
@@ -223,7 +218,7 @@ int main(int argc, char **argv)
 	be_wr(buffer + OFFSET_HCRC, sum);
 	printf("header checksum: 0x%08x\n", sum);
 
-	printf("OUTFILE: %s, size: %08x bytes\n", pathout, bufsize);
+	printf("OUTFILE: %s, size: %08zx bytes\n", pathout, bufsize);
 	fdout = open(pathout, O_RDWR|O_CREAT|O_TRUNC,S_IRWXU|S_IRGRP);
 	if (!fdout) {
 		printf("ERROR: could not open output file\n");
diff --git a/tools/firmware-utils/src/fw.h b/tools/firmware-utils/src/fw.h
index 778143d2c4..c8fb99b467 100644
--- a/tools/firmware-utils/src/fw.h
+++ b/tools/firmware-utils/src/fw.h
@@ -31,15 +31,15 @@
 #define PART_NAME_LENGTH 16
 
 typedef struct header {
-	uint8_t magic[MAGIC_LENGTH];
-	uint8_t version[256];
+	char magic[MAGIC_LENGTH];
+	char version[256];
 	u_int32_t crc;
 	u_int32_t pad;
 } __attribute__ ((packed)) header_t;
 
 typedef struct part {
-	uint8_t magic[MAGIC_LENGTH];
-	uint8_t name[PART_NAME_LENGTH];
+	char magic[MAGIC_LENGTH];
+	char name[PART_NAME_LENGTH];
 	uint8_t pad[12];
 	u_int32_t memaddr;
 	u_int32_t index;
diff --git a/tools/firmware-utils/src/imagetag.c b/tools/firmware-utils/src/imagetag.c
index bc70399cca..6b06bd785a 100644
--- a/tools/firmware-utils/src/imagetag.c
+++ b/tools/firmware-utils/src/imagetag.c
@@ -82,8 +82,8 @@ int tagfile(const char *kernel, const char *rootfs, const char *bin, \
 	struct bcm_tag tag;
 	struct kernelhdr khdr;
 	FILE *kernelfile = NULL, *rootfsfile = NULL, *binfile = NULL, *cfefile = NULL;
-	size_t cfeoff, cfelen, kerneloff, kernellen, rootfsoff, rootfslen, \
-	  read, imagelen, rootfsoffpadlen = 0, kernelfslen, kerneloffpadlen = 0, oldrootfslen, \
+	size_t cfelen, kerneloff, kernellen, rootfsoff, rootfslen, \
+	  read, imagelen, rootfsoffpadlen = 0, oldrootfslen, \
 	  rootfsend;
 	uint8_t readbuf[1024];
 	uint32_t imagecrc = IMAGETAG_CRC_START;
@@ -91,7 +91,6 @@ int tagfile(const char *kernel, const char *rootfs, const char *bin, \
 	uint32_t rootfscrc = IMAGETAG_CRC_START;
 	uint32_t kernelfscrc = IMAGETAG_CRC_START;
 	uint32_t fwaddr = 0;
-	uint8_t crc_val;
 	const uint32_t deadcode = htonl(DEADCODE);
 	int i;
 	int is_pirelli = 0;
@@ -126,7 +125,6 @@ int tagfile(const char *kernel, const char *rootfs, const char *bin, \
 
 	fwaddr = flash_start + image_offset;
 	if (cfefile) {
-	  cfeoff = flash_start;		  
 	  cfelen = getlen(cfefile);
 	  /* Seek to the start of the file after tag */
 	  fseek(binfile, sizeof(tag), SEEK_SET);
@@ -138,7 +136,6 @@ int tagfile(const char *kernel, const char *rootfs, const char *bin, \
 	  }
 
 	} else {
-	  cfeoff = 0;
 	  cfelen = 0;
 	}
 
@@ -239,7 +236,6 @@ int tagfile(const char *kernel, const char *rootfs, const char *bin, \
 	  oldrootfslen = getlen(rootfsfile);
 	  rootfslen = oldrootfslen;
 	  rootfslen = ( (rootfslen % block_size) > 0 ? (((rootfslen / block_size) + 1) * block_size) : rootfslen );
-	  kerneloffpadlen = rootfslen - oldrootfslen;
 	  oldrootfslen = rootfslen;
 
 	  kerneloff = rootfsoff + rootfslen;
@@ -391,7 +387,6 @@ int tagfile(const char *kernel, const char *rootfs, const char *bin, \
 
 int main(int argc, char **argv)
 {
-    int c, i;
 	char *kernel, *rootfs, *bin;
 	uint32_t flash_start, image_offset, block_size, load_address, entry;
 	flash_start = image_offset = block_size = load_address = entry = 0;
diff --git a/tools/firmware-utils/src/mkbrnimg.c b/tools/firmware-utils/src/mkbrnimg.c
index b7a73ff59d..9cddda3575 100644
--- a/tools/firmware-utils/src/mkbrnimg.c
+++ b/tools/firmware-utils/src/mkbrnimg.c
@@ -52,12 +52,13 @@ static void init_crc32()
 	}
 }
 
-static uint32_t crc32buf(unsigned char *buf, size_t len)
+static uint32_t crc32buf(const void *buf, size_t len)
 {
 	uint32_t crc = 0xFFFFFFFF;
+	const uint8_t *in = buf;
 
-	for (; len; len--, buf++)
-		crc = crc32[(uint8_t)crc ^ *buf] ^ (crc >> BPB);
+	for (; len; len--, in++)
+		crc = crc32[(uint8_t)crc ^ *in] ^ (crc >> BPB);
 	return ~crc;
 }
 
diff --git a/tools/firmware-utils/src/mkcasfw.c b/tools/firmware-utils/src/mkcasfw.c
index 5655bf1894..0e7aa17c1b 100644
--- a/tools/firmware-utils/src/mkcasfw.c
+++ b/tools/firmware-utils/src/mkcasfw.c
@@ -463,8 +463,9 @@ csum8_get(struct csum_state *css)
 
 
 void
-csum16_update(uint8_t *p, uint32_t len, struct csum_state *css)
+csum16_update(void *data, uint32_t len, struct csum_state *css)
 {
+	uint8_t *p = data;
 	uint16_t t;
 
 	if (css->odd) {
@@ -524,8 +525,10 @@ csum_init(struct csum_state *css, int size)
 }
 
 void
-csum_update(uint8_t *p, uint32_t len, struct csum_state *css)
+csum_update(void *data, uint32_t len, struct csum_state *css)
 {
+	uint8_t *p = data;
+
 	switch (css->size) {
 	case CSUM_TYPE_8:
 		csum8_update(p,len,css);
@@ -554,6 +557,10 @@ csum_get(struct csum_state *css)
 		break;
 	case CSUM_TYPE_32:
 		ret = csum32_get(css);
+		break;
+	default:
+		ERR("invalid checksum size\n");
+		return 0;
 	}
 
 	return ret;
@@ -564,19 +571,21 @@ csum_get(struct csum_state *css)
  * routines to write data to the output file
  */
 int
-write_out_data(FILE *outfile, uint8_t *data, size_t len,
+write_out_data(FILE *outfile, void *data, size_t len,
 		struct csum_state *css)
 {
+	uint8_t *ptr = data;
+
 	errno = 0;
 
-	fwrite(data, len, 1, outfile);
+	fwrite(ptr, len, 1, outfile);
 	if (errno) {
 		ERRS("unable to write output file");
 		return ERR_FATAL;
 	}
 
 	if (css) {
-		csum_update(data, len, css);
+		csum_update(ptr, len, css);
 	}
 
 	return 0;
@@ -755,6 +764,9 @@ write_out_header(FILE *outfile)
 		res = write_out_data(outfile, (uint8_t *)&tmp.nfs,
 					sizeof(tmp.nfs), NULL);
 		break;
+	default:
+		ERR("invalid header type\n");
+		return -EINVAL;
 	}
 
 	return res;
@@ -763,8 +775,7 @@ write_out_header(FILE *outfile)
 int
 write_out_images(FILE *outfile)
 {
-	struct image_desc *desc;
-	int i, res;
+	int res;
 
 	res = image_writeout(outfile, &kernel_image);
 	if (res)
@@ -839,7 +850,6 @@ parse_opt_image(char ch, char *arg)
 {
 	char buf[MAX_ARG_LEN];
 	char *argv[MAX_ARG_COUNT];
-	int argc;
 	char *p;
 	struct image_desc *desc = NULL;
 	int i;
@@ -864,7 +874,7 @@ parse_opt_image(char ch, char *arg)
 	if (!desc)
 		return ERR_FATAL;
 
-	argc = parse_arg(arg, buf, argv);
+	parse_arg(arg, buf, argv);
 
 	i = 0;
 	p = argv[i++];
@@ -886,9 +896,6 @@ parse_opt_image(char ch, char *arg)
 int
 process_images(void)
 {
-	struct image_desc *desc;
-	uint32_t offs = 0;
-	int i;
 	int res;
 
 	kernel_image.out_size = board->max_kernel_size;
diff --git a/tools/firmware-utils/src/mkcsysimg.c b/tools/firmware-utils/src/mkcsysimg.c
index 77fbbaa57f..0ddb54c4ec 100644
--- a/tools/firmware-utils/src/mkcsysimg.c
+++ b/tools/firmware-utils/src/mkcsysimg.c
@@ -423,8 +423,9 @@ csum8_get(struct csum_state *css)
 
 
 void
-csum16_update(uint8_t *p, uint32_t len, struct csum_state *css)
+csum16_update(void *data, uint32_t len, struct csum_state *css)
 {
+	uint8_t *p = data;
 	uint16_t t;
 
 	if (css->odd) {
@@ -468,8 +469,10 @@ csum_init(struct csum_state *css, int size)
 
 
 void
-csum_update(uint8_t *p, uint32_t len, struct csum_state *css)
+csum_update(void *data, uint32_t len, struct csum_state *css)
 {
+	uint8_t *p = data;
+
 	switch (css->size) {
 	case CSUM_SIZE_8:
 		csum8_update(p,len,css);
@@ -493,6 +496,9 @@ csum_get(struct csum_state *css)
 	case CSUM_SIZE_16:
 		ret = csum16_get(css);
 		break;
+	default:
+		ERR("invalid checksum size\n");
+		return 0;
 	}
 
 	return ret;
@@ -503,19 +509,21 @@ csum_get(struct csum_state *css)
  * routines to write data to the output file
  */
 int
-write_out_data(FILE *outfile, uint8_t *data, size_t len,
+write_out_data(FILE *outfile, void *data, size_t len,
 		struct csum_state *css)
 {
+	uint8_t *ptr = data;
+
 	errno = 0;
 
-	fwrite(data, len, 1, outfile);
+	fwrite(ptr, len, 1, outfile);
 	if (errno) {
 		ERRS("unable to write output file");
 		return ERR_FATAL;
 	}
 
 	if (css) {
-		csum_update(data, len, css);
+		csum_update(ptr, len, css);
 	}
 
 	return 0;
@@ -792,7 +800,6 @@ parse_opt_block(char ch, char *arg)
 {
 	char buf[MAX_ARG_LEN];
 	char *argv[MAX_ARG_COUNT];
-	int argc;
 	char *p;
 	struct csys_block *block;
 	int i;
@@ -854,7 +861,7 @@ parse_opt_block(char ch, char *arg)
 		return ERR_FATAL;
 	}
 
-	argc = parse_arg(arg, buf, argv);
+	parse_arg(arg, buf, argv);
 
 	i = 0;
 	p = argv[i++];
diff --git a/tools/firmware-utils/src/mkdapimg.c b/tools/firmware-utils/src/mkdapimg.c
index 640f42d7c6..0031d83dd0 100644
--- a/tools/firmware-utils/src/mkdapimg.c
+++ b/tools/firmware-utils/src/mkdapimg.c
@@ -68,7 +68,8 @@ main(int ac, char *av[])
 	int fixmode = 0;
 	int have_regionversion = 0;
 
-	FILE *ifile, *ofile;
+	FILE *ifile = NULL;
+	FILE *ofile = NULL;
 	int c;
 	uint32_t cksum;
 	uint32_t bcnt;
diff --git a/tools/firmware-utils/src/mkdapimg2.c b/tools/firmware-utils/src/mkdapimg2.c
index 6b53c959b6..1d09290a16 100644
--- a/tools/firmware-utils/src/mkdapimg2.c
+++ b/tools/firmware-utils/src/mkdapimg2.c
@@ -92,7 +92,8 @@ main(int ac, char *av[])
 	char region[MAX_REG_LEN];
 	int kernel = 0;
 
-	FILE *ifile, *ofile;
+	FILE *ifile = NULL;
+	FILE *ofile = NULL;
 	int c;
 
 	uint32_t cksum;
diff --git a/tools/firmware-utils/src/mkdniimg.c b/tools/firmware-utils/src/mkdniimg.c
index 852b07dd9f..92315f9849 100644
--- a/tools/firmware-utils/src/mkdniimg.c
+++ b/tools/firmware-utils/src/mkdniimg.c
@@ -50,7 +50,6 @@ static char *board_id;
 void usage(int status)
 {
 	FILE *stream = (status != EXIT_SUCCESS) ? stderr : stdout;
-	struct board_info *board;
 
 	fprintf(stream, "Usage: %s [OPTIONS...]\n", progname);
 	fprintf(stream,
@@ -188,7 +187,6 @@ int main(int argc, char *argv[])
 
 	res = EXIT_SUCCESS;
 
- out_flush:
 	fflush(outfile);
 
  err_close_out:
diff --git a/tools/firmware-utils/src/mkfwimage2.c b/tools/firmware-utils/src/mkfwimage2.c
index 9b7e1a3cd7..9d8b2f6f8b 100644
--- a/tools/firmware-utils/src/mkfwimage2.c
+++ b/tools/firmware-utils/src/mkfwimage2.c
@@ -65,7 +65,6 @@ typedef struct image_info {
 } image_info_t;
 
 static image_info_t im;
-static int debug = 0;
 static int zero_part_baseaddr = 0;
 
 static void write_header(void* mem, const char* version)
diff --git a/tools/firmware-utils/src/mkmylofw.c b/tools/firmware-utils/src/mkmylofw.c
index b5958ebe0f..93eab202d9 100644
--- a/tools/firmware-utils/src/mkmylofw.c
+++ b/tools/firmware-utils/src/mkmylofw.c
@@ -98,7 +98,7 @@ struct cpx_board {
 #define CPX_BOARD_AR23XX(_did, _flash, _mod, _name, _desc) \
 	CPX_BOARD(_did, _flash, _mod, _name, _desc, 0x10000, 0x10000)
 
-#define ALIGN(x,y)	((x)+((y)-1)) & ~((y)-1)
+#define ALIGN(x,y)	(((x)+((y)-1)) & ~((y)-1))
 
 char	*progname;
 char	*ofname = NULL;
@@ -478,18 +478,20 @@ process_partitions(void)
  * routines to write data to the output file
  */
 int
-write_out_data(FILE *outfile, uint8_t *data, size_t len, uint32_t *crc)
+write_out_data(FILE *outfile, void *data, size_t len, uint32_t *crc)
 {
+	uint8_t *ptr = data;
+
 	errno = 0;
 
-	fwrite(data, len, 1, outfile);
+	fwrite(ptr, len, 1, outfile);
 	if (errno) {
 		errmsg(1,"unable to write output file");
 		return -1;
 	}
 
 	if (crc) {
-		update_crc(data, len, crc);
+		update_crc(ptr, len, crc);
 	}
 
 	return 0;
@@ -581,7 +583,7 @@ write_out_file(FILE *outfile, struct fw_block *block, uint32_t *crc)
 	fclose(f);
 
 	/* align next block on a 4 byte boundary */
-	len = ALIGN(len,4) - block->size;
+	len = block->size % 4;
 	if (write_out_padding(outfile, len, 0xFF, crc))
 		return -1;
 
@@ -848,14 +850,13 @@ parse_opt_id(char ch, char *arg)
 {
 	char buf[MAX_ARG_LEN];
 	char *argv[MAX_ARG_COUNT];
-	int argc;
 	char *p;
 
 	if (required_arg(ch, arg)) {
 		goto err_out;
 	}
 
-	argc = parse_arg(arg, buf, argv);
+	parse_arg(arg, buf, argv);
 
 	/* processing vendor ID*/
 	p = argv[0];
@@ -1011,7 +1012,6 @@ parse_opt_partition(char ch, char *arg)
 {
 	char buf[MAX_ARG_LEN];
 	char *argv[MAX_ARG_COUNT];
-	int argc;
 	char *p;
 	struct mylo_partition *part;
 	struct fw_part *fp;
@@ -1028,7 +1028,7 @@ parse_opt_partition(char ch, char *arg)
 	fp = &fw_parts[fw_num_partitions++];
 	part = &fp->mylo;
 
-	argc = parse_arg(arg, buf, argv);
+	parse_arg(arg, buf, argv);
 
 	/* processing partition address */
 	p = argv[0];
diff --git a/tools/firmware-utils/src/mkplanexfw.c b/tools/firmware-utils/src/mkplanexfw.c
index 0b71f80438..0230fe2252 100644
--- a/tools/firmware-utils/src/mkplanexfw.c
+++ b/tools/firmware-utils/src/mkplanexfw.c
@@ -105,7 +105,6 @@ static struct board_info *find_board(char *id)
 void usage(int status)
 {
 	FILE *stream = (status != EXIT_SUCCESS) ? stderr : stdout;
-	struct board_info *board;
 
 	fprintf(stream, "Usage: %s [OPTIONS...]\n", progname);
 	fprintf(stream,
@@ -248,7 +247,6 @@ int main(int argc, char *argv[])
 
 	res = EXIT_SUCCESS;
 
- out_flush:
 	fflush(outfile);
 
  err_close_out:
diff --git a/tools/firmware-utils/src/mkrtn56uimg.c b/tools/firmware-utils/src/mkrtn56uimg.c
index 92aaf314a1..689dc8b375 100644
--- a/tools/firmware-utils/src/mkrtn56uimg.c
+++ b/tools/firmware-utils/src/mkrtn56uimg.c
@@ -67,7 +67,7 @@ typedef struct image_header {
 	uint8_t		ih_type;
 	uint8_t		ih_comp;
 	union {
-		uint8_t	ih_name[IH_NMLEN];
+		char	ih_name[IH_NMLEN];
 		asus_t	asus;
 	} tail;
 } image_header_t;
@@ -102,7 +102,6 @@ static void
 usage(const char *progname, int status)
 {
 	FILE *stream = (status != EXIT_SUCCESS) ? stderr : stdout;
-	int i;
 
 	fprintf(stream, "Usage: %s [OPTIONS...]\n", progname);
 	fprintf(stream, "\n"
@@ -116,12 +115,12 @@ usage(const char *progname, int status)
 int
 process_image(char *progname, char *filename, op_mode_t opmode)
 {
-	int 		fd, len;
-	void 		*data, *ptr;
+	int 		fd;
+	void 		*ptr;
 	char		namebuf[IH_NMLEN];
 	struct 		stat sbuf;
-	uint32_t	checksum, offset_kernel, offset_sqfs, offset_end,
-				offset_sec_header, offset_eb, offset_image_end;
+	uint32_t	offset_kernel, offset_sqfs, offset_end,
+			offset_sec_header, offset_eb, offset_image_end;
 	squashfs_sb_t *sqs;
 	image_header_t *hdr;
 
@@ -252,7 +251,8 @@ int
 main(int argc, char **argv)
 {
 	int 		opt;
-	char 		*filename, *progname;
+	char 		*filename = NULL;
+	char		*progname;
 	op_mode_t	opmode = NONE;
 
 	progname = argv[0];
diff --git a/tools/firmware-utils/src/mktitanimg.c b/tools/firmware-utils/src/mktitanimg.c
index 120d08f0c4..acc21bd64d 100644
--- a/tools/firmware-utils/src/mktitanimg.c
+++ b/tools/firmware-utils/src/mktitanimg.c
@@ -40,7 +40,6 @@ void print_help(void)
 void mknspimg_print_hdr(struct nsp_img_hdr *hdr)
 {
 	struct nsp_img_hdr_chksum	*chksum;
-	struct nsp_img_hdr_section_info	*sect_info;
 	struct nsp_img_hdr_sections	*section;
 	int i;
 
@@ -118,14 +117,11 @@ int main(int argc, char* argv[], char* env[])
 	int	cmdline_err;
 	char*	cmdline_error_msg;
 
-	char*	filen_kernel;
-	char*	filen_files;
 	char*	filen_out;
 
 	int	i,count;			/* loop variables */
 	int	num_sects = 2;			/* We require exactly two image with -i option
 							   (see CMDLINE_CFG structure above) */
-	int	desc_count=0;
 	int	total = 0;
 
 	int	header_size=0;
@@ -158,8 +154,6 @@ int main(int argc, char* argv[], char* env[])
 		header_version=atoi(argv[cmdline_getarg(cmdline_getarg_list('h'),0)]);
 	}
 	/* Set up arguments */
-	filen_kernel	= argv[cmdline_getarg(cmdline_getarg_list('i'),0)];
-	filen_files	= argv[cmdline_getarg(cmdline_getarg_list('i'),1)];
 	filen_out	= argv[cmdline_getarg(cmdline_getarg_list('o'),0)];
 	/* Command line arguments have been parsed. Start doing our work. */
 
@@ -290,7 +284,7 @@ int main(int argc, char* argv[], char* env[])
 			else
 				padding = align - ((section->raw_size+ section->offset) % align);
 
-				section->total_size=section->raw_size + padding;
+			section->total_size=section->raw_size + padding;
 		}
 		else{
 			#define EXTRA_BLOCK 0x10000
diff --git a/tools/firmware-utils/src/mktplinkfw2.c b/tools/firmware-utils/src/mktplinkfw2.c
index e1c28e6347..053ff0050b 100644
--- a/tools/firmware-utils/src/mktplinkfw2.c
+++ b/tools/firmware-utils/src/mktplinkfw2.c
@@ -184,7 +184,6 @@ static struct flash_layout layouts[] = {
 static void usage(int status)
 {
 	FILE *stream = (status != EXIT_SUCCESS) ? stderr : stdout;
-	struct board_info *board;
 
 	fprintf(stream, "Usage: %s [OPTIONS...]\n", progname);
 	fprintf(stream,
diff --git a/tools/firmware-utils/src/mkwrggimg.c b/tools/firmware-utils/src/mkwrggimg.c
index 9995b9a13d..d2c42b02b3 100644
--- a/tools/firmware-utils/src/mkwrggimg.c
+++ b/tools/firmware-utils/src/mkwrggimg.c
@@ -114,7 +114,7 @@ static void get_digest(struct wrgg03_header *header, char *data, int size)
 	MD5_Update(&ctx, (char *)&header->devname, sizeof(header->devname));
 	MD5_Update(&ctx, data, size);
 
-	MD5_Final(header->digest, &ctx);
+	MD5_Final((unsigned char *)header->digest, &ctx);
 }
 
 int main(int argc, char *argv[])
diff --git a/tools/firmware-utils/src/mkwrgimg.c b/tools/firmware-utils/src/mkwrgimg.c
index 3915d146cf..6ba2fd1577 100644
--- a/tools/firmware-utils/src/mkwrgimg.c
+++ b/tools/firmware-utils/src/mkwrgimg.c
@@ -100,7 +100,7 @@ static void get_digest(struct wrg_header *header, char *data, int size)
 	MD5_Update(&ctx, (char *)&header->devname, sizeof(header->devname));
 	MD5_Update(&ctx, data, size);
 
-	MD5_Final(header->digest, &ctx);
+	MD5_Final((unsigned char *)header->digest, &ctx);
 }
 
 int main(int argc, char *argv[])
diff --git a/tools/firmware-utils/src/mkzcfw.c b/tools/firmware-utils/src/mkzcfw.c
index 2326f1ff5c..e21504e266 100644
--- a/tools/firmware-utils/src/mkzcfw.c
+++ b/tools/firmware-utils/src/mkzcfw.c
@@ -127,7 +127,6 @@ static struct board_info *find_board(char *id)
 static void usage(int status)
 {
 	FILE *stream = (status != EXIT_SUCCESS) ? stderr : stdout;
-	struct board_info *board;
 
 	fprintf(stream, "Usage: %s [OPTIONS...]\n", progname);
 	fprintf(stream,
@@ -276,8 +275,6 @@ static int build_fw(void)
 	char *buf;
 	char *p;
 	int ret = EXIT_FAILURE;
-	int writelen = 0;
-	uint32_t crc;
 	struct fw_header *hdr;
 	struct fw_tail *tail;
 
@@ -361,11 +358,6 @@ static int build_fw(void)
 int main(int argc, char *argv[])
 {
 	int ret = EXIT_FAILURE;
-	int err;
-
-	FILE *outfile;
-
-	progname = basename(argv[0]);
 
 	while ( 1 ) {
 		int c;
diff --git a/tools/firmware-utils/src/mkzynfw.c b/tools/firmware-utils/src/mkzynfw.c
index ccbabfe7f2..365264ca68 100644
--- a/tools/firmware-utils/src/mkzynfw.c
+++ b/tools/firmware-utils/src/mkzynfw.c
@@ -444,8 +444,10 @@ csum_init(struct csum_state *css)
 
 
 void
-csum_update(uint8_t *p, uint32_t len, struct csum_state *css)
+csum_update(void *data, uint32_t len, struct csum_state *css)
 {
+	uint8_t *p = data;
+
 	if (len == 0)
 		return;
 
@@ -499,19 +501,21 @@ csum_buf(uint8_t *p, uint32_t len)
  * routines to write data to the output file
  */
 int
-write_out_data(FILE *outfile, uint8_t *data, size_t len,
+write_out_data(FILE *outfile, void *data, size_t len,
 		struct csum_state *css)
 {
+	uint8_t *ptr = data;
+
 	errno = 0;
 
-	fwrite(data, len, 1, outfile);
+	fwrite(ptr, len, 1, outfile);
 	if (errno) {
 		ERR("unable to write output file");
 		return -1;
 	}
 
 	if (css) {
-		csum_update(data, len, css);
+		csum_update(ptr, len, css);
 	}
 
 	return 0;
@@ -541,7 +545,7 @@ write_out_padding(FILE *outfile, size_t len, uint8_t padc,
 
 
 int
-write_out_data_align(FILE *outfile, uint8_t *data, size_t len, size_t align,
+write_out_data_align(FILE *outfile, void *data, size_t len, size_t align,
 		struct csum_state *css)
 {
 	size_t padlen;
@@ -611,7 +615,7 @@ write_out_mmap(FILE *outfile, struct fw_mmap *mmap, struct csum_state *css)
 	mh->count=0;
 
 	/* Build user data section */
-	data = buf+sizeof(*mh);
+	data = (char *)buf + sizeof(*mh);
 	data += sprintf(data, "Vendor 1 %d", board->vendor);
 	*data++ = '\0';
 	data += sprintf(data, "Model 1 %d", BE16_TO_HOST(board->model));
@@ -922,7 +926,6 @@ parse_opt_block(char ch, char *arg)
 {
 	char buf[MAX_ARG_LEN];
 	char *argv[MAX_ARG_COUNT];
-	int argc;
 	char *p;
 	struct fw_block *block;
 	int i;
@@ -951,7 +954,7 @@ parse_opt_block(char ch, char *arg)
 		break;
 	}
 
-	argc = parse_arg(arg, buf, argv);
+	parse_arg(arg, buf, argv);
 
 	i = 0;
 	p = argv[i++];
diff --git a/tools/firmware-utils/src/osbridge-crc.c b/tools/firmware-utils/src/osbridge-crc.c
index 5fd236a074..46ea855ec1 100644
--- a/tools/firmware-utils/src/osbridge-crc.c
+++ b/tools/firmware-utils/src/osbridge-crc.c
@@ -58,7 +58,6 @@ static char *ofname;
 void usage(int status)
 {
 	FILE *stream = (status != EXIT_SUCCESS) ? stderr : stdout;
-	struct board_info *board;
 
 	fprintf(stream, "Usage: %s [OPTIONS...]\n", progname);
 	fprintf(stream,
@@ -164,7 +163,6 @@ int main(int argc, char *argv[])
 
 	res = EXIT_SUCCESS;
 
- out_flush:
 	fflush(outfile);
 
  err_close_out:
diff --git a/tools/firmware-utils/src/otrx.c b/tools/firmware-utils/src/otrx.c
index 223e032f2b..3bbbac39e3 100644
--- a/tools/firmware-utils/src/otrx.c
+++ b/tools/firmware-utils/src/otrx.c
@@ -287,7 +287,6 @@ static int otrx_create_write_hdr(FILE *trx, struct trx_header *hdr) {
 	uint8_t buf[1024];
 	uint32_t crc32;
 
-	hdr->magic = cpu_to_le32(TRX_MAGIC);
 	hdr->version = 1;
 
 	fseek(trx, 0, SEEK_SET);
@@ -324,9 +323,13 @@ static int otrx_create(int argc, char **argv) {
 	ssize_t sbytes;
 	size_t curr_idx = 0;
 	size_t curr_offset = sizeof(hdr);
+	char *e;
+	uint32_t magic;
 	int c;
 	int err = 0;
 
+	hdr.magic = cpu_to_le32(TRX_MAGIC);
+
 	if (argc < 3) {
 		fprintf(stderr, "No TRX file passed\n");
 		err = -EINVAL;
@@ -343,7 +346,7 @@ static int otrx_create(int argc, char **argv) {
 	fseek(trx, curr_offset, SEEK_SET);
 
 	optind = 3;
-	while ((c = getopt(argc, argv, "f:A:a:b:")) != -1) {
+	while ((c = getopt(argc, argv, "f:A:a:b:M:")) != -1) {
 		switch (c) {
 		case 'f':
 			if (curr_idx >= TRX_MAX_PARTS) {
@@ -400,6 +403,14 @@ static int otrx_create(int argc, char **argv) {
 					curr_offset += sbytes;
 			}
 			break;
+		case 'M':
+			errno = 0;
+			magic = strtoul(optarg, &e, 0);
+			if (errno || (e == optarg) || *e)
+				fprintf(stderr, "illegal magic string %s\n", optarg);
+			else
+				hdr.magic = cpu_to_le32(magic);
+			break;
 		}
 		if (err)
 			break;
diff --git a/tools/firmware-utils/src/pc1crypt.c b/tools/firmware-utils/src/pc1crypt.c
index fe41b3dab5..5eb6e01d4a 100644
--- a/tools/firmware-utils/src/pc1crypt.c
+++ b/tools/firmware-utils/src/pc1crypt.c
@@ -215,7 +215,6 @@ static int decrypt;
 void usage(int status)
 {
 	FILE *stream = (status != EXIT_SUCCESS) ? stderr : stdout;
-	struct board_info *board;
 
 	fprintf(stream, "Usage: %s [OPTIONS...]\n", progname);
 	fprintf(stream,
@@ -340,7 +339,6 @@ int main(int argc, char *argv[])
 
 	res = EXIT_SUCCESS;
 
- out_flush:
 	fflush(outfile);
 
  err_close_out:
diff --git a/tools/firmware-utils/src/ptgen.c b/tools/firmware-utils/src/ptgen.c
index 223ee29561..d911b9d1f0 100644
--- a/tools/firmware-utils/src/ptgen.c
+++ b/tools/firmware-utils/src/ptgen.c
@@ -52,6 +52,8 @@
 #define swap(a, b) \
 	do { typeof(a) __tmp = (a); (a) = (b); (b) = __tmp; } while (0)
 
+#define BIT(_x)		(1UL << (_x))
+
 typedef struct {
 	uint8_t b[16];
 } guid_t;
@@ -80,10 +82,23 @@ typedef struct {
 	GUID_INIT( 0x21686148, 0x6449, 0x6E6F, \
 			0x74, 0x4E, 0x65, 0x65, 0x64, 0x45, 0x46, 0x49)
 
+#define GUID_PARTITION_LINUX_FIT_GUID \
+	GUID_INIT( 0xcae9be83, 0xb15f, 0x49cc, \
+			0x86, 0x3f, 0x08, 0x1b, 0x74, 0x4a, 0x2d, 0x93)
+
+#define GUID_PARTITION_LINUX_FS_GUID \
+	GUID_INIT( 0x0fc63daf, 0x8483, 0x4772, \
+			0x8e, 0x79, 0x3d, 0x69, 0xd8, 0x47, 0x7d, 0xe4)
+
 #define GPT_HEADER_SIZE         92
 #define GPT_ENTRY_SIZE          128
 #define GPT_ENTRY_MAX           128
 #define GPT_ENTRY_NAME_SIZE     72
+#define GPT_SIZE		GPT_ENTRY_SIZE * GPT_ENTRY_MAX / DISK_SECTOR_SIZE
+
+#define GPT_ATTR_PLAT_REQUIRED  BIT(0)
+#define GPT_ATTR_EFI_IGNORE     BIT(1)
+#define GPT_ATTR_LEGACY_BOOT    BIT(2)
 
 #define GPT_HEADER_SECTOR       1
 #define GPT_FIRST_ENTRY_SECTOR  2
@@ -106,9 +121,14 @@ struct pte {
 };
 
 struct partinfo {
+	unsigned long actual_start;
 	unsigned long start;
 	unsigned long size;
 	int type;
+	int hybrid;
+	char *name;
+	short int required;
+	guid_t guid;
 };
 
 /* GPT Partition table header */
@@ -352,7 +372,7 @@ fail:
 /* check the partition sizes and write the guid partition table */
 static int gen_gptable(uint32_t signature, guid_t guid, unsigned nr)
 {
-	struct pte pte;
+	struct pte pte[MBR_ENTRY_MAX];
 	struct gpth gpth = {
 		.signature = cpu_to_le64(GPT_SIGNATURE),
 		.revision = cpu_to_le32(GPT_REVISION),
@@ -365,10 +385,12 @@ static int gen_gptable(uint32_t signature, guid_t guid, unsigned nr)
 		.entry_size = cpu_to_le32(GPT_ENTRY_SIZE),
 	};
 	struct gpte  gpte[GPT_ENTRY_MAX];
-	uint64_t start, end, sect = 0;
+	uint64_t start, end;
+	uint64_t sect = GPT_SIZE + GPT_FIRST_ENTRY_SECTOR;
 	int fd, ret = -1;
-	unsigned i;
+	unsigned i, pmbr = 1;
 
+	memset(pte, 0, sizeof(struct pte) * MBR_ENTRY_MAX);
 	memset(gpte, 0, GPT_ENTRY_SIZE * GPT_ENTRY_MAX);
 	for (i = 0; i < nr; i++) {
 		if (!parts[i].size) {
@@ -377,7 +399,7 @@ static int gen_gptable(uint32_t signature, guid_t guid, unsigned nr)
 			fprintf(stderr, "Invalid size in partition %d!\n", i);
 			return ret;
 		}
-		start = sect + sectors;
+		start = sect;
 		if (parts[i].start != 0) {
 			if (parts[i].start * 2 < start) {
 				fprintf(stderr, "Invalid start %ld for partition %d!\n",
@@ -388,21 +410,34 @@ static int gen_gptable(uint32_t signature, guid_t guid, unsigned nr)
 		} else if (kb_align != 0) {
 			start = round_to_kb(start);
 		}
+		parts[i].actual_start = start;
 		gpte[i].start = cpu_to_le64(start);
 
 		sect = start + parts[i].size * 2;
-		if (kb_align == 0)
-			sect = round_to_cyl(sect);
 		gpte[i].end = cpu_to_le64(sect -1);
 		gpte[i].guid = guid;
 		gpte[i].guid.b[sizeof(guid_t) -1] += i + 1;
-		if (parts[i].type == 0xEF || (i + 1) == (unsigned)active) {
-			gpte[i].type = GUID_PARTITION_SYSTEM;
-			init_utf16("EFI System Partition", (uint16_t *)gpte[i].name, GPT_ENTRY_NAME_SIZE / sizeof(uint16_t));
-		} else {
-			gpte[i].type = GUID_PARTITION_BASIC_DATA;
+		gpte[i].type = parts[i].guid;
+
+		if (parts[i].hybrid && pmbr < MBR_ENTRY_MAX) {
+			pte[pmbr].active = ((i + 1) == active) ? 0x80 : 0;
+			pte[pmbr].type = parts[i].type;
+			pte[pmbr].start = cpu_to_le32(start);
+			pte[pmbr].length = cpu_to_le32(sect - start);
+			to_chs(start, pte[1].chs_start);
+			to_chs(sect - 1, pte[1].chs_end);
+			pmbr++;
 		}
 
+		if (parts[i].name)
+			init_utf16(parts[i].name, (uint16_t *)gpte[i].name, GPT_ENTRY_NAME_SIZE / sizeof(uint16_t));
+
+		if ((i + 1) == (unsigned)active)
+			gpte[i].attr |= GPT_ATTR_LEGACY_BOOT;
+
+		if (parts[i].required)
+			gpte[i].attr |= GPT_ATTR_PLAT_REQUIRED;
+
 		if (verbose)
 			fprintf(stderr, "Partition %d: start=%" PRIu64 ", end=%" PRIu64 ", size=%"  PRIu64 "\n",
 					i,
@@ -412,21 +447,23 @@ static int gen_gptable(uint32_t signature, guid_t guid, unsigned nr)
 		printf("%" PRIu64 "\n", (sect - start) * DISK_SECTOR_SIZE);
 	}
 
-	gpte[GPT_ENTRY_MAX - 1].start = cpu_to_le64(GPT_FIRST_ENTRY_SECTOR + GPT_ENTRY_SIZE * GPT_ENTRY_MAX / DISK_SECTOR_SIZE);
-	gpte[GPT_ENTRY_MAX - 1].end = cpu_to_le64((kb_align ? round_to_kb(sectors) : (unsigned long)sectors) - 1);
-	gpte[GPT_ENTRY_MAX - 1].type = GUID_PARTITION_BIOS_BOOT;
-	gpte[GPT_ENTRY_MAX - 1].guid = guid;
-	gpte[GPT_ENTRY_MAX - 1].guid.b[sizeof(guid_t) -1] += GPT_ENTRY_MAX;
+	if (parts[0].actual_start > GPT_FIRST_ENTRY_SECTOR + GPT_SIZE) {
+		gpte[GPT_ENTRY_MAX - 1].start = cpu_to_le64(GPT_FIRST_ENTRY_SECTOR + GPT_SIZE);
+		gpte[GPT_ENTRY_MAX - 1].end = cpu_to_le64(parts[0].actual_start - 1);
+		gpte[GPT_ENTRY_MAX - 1].type = GUID_PARTITION_BIOS_BOOT;
+		gpte[GPT_ENTRY_MAX - 1].guid = guid;
+		gpte[GPT_ENTRY_MAX - 1].guid.b[sizeof(guid_t) -1] += GPT_ENTRY_MAX;
+	}
 
-	end = sect + sectors - 1;
+	end = sect + GPT_SIZE;
 
-	pte.type = 0xEE;
-	pte.start = cpu_to_le32(GPT_HEADER_SECTOR);
-	pte.length = cpu_to_le32(end);
-	to_chs(GPT_HEADER_SECTOR, pte.chs_start);
-	to_chs(end, pte.chs_end);
+	pte[0].type = 0xEE;
+	pte[0].start = cpu_to_le32(GPT_HEADER_SECTOR);
+	pte[0].length = cpu_to_le32(end - GPT_HEADER_SECTOR);
+	to_chs(GPT_HEADER_SECTOR, pte[0].chs_start);
+	to_chs(end, pte[0].chs_end);
 
-	gpth.last_usable = cpu_to_le64(end - GPT_ENTRY_SIZE * GPT_ENTRY_MAX / DISK_SECTOR_SIZE - 1);
+	gpth.last_usable = cpu_to_le64(end - GPT_SIZE - 1);
 	gpth.alternate = cpu_to_le64(end);
 	gpth.entry_crc32 = cpu_to_le32(gpt_crc32(gpte, GPT_ENTRY_SIZE * GPT_ENTRY_MAX));
 	gpth.crc32 = cpu_to_le32(gpt_crc32((char *)&gpth, GPT_HEADER_SIZE));
@@ -443,7 +480,7 @@ static int gen_gptable(uint32_t signature, guid_t guid, unsigned nr)
 	}
 
 	lseek(fd, MBR_PARTITION_ENTRY_OFFSET, SEEK_SET);
-	if (write(fd, &pte, sizeof(struct pte)) != sizeof(struct pte)) {
+	if (write(fd, pte, sizeof(struct pte) * MBR_ENTRY_MAX) != sizeof(struct pte) * MBR_ENTRY_MAX) {
 		fputs("write failed.\n", stderr);
 		goto fail;
 	}
@@ -498,21 +535,45 @@ fail:
 
 static void usage(char *prog)
 {
-	fprintf(stderr, "Usage: %s [-v] [-n] [-g] -h <heads> -s <sectors> -o <outputfile> [-a 0..4] [-l <align kB>] [-G <guid>] [[-t <type>] -p <size>[@<start>]...] \n", prog);
+	fprintf(stderr, "Usage: %s [-v] [-n] [-g] -h <heads> -s <sectors> -o <outputfile> [-a 0..4] [-l <align kB>] [-G <guid>] [[-t <type>] [-r] [-N <name>] -p <size>[@<start>]...] \n", prog);
 	exit(EXIT_FAILURE);
 }
 
+static guid_t type_to_guid_and_name(unsigned char type, char **name)
+{
+	guid_t guid = GUID_PARTITION_BASIC_DATA;
+
+	switch (type) {
+		case 0xef:
+			if(*name == NULL)
+				*name = "EFI System Partition";
+			guid = GUID_PARTITION_SYSTEM;
+			break;
+		case 0x83:
+			guid = GUID_PARTITION_LINUX_FS_GUID;
+			break;
+		case 0x2e:
+			guid = GUID_PARTITION_LINUX_FIT_GUID;
+			break;
+	}
+
+	return guid;
+}
+
 int main (int argc, char **argv)
 {
 	unsigned char type = 0x83;
 	char *p;
 	int ch;
 	int part = 0;
+	char *name = NULL;
+	unsigned short int hybrid = 0, required = 0;
 	uint32_t signature = 0x5452574F; /* 'OWRT' */
 	guid_t guid = GUID_INIT( signature, 0x2211, 0x4433, \
 			0x55, 0x66, 0x77, 0x88, 0x99, 0xAA, 0xBB, 0x00);
+	guid_t part_guid = GUID_PARTITION_BASIC_DATA;
 
-	while ((ch = getopt(argc, argv, "h:s:p:a:t:o:vngl:S:G:")) != -1) {
+	while ((ch = getopt(argc, argv, "h:s:p:a:t:o:vnHN:gl:rS:G:")) != -1) {
 		switch (ch) {
 		case 'o':
 			filename = optarg;
@@ -526,6 +587,9 @@ int main (int argc, char **argv)
 		case 'g':
 			use_guid_partition_table = 1;
 			break;
+		case 'H':
+			hybrid = 1;
+			break;
 		case 'h':
 			heads = (int)strtoul(optarg, NULL, 0);
 			break;
@@ -542,9 +606,27 @@ int main (int argc, char **argv)
 				*(p++) = 0;
 				parts[part].start = to_kbytes(p);
 			}
+			part_guid = type_to_guid_and_name(type, &name);
 			parts[part].size = to_kbytes(optarg);
+			parts[part].required = required;
+			parts[part].name = name;
+			parts[part].hybrid = hybrid;
+			parts[part].guid = part_guid;
 			fprintf(stderr, "part %ld %ld\n", parts[part].start, parts[part].size);
 			parts[part++].type = type;
+			/*
+			 * reset 'name','required' and 'hybrid'
+			 * 'type' is deliberately inherited from the previous delcaration
+			 */
+			name = NULL;
+			required = 0;
+			hybrid = 0;
+			break;
+		case 'N':
+			name = optarg;
+			break;
+		case 'r':
+			required = 1;
 			break;
 		case 't':
 			type = (char)strtoul(optarg, NULL, 16);
@@ -572,11 +654,14 @@ int main (int argc, char **argv)
 		}
 	}
 	argc -= optind;
-	if (argc || (heads <= 0) || (sectors <= 0) || !filename)
+	if (argc || (!use_guid_partition_table && ((heads <= 0) || (sectors <= 0))) || !filename)
 		usage(argv[0]);
 
-	if (use_guid_partition_table)
+	if (use_guid_partition_table) {
+		heads = 254;
+		sectors = 63;
 		return gen_gptable(signature, guid, part) ? EXIT_FAILURE : EXIT_SUCCESS;
+	}
 
 	return gen_ptable(signature, part) ? EXIT_FAILURE : EXIT_SUCCESS;
 }
diff --git a/tools/firmware-utils/src/sha1.c b/tools/firmware-utils/src/sha1.c
index 3ab1332992..40cc78ca08 100644
--- a/tools/firmware-utils/src/sha1.c
+++ b/tools/firmware-utils/src/sha1.c
@@ -225,8 +225,9 @@ void sha1_process( sha1_context *ctx, uchar data[64] )
     ctx->state[4] += E;
 }
 
-void sha1_update( sha1_context *ctx, uchar *input, uint length )
+void sha1_update( sha1_context *ctx, void *data, uint length )
 {
+    uchar *input = data;
     ulong left, fill;
 
     if( ! length ) return;
diff --git a/tools/firmware-utils/src/sha1.h b/tools/firmware-utils/src/sha1.h
index 425267a306..990a52765c 100644
--- a/tools/firmware-utils/src/sha1.h
+++ b/tools/firmware-utils/src/sha1.h
@@ -26,7 +26,7 @@ sha1_context;
  * Core SHA-1 functions
  */
 void sha1_starts( sha1_context *ctx );
-void sha1_update( sha1_context *ctx, uchar *input, uint length );
+void sha1_update( sha1_context *ctx, void *input, uint length );
 void sha1_finish( sha1_context *ctx, uchar digest[20] );
 
 /*
diff --git a/tools/firmware-utils/src/spw303v.c b/tools/firmware-utils/src/spw303v.c
index 684532d7e1..980f41ded6 100644
--- a/tools/firmware-utils/src/spw303v.c
+++ b/tools/firmware-utils/src/spw303v.c
@@ -117,10 +117,12 @@ static char fake_data[] = {
 };
 
 
-uint32_t crc32(uint32_t crc, uint8_t *data, size_t len)
+uint32_t crc32(uint32_t crc, const void *data, size_t len)
 {
+	const uint8_t *in = data;
+
 	while (len--)
-		crc = (crc >> 8) ^ crc32tab[(crc ^ *data++) & 0xFF];
+		crc = (crc >> 8) ^ crc32tab[(crc ^ *in++) & 0xFF];
 
 	return crc;
 }
@@ -167,7 +169,6 @@ int main(int argc, char **argv)
 	char *ifn = NULL;
 	char *ofn = NULL;
 	int c;
-	int v0, v1, v2;
 	size_t n;
 	int first_block = 1;
 
diff --git a/tools/firmware-utils/src/srec2bin.c b/tools/firmware-utils/src/srec2bin.c
index 5cc71bda22..95a8195d1a 100644
--- a/tools/firmware-utils/src/srec2bin.c
+++ b/tools/firmware-utils/src/srec2bin.c
@@ -433,9 +433,8 @@ int srecLine(char *pSrecLine)
 
 int srec2bin(int argc,char *argv[],int verbose)
 {
-    int i,rlen,sts;
+    int rlen,sts;
     FILE *fp;
-    char ac;
     char buff[256];
     bit32u TAG_BIG     = 0xDEADBE42;
     bit32u TAG_LITTLE  = 0xFEEDFA42;
diff --git a/tools/firmware-utils/src/tplink-safeloader.c b/tools/firmware-utils/src/tplink-safeloader.c
index 3a7d8d912e..b3d5c9151d 100644
--- a/tools/firmware-utils/src/tplink-safeloader.c
+++ b/tools/firmware-utils/src/tplink-safeloader.c
@@ -33,8 +33,10 @@
 
 
 #include <assert.h>
+#include <ctype.h>
 #include <errno.h>
 #include <stdbool.h>
+#include <stddef.h>
 #include <stdio.h>
 #include <stdint.h>
 #include <stdlib.h>
@@ -154,7 +156,8 @@ static struct device_info boards[] = {
 			{"default-mac", 0x30000, 0x00020},
 			{"product-info", 0x31100, 0x00100},
 			{"signature", 0x32000, 0x00400},
-			{"firmware", 0x40000, 0x770000},
+			{"os-image", 0x40000, 0x300000},
+			{"file-system", 0x340000, 0x470000},
 			{"soft-version", 0x7b0000, 0x00100},
 			{"support-list", 0x7b1000, 0x00400},
 			{"user-config", 0x7c0000, 0x10000},
@@ -276,7 +279,8 @@ static struct device_info boards[] = {
 			{"default-mac", 0x30000, 0x00020},
 			{"product-info", 0x31100, 0x00100},
 			{"signature", 0x32000, 0x00400},
-			{"firmware", 0x40000, 0x770000},
+			{"os-image", 0x40000, 0x300000},
+			{"file-system", 0x340000, 0x470000},
 			{"soft-version", 0x7b0000, 0x00100},
 			{"support-list", 0x7b1000, 0x00400},
 			{"user-config", 0x7c0000, 0x10000},
@@ -354,7 +358,8 @@ static struct device_info boards[] = {
 			{"default-mac", 0x30000, 0x00020},
 			{"product-info", 0x31100, 0x00100},
 			{"signature", 0x32000, 0x00400},
-			{"firmware", 0x40000, 0x770000},
+			{"os-image", 0x40000, 0x300000},
+			{"file-system", 0x340000, 0x470000},
 			{"soft-version", 0x7b0000, 0x00100},
 			{"support-list", 0x7b1000, 0x00400},
 			{"user-config", 0x7c0000, 0x10000},
@@ -395,7 +400,8 @@ static struct device_info boards[] = {
 			{"default-mac", 0x30000, 0x00020},
 			{"product-info", 0x31100, 0x00100},
 			{"signature", 0x32000, 0x00400},
-			{"firmware", 0x40000, 0x770000},
+			{"os-image", 0x40000, 0x300000},
+			{"file-system", 0x340000, 0x470000},
 			{"soft-version", 0x7b0000, 0x00100},
 			{"support-list", 0x7b1000, 0x00400},
 			{"user-config", 0x7c0000, 0x10000},
@@ -439,7 +445,8 @@ static struct device_info boards[] = {
 			{"default-mac", 0x30000, 0x00020},
 			{"product-info", 0x31100, 0x00100},
 			{"signature", 0x32000, 0x00400},
-			{"firmware", 0x40000, 0x770000},
+			{"os-image", 0x40000, 0x300000},
+			{"file-system", 0x340000, 0x470000},
 			{"soft-version", 0x7b0000, 0x00100},
 			{"support-list", 0x7b1000, 0x00400},
 			{"user-config", 0x7c0000, 0x10000},
@@ -478,7 +485,8 @@ static struct device_info boards[] = {
 			{"default-mac", 0x30000, 0x00020},
 			{"product-info", 0x31100, 0x00100},
 			{"signature", 0x32000, 0x00400},
-			{"firmware", 0x40000, 0x770000},
+			{"os-image", 0x40000, 0x300000},
+			{"file-system", 0x340000, 0x470000},
 			{"soft-version", 0x7b0000, 0x00100},
 			{"support-list", 0x7b1000, 0x00400},
 			{"user-config", 0x7c0000, 0x10000},
@@ -517,7 +525,8 @@ static struct device_info boards[] = {
 			{"default-mac", 0x30000, 0x00020},
 			{"product-info", 0x31100, 0x00100},
 			{"signature", 0x32000, 0x00400},
-			{"firmware", 0x40000, 0x770000},
+			{"os-image", 0x40000, 0x300000},
+			{"file-system", 0x340000, 0x470000},
 			{"soft-version", 0x7b0000, 0x00100},
 			{"support-list", 0x7b1000, 0x00400},
 			{"user-config", 0x7c0000, 0x10000},
@@ -548,7 +557,8 @@ static struct device_info boards[] = {
 			{"default-mac", 0x30000, 0x00020},
 			{"product-info", 0x31100, 0x00100},
 			{"signature", 0x32000, 0x00400},
-			{"firmware", 0x40000, 0x770000},
+			{"os-image", 0x40000, 0x300000},
+			{"file-system", 0x340000, 0x470000},
 			{"soft-version", 0x7b0000, 0x00100},
 			{"support-list", 0x7b1000, 0x00400},
 			{"user-config", 0x7c0000, 0x10000},
@@ -579,7 +589,8 @@ static struct device_info boards[] = {
 			{"default-mac", 0x30000, 0x00020},
 			{"product-info", 0x31100, 0x00100},
 			{"signature", 0x32000, 0x00400},
-			{"firmware", 0x40000, 0x770000},
+			{"os-image", 0x40000, 0x300000},
+			{"file-system", 0x340000, 0x470000},
 			{"soft-version", 0x7b0000, 0x00100},
 			{"support-list", 0x7b1000, 0x00400},
 			{"user-config", 0x7c0000, 0x10000},
@@ -611,7 +622,8 @@ static struct device_info boards[] = {
 			{"default-mac", 0x30000, 0x00020},
 			{"product-info", 0x31100, 0x00100},
 			{"signature", 0x32000, 0x00400},
-			{"firmware", 0x40000, 0x770000},
+			{"os-image", 0x40000, 0x300000},
+			{"file-system", 0x340000, 0x470000},
 			{"soft-version", 0x7b0000, 0x00100},
 			{"support-list", 0x7b1000, 0x00400},
 			{"user-config", 0x7c0000, 0x10000},
@@ -643,7 +655,8 @@ static struct device_info boards[] = {
 			{"default-mac", 0x30000, 0x00020},
 			{"product-info", 0x31100, 0x00100},
 			{"signature", 0x32000, 0x00400},
-			{"firmware", 0x40000, 0x770000},
+			{"os-image", 0x40000, 0x300000},
+			{"file-system", 0x340000, 0x470000},
 			{"soft-version", 0x7b0000, 0x00100},
 			{"support-list", 0x7b1000, 0x00400},
 			{"user-config", 0x7c0000, 0x10000},
@@ -663,7 +676,7 @@ static struct device_info boards[] = {
 		.vendor = "",
 		.support_list =
 			"SupportList:\r\n"
-			"{product_name:AD7200,product_ver:1.0.0,special_id:00000000}\r\n",
+			"{product_name:Talon AD7200,product_ver:1.0.0,special_id:00000000}\r\n",
 		.part_trail = 0x00,
 		.soft_ver = NULL,
 
@@ -761,7 +774,7 @@ static struct device_info boards[] = {
 			"{product_name:Archer A7,product_ver:5.0.0,special_id:54570000}\n"
 			"{product_name:Archer A7,product_ver:5.0.0,special_id:52550000}\n",
 		.part_trail = 0x00,
-		.soft_ver = "soft_ver:7.0.0\n",
+		.soft_ver = "soft_ver:1.0.0\n",
 
 		/* We're using a dynamic kernel/rootfs split here */
 		.partitions = {
@@ -1048,78 +1061,7 @@ static struct device_info boards[] = {
 		.first_sysupgrade_partition = "os-image",
 		.last_sysupgrade_partition = "file-system",
 	},
-	/** Firmware layout for the Archer A6 v3  */
-	{
-		.id     = "ARCHER-A6-V3",
-		.vendor = "",
-		.support_list =
-			"SupportList:\n"
-			"{product_name:Archer A6,product_ver:3.0.0,special_id:55530000}\n"
-			"{product_name:Archer A6,product_ver:3.0.0,special_id:54570000}\n",
-		.part_trail = 0x00,
-		.soft_ver = "soft_ver:1.0.5\n",
 
-		.partitions = {
-			{"fs-uboot", 0x00000, 0x40000},
-			{"firmware", 0x40000, 0xf60000},
-			{"default-mac", 0xfa0000, 0x00200},
-			{"pin", 0xfa0200, 0x00100},
-			{"device-id", 0xfa0300, 0x00100},
-			{"product-info", 0xfa0400, 0x0fc00},
-			{"default-config", 0xfb0000, 0x08000},
-			{"ap-def-config", 0xfb8000, 0x08000},
-			{"user-config", 0xfc0000, 0x0a000},
-			{"ag-config", 0xfca000, 0x04000},
-			{"certificate", 0xfce000, 0x02000},
-			{"ap-config", 0xfd0000, 0x06000},
-			{"router-config", 0xfd6000, 0x06000},
-			{"favicon", 0xfdc000, 0x02000},
-			{"logo", 0xfde000, 0x02000},
-			{"partition-table", 0xfe0000, 0x00800},
-			{"soft-version", 0xfe0800, 0x00100},
-			{"support-list", 0xfe0900, 0x00200},
-			{"profile", 0xfe0b00, 0x03000},
-			{"extra-para", 0xfe3b00, 0x00100},
-			{"radio", 0xff0000, 0x10000},
-			{NULL, 0, 0}
-		},
-		.first_sysupgrade_partition = "os-image",
-		.last_sysupgrade_partition = "file-system",
-	},
-	/** Firmware layout for the Archer C6U v1 */
-	{
-		.id     = "ARCHER-C6U-V1",
-		.vendor = "",
-		.support_list =
-			"SupportList:\n"
-			"{product_name:Archer C6U,product_ver:1.0.0,special_id:45550000}\n",
-		.part_trail = 0x00,
-		.soft_ver = "soft_ver:1.0.2\n",
-
-		.partitions = {
-			{"fs-uboot", 0x00000, 0x40000},
-			{"firmware", 0x40000, 0xf60000},
-			{"default-mac", 0xfa0000, 0x00200},
-			{"pin", 0xfa0200, 0x00100},
-			{"device-id", 0xfa0300, 0x00100},
-			{"product-info", 0xfa0400, 0x0fc00},
-			{"default-config", 0xfb0000, 0x08000},
-			{"ap-def-config", 0xfb8000, 0x08000},
-			{"user-config", 0xfc0000, 0x0c000},
-			{"certificate", 0xfcc000, 0x04000},
-			{"ap-config", 0xfd0000, 0x08000},
-			{"router-config", 0xfd8000, 0x08000},
-			{"partition-table", 0xfe0000, 0x00800},
-			{"soft-version", 0xfe0800, 0x00100},
-			{"support-list", 0xfe0900, 0x00200},
-			{"profile", 0xfe0b00, 0x03000},
-			{"extra-para", 0xfe3b00, 0x00100},
-			{"radio", 0xff0000, 0x10000},
-			{NULL, 0, 0}
-		},
-		.first_sysupgrade_partition = "os-image",
-		.last_sysupgrade_partition = "file-system",
-	},
 	/** Firmware layout for the C60v1 */
 	{
 		.id     = "ARCHER-C60-V1",
@@ -2884,8 +2826,7 @@ static void build_image(const char *output,
 	parts[4] = read_file("file-system", rootfs_image, add_jffs2_eof, file_system_partition);
 
 	/* Some devices need the extra-para partition to accept the firmware */
-	if (strcasecmp(info->id, "ARCHER-A6-V3") == 0 ||
-	    strcasecmp(info->id, "ARCHER-A7-V5") == 0 ||
+	if (strcasecmp(info->id, "ARCHER-A7-V5") == 0 ||
 	    strcasecmp(info->id, "ARCHER-C2-V3") == 0 ||
 	    strcasecmp(info->id, "ARCHER-C7-V4") == 0 ||
 	    strcasecmp(info->id, "ARCHER-C7-V5") == 0 ||
@@ -2893,7 +2834,6 @@ static void build_image(const char *output,
 	    strcasecmp(info->id, "ARCHER-C59-V2") == 0 ||
 	    strcasecmp(info->id, "ARCHER-C60-V2") == 0 ||
 	    strcasecmp(info->id, "ARCHER-C60-V3") == 0 ||
-	    strcasecmp(info->id, "ARCHER-C6U-V1") == 0 ||
 	    strcasecmp(info->id, "TLWR1043NV5") == 0) {
 		const uint8_t extra_para[2] = {0x01, 0x00};
 		parts[5] = make_extra_para(info, extra_para,
@@ -2939,6 +2879,8 @@ static void usage(const char *argv0) {
 		"Options:\n"
 		"  -h              show this help\n"
 		"\n"
+		"Info about an image:\n"
+		"  -i <file>       input file to read from\n"
 		"Create a new image:\n"
 		"  -B <board>      create image for the board specified with <board>\n"
 		"  -k <file>       read kernel image from the file <file>\n"
@@ -3203,10 +3145,123 @@ static struct flash_partition_entry *find_partition(
 			return entries;
 	}
 
-	error(1, 0, "%s", error_msg);
+	if (error_msg) {
+		error(1, 0, "%s", error_msg);
+	}
+
 	return NULL;
 }
 
+static int firmware_info(const char *input)
+{
+	struct flash_partition_entry pointers[MAX_PARTITIONS] = { };
+	struct flash_partition_entry *e;
+	FILE *fp;
+	int i;
+
+	fp = fopen(input, "r");
+
+	if (read_partition_table(fp, 0x1014, pointers, MAX_PARTITIONS, 0)) {
+		error(1, 0, "Error can not read the partition table (fwup-ptn)");
+	}
+
+	printf("Firmware image partitions:\n");
+	printf("%-8s %-8s %s\n", "base", "size", "name");
+	for (i = 0; i < MAX_PARTITIONS; i++) {
+		e = &pointers[i];
+
+		if (!e->name && !e->base && !e->size)
+			continue;
+
+		printf("%08x %08x %s\n", e->base, e->size, e->name ? e->name : "");
+	}
+
+	e = find_partition(pointers, MAX_PARTITIONS, "soft-version", NULL);
+	if (e) {
+		size_t data_len = e->size - sizeof(struct meta_header);
+		char *buf = malloc(data_len);
+		struct soft_version *s;
+		bool isstr;
+		int i;
+
+		if (!buf)
+			error(1, errno, "Failed to alloc buffer");
+
+		if (fseek(fp, 0x1014 + e->base + sizeof(struct meta_header), SEEK_SET))
+			error(1, errno, "Can not seek in the firmware");
+
+		if (fread(buf, data_len, 1, fp) != 1)
+			error(1, errno, "Can not read fwup-ptn data from the firmware");
+
+		/* Check for string ignoring padding character */
+		isstr = true;
+		for (i = 0; i < data_len - 1; i++) {
+			if (!isascii(buf[i])) {
+				isstr = false;
+				break;
+			}
+		}
+
+		printf("\n[Software version]\n");
+		if (isstr) {
+			fwrite(buf, data_len, 1, stdout);
+			putchar('\n');
+		} else if (data_len >= offsetof(struct soft_version, rev)) {
+			s = (struct soft_version *)buf;
+
+			printf("Version: %d.%d.%d\n", s->version_major, s->version_minor, s->version_patch);
+			printf("Date: %02x%02x-%02x-%02x\n", s->year_hi, s->year_lo, s->month, s->day);
+		} else {
+			printf("Failed to parse data\n");
+		}
+
+		free(buf);
+	}
+
+	e = find_partition(pointers, MAX_PARTITIONS, "support-list", NULL);
+	if (e) {
+		char buf[128];
+		size_t length;
+		size_t bytes;
+
+		if (fseek(fp, 0x1014 + e->base + sizeof(struct meta_header), SEEK_SET))
+			error(1, errno, "Can not seek in the firmware");
+
+		printf("\n[Support list]\n");
+		for (length = e->size - sizeof(struct meta_header); length; length -= bytes) {
+			bytes = fread(buf, 1, length > sizeof(buf) ? sizeof(buf) : length, fp);
+			if (bytes <= 0)
+				error(1, errno, "Can not read fwup-ptn data from the firmware");
+
+			puts(buf);
+		}
+	}
+
+	e = find_partition(pointers, MAX_PARTITIONS, "partition-table", NULL);
+	if (e) {
+		struct flash_partition_entry parts[MAX_PARTITIONS] = { };
+
+		if (read_partition_table(fp, 0x1014 + e->base + 4, parts, MAX_PARTITIONS, 1)) {
+			error(1, 0, "Error can not read the partition table (partition)");
+		}
+
+		printf("\n[Partition table]\n");
+		printf("%-8s %-8s %s\n", "base", "size", "name");
+		for (i = 0; i < MAX_PARTITIONS; i++) {
+			e = &parts[i];
+
+			if (!e->name && !e->base && !e->size)
+				continue;
+
+			printf("%08x %08x %s\n", e->base, e->size, e->name ? e->name : "");
+		}
+	}
+
+	fclose(fp);
+
+	return 0;
+}
+
 static void write_ff(FILE *output_file, size_t size)
 {
 	char buf[4096];
@@ -3286,7 +3341,7 @@ static void convert_firmware(const char *input, const char *output)
 }
 
 int main(int argc, char *argv[]) {
-	const char *board = NULL, *kernel_image = NULL, *rootfs_image = NULL, *output = NULL;
+	const char *info_image = NULL, *board = NULL, *kernel_image = NULL, *rootfs_image = NULL, *output = NULL;
 	const char *extract_image = NULL, *output_directory = NULL, *convert_image = NULL;
 	bool add_jffs2_eof = false, sysupgrade = false;
 	unsigned rev = 0;
@@ -3296,11 +3351,15 @@ int main(int argc, char *argv[]) {
 	while (true) {
 		int c;
 
-		c = getopt(argc, argv, "B:k:r:o:V:jSh:x:d:z:");
+		c = getopt(argc, argv, "i:B:k:r:o:V:jSh:x:d:z:");
 		if (c == -1)
 			break;
 
 		switch (c) {
+		case 'i':
+			info_image = optarg;
+			break;
+
 		case 'B':
 			board = optarg;
 			break;
@@ -3351,7 +3410,9 @@ int main(int argc, char *argv[]) {
 		}
 	}
 
-	if (extract_image || output_directory) {
+	if (info_image) {
+		firmware_info(info_image);
+	} else if (extract_image || output_directory) {
 		if (!extract_image)
 			error(1, 0, "No factory/oem image given via -x <file>. Output directory is only valid with -x");
 		if (!output_directory)
diff --git a/tools/firmware-utils/src/trx2edips.c b/tools/firmware-utils/src/trx2edips.c
index f8d068d502..14c4eb70ba 100644
--- a/tools/firmware-utils/src/trx2edips.c
+++ b/tools/firmware-utils/src/trx2edips.c
@@ -140,6 +140,10 @@ int main(int argc, char *argv[])
 	rewind(fpIn);
 	/* read the whole file*/
 	res = fread(buf, 1, length, fpIn);
+	if (res != length) {
+		fprintf(stderr, "Unable to fread from input file\n");
+		return EXIT_FAILURE;
+	}
 
 	p = (struct trx_header *)buf;
 	if (LOAD32_LE(p->magic) != TRX_MAGIC) {
diff --git a/tools/firmware-utils/src/xorimage.c b/tools/firmware-utils/src/xorimage.c
index 2ca643faeb..e13531ab4a 100644
--- a/tools/firmware-utils/src/xorimage.c
+++ b/tools/firmware-utils/src/xorimage.c
@@ -29,15 +29,17 @@ static char default_pattern[] = "12345678";
 static int is_hex_pattern;
 
 
-int xor_data(uint8_t *data, size_t len, const uint8_t *pattern, int p_len, int p_off)
+int xor_data(void *data, size_t len, const void *pattern, int p_len, int p_off)
 {
-	int offset = p_off;
+	const uint8_t *key = pattern;
+	uint8_t *d = data;
+
 	while (len--) {
-		*data ^= pattern[offset];
-		data++;
-		offset = (offset + 1) % p_len;
+		*d ^= key[p_off];
+		d++;
+		p_off = (p_off + 1) % p_len;
 	}
-	return offset;
+	return p_off;
 }
 
 
@@ -61,7 +63,6 @@ int main(int argc, char **argv)
 	char hex_pattern[128];
 	unsigned int hex_buf;
 	int c;
-	int v0, v1, v2;
 	size_t n;
 	int p_len, p_off = 0;
 
diff --git a/tools/firmware-utils/src/zyimage.c b/tools/firmware-utils/src/zyimage.c
index 6aacf2ff1b..4f7cfd6f43 100644
--- a/tools/firmware-utils/src/zyimage.c
+++ b/tools/firmware-utils/src/zyimage.c
@@ -7,8 +7,6 @@
  *
  */
 
-#define _POSIX_SOURCE
-#define _POSIX_C_SOURCE 199309L /* getopt */
 #include <stdio.h>
 #include <stdlib.h>
 #include <sys/types.h>
diff --git a/tools/firmware-utils/src/zytrx.c b/tools/firmware-utils/src/zytrx.c
deleted file mode 100644
index 7167679206..0000000000
--- a/tools/firmware-utils/src/zytrx.c
+++ /dev/null
@@ -1,228 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0-only
-/*
- * zytrx - add header to images for ZyXEL NR7101
- *
- * Based on add_header.c - partially based on OpenWrt's
- * motorola-bin.c
- *
- * Copyright (C) 2008 Imre Kaloz  <kaloz@openwrt.org>
- *                    Gabor Juhos <juhosg@openwrt.org>
- * Copyright (C) 2021 Bjørn Mork <bjorn@mork.no>
-
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License,
- * version 2 as published by the Free Software Foundation.
- */
-
-#include <stdio.h>
-#include <stdlib.h>
-#include <stddef.h>
-#include <unistd.h>
-#include <errno.h>
-#include <fcntl.h>
-#include <sys/mman.h>
-#include <sys/stat.h>
-#include <string.h>
-#include <netinet/in.h>
-#include <inttypes.h>
-
-#define BPB 8 /* bits/byte */
-
-static uint32_t crc32[1<<BPB];
-
-static void init_crc32(void)
-{
-	const uint32_t poly = ntohl(0x2083b8ed);
-	int n;
-
-	for (n = 0; n < 1<<BPB; n++) {
-		uint32_t crc = n;
-		int bit;
-
-		for (bit = 0; bit < BPB; bit++)
-			crc = (crc & 1) ? (poly ^ (crc >> 1)) : (crc >> 1);
-		crc32[n] = crc;
-	}
-}
-
-static uint32_t crc32buf(const unsigned char *buf, size_t len)
-{
-	uint32_t crc = 0xFFFFFFFF;
-
-	for (; len; len--, buf++)
-		crc = crc32[(uint8_t)crc ^ *buf] ^ (crc >> BPB);
-	return ~crc;
-}
-
-/* HDR0 reversed, to be stored as BE */
-#define MAGIC		0x30524448  /* HDR0 reversed, to be stored as BE */
-
-/* All numbers are stored as BE */
-struct zytrx_t {
-	uint32_t magic;
-	uint32_t len_h;		/* Length of this header */
-	uint32_t len_t;		/* Total length of file  */
-	uint32_t crc32_p;	/* Bit inverted 32-bit CRC of image payload */
-	uint8_t  verInt[32];	/* String "5.0.0.0\n" zero padded */
-	uint8_t  verExt[32];	/* String "\n" zero padded */
-	uint32_t len_p;		/* Length of image payload */
-	uint8_t  pad1[12];	/* zero padding(?) */
-	uint8_t  code[164];	/* string "3 6035 122 0\n" zero padded */
-	uint8_t  chipid[8];	/* string "MT7621A" zero padded */
-	uint8_t  boardid[16];	/* string "NR7101" zero padded */
-	uint32_t modelid;	/* modelid as 4 BCD digits: 0x07010001 */
-	uint8_t  pad2[8];	/* zero padding(?) */
-	uint8_t  swVersionInt[32];	/* ZyXEL version string: "1.00(ABUV.0)D0" zero padded */
-	uint8_t  swVersionExt[32];	/* identical to swVersionInt  */
-	uint8_t  pad4[4];	/* zero padding(?) */
-	uint32_t kernelChksum;	/* no idea how this is computed - reported but not validated */
-	uint8_t  pad5[4];	/* zero padding(?) */
-	uint32_t crc32_h;	/* Bit inverted 32-bit CRC of this header payload */
-	uint8_t  pad6[4];	/* zero padding(?) */
-};
-
-/* static?() field values of unknown meaning - maybe ove to board
- * table when we know the significance
- */
-#define VER_INT		"5.0.0.0\n"
-#define VER_EXT		"\n"
-#define CODE		"3 6035 122 0\n"
-#define KERNELCHKSUM	0x12345678
-
-/* table of supported devices using this header format */
-static struct board_t {
-	uint8_t  chipid[8];
-	uint8_t  boardid[16];
-	uint32_t modelid;
-} boards[] = {
-	{ "MT7621A", "NR7101", 0x07010001 },
-	{}
-};
-
-static int find_board(struct zytrx_t *h, char *board)
-{
-	struct board_t *p;
-
-	for (p = boards; p->modelid; p++) {
-		if (strncmp((const char *)p->boardid, board, sizeof(p->boardid)))
-			continue;
-		memcpy(h->chipid, p->chipid, sizeof(h->chipid));
-		memcpy(h->boardid, p->boardid, sizeof(h->boardid));
-		h->modelid = htonl(p->modelid);
-		return 0;
-	}
-	return -1;
-}
-
-static void usage(const char *name)
-{
-	struct board_t *p;
-
-	fprintf(stderr, "Usage:\n");
-	fprintf(stderr, " %s -B <board> -v <versionstr> -i <file> [-o <outputfile>]\n\n", name);
-	fprintf(stderr, "Supported <board> values:\n");
-	for (p = boards; p->modelid; p++)
-		fprintf(stderr, "\t%-12s\n", p->boardid);
-	fprintf(stderr, "\nExample:\n");
-	fprintf(stderr, " %s -B %s -v foobar-1.0 -i my.img -o out.img\n\n", name,
-		boards[0].boardid);
-	exit(EXIT_FAILURE);
-}
-
-static void errexit(const char *msg)
-{
-	fprintf(stderr, "ERR: %s: %s\n", msg, errno ? strerror(errno) : "unknown");
-	exit(EXIT_FAILURE);
-}
-
-static void *map_input(const char *name, size_t *len)
-{
-	struct stat stat;
-	void *mapped;
-	int fd;
-
-	fd = open(name, O_RDONLY);
-	if (fd < 0)
-		return NULL;
-	if (fstat(fd, &stat) < 0) {
-		close(fd);
-		return NULL;
-	}
-	*len = stat.st_size;
-	mapped = mmap(NULL, stat.st_size, PROT_READ, MAP_SHARED, fd, 0);
-	if (close(fd) < 0) {
-		(void) munmap(mapped, stat.st_size);
-		return NULL;
-	}
-	return mapped;
-}
-
-int main(int argc, char **argv)
-{
-	int c, fdout = STDOUT_FILENO;
-	void *input_file = NULL;
-	size_t file_len, len;
-	uint32_t crc;
-	struct zytrx_t h = {
-		.magic		= htonl(MAGIC),
-		.len_h		= htonl(sizeof(h)),
-		.verInt		= VER_INT,
-		.verExt		= VER_EXT,
-		.code		= CODE,
-		.kernelChksum	= htonl(KERNELCHKSUM),
-	};
-
-	while ((c = getopt(argc, argv, "B:v:i:o:")) != -1) {
-		switch (c) {
-		case 'B':
-			if (find_board(&h, optarg) < 0)
-				errexit("unsupported board");
-			break;
-		case 'v':
-			len = strlen(optarg);
-			if (len > sizeof(h.swVersionInt))
-				errexit("version string too long");
-			memcpy(h.swVersionInt, optarg, len);
-			memcpy(h.swVersionExt, optarg, len);
-			break;
-		case 'i':
-			input_file = map_input(optarg, &file_len);
-			if (!input_file)
-				errexit(optarg);
-			break;
-		case 'o':
-			fdout = open(optarg, O_WRONLY | O_CREAT, 0644);
-			if (fdout < 0)
-				errexit(optarg);
-			break;
-		default:
-			usage(argv[0]);
-		}
-	}
-
-	/* required paremeters */
-	if (!input_file || !h.modelid || !h.swVersionInt[0])
-		usage(argv[0]);
-
-	/* length fields */
-	h.len_t = htonl(sizeof(h) + file_len);
-	h.len_p = htonl(file_len);
-
-	/* crc fields */
-	init_crc32();
-	crc = crc32buf(input_file, file_len);
-	h.crc32_p = htonl(~crc);
-	crc = crc32buf((unsigned char *)&h, sizeof(h));
-	h.crc32_h = htonl(~crc);
-
-	/* dump new image */
-	write(fdout, &h, sizeof(h));
-	write(fdout, input_file, file_len);
-
-	/* close files */
-	munmap(input_file, file_len);
-	if (fdout != STDOUT_FILENO)
-		close(fdout);
-
-	return EXIT_SUCCESS;
-}
diff --git a/tools/mkimage/patches/080-mtk_image-add-support-for-booting-ARM64-images.patch b/tools/mkimage/patches/080-mtk_image-add-support-for-booting-ARM64-images.patch
new file mode 100644
index 0000000000..dfe8128fb5
--- /dev/null
+++ b/tools/mkimage/patches/080-mtk_image-add-support-for-booting-ARM64-images.patch
@@ -0,0 +1,134 @@
+From 44165e4c676d266f73fda2e6ba82b4bf3262daf2 Mon Sep 17 00:00:00 2001
+From: Fabien Parent <fparent@baylibre.com>
+Date: Fri, 16 Oct 2020 19:52:37 +0200
+Subject: [PATCH] tools: mtk_image: add support for booting ARM64 images
+
+mkimage is only able to package aarch32 binaries. Add support for
+AArch64 images.
+
+One can create a ARM64 image using the following command line:
+mkimage -T mtk_image -a 0x201000 -e 0x201000 -n "media=emmc;arm64=1"
+-d bl2.bin bl2.img
+
+Signed-off-by: Fabien Parent <fparent@baylibre.com>
+---
+ tools/mtk_image.c | 28 ++++++++++++++++++++++++----
+ tools/mtk_image.h |  6 +++++-
+ 2 files changed, 29 insertions(+), 5 deletions(-)
+
+diff --git a/tools/mtk_image.c b/tools/mtk_image.c
+index 2ca519483d..bde1e5da4b 100644
+--- a/tools/mtk_image.c
++++ b/tools/mtk_image.c
+@@ -246,6 +246,7 @@ static const struct brom_img_type {
+ /* Image type selected by user */
+ static enum brlyt_img_type hdr_media;
+ static int use_lk_hdr;
++static bool is_arm64_image;
+ 
+ /* LK image name */
+ static char lk_name[32] = "U-Boot";
+@@ -276,6 +277,7 @@ static int mtk_brom_parse_imagename(const char *imagename)
+ 	static const char *media = "";
+ 	static const char *nandinfo = "";
+ 	static const char *lk = "";
++	static const char *arm64_param = "";
+ 
+ 	key = buf;
+ 	while (key) {
+@@ -323,6 +325,9 @@ static int mtk_brom_parse_imagename(const char *imagename)
+ 
+ 			if (!strcmp(key, "lkname"))
+ 				snprintf(lk_name, sizeof(lk_name), "%s", val);
++
++			if (!strcmp(key, "arm64"))
++				arm64_param = val;
+ 		}
+ 
+ 		if (next)
+@@ -354,6 +359,9 @@ static int mtk_brom_parse_imagename(const char *imagename)
+ 		}
+ 	}
+ 
++	if (arm64_param && arm64_param[0] == '1')
++		is_arm64_image = true;
++
+ 	free(buf);
+ 
+ 	if (hdr_media == BRLYT_TYPE_INVALID) {
+@@ -458,6 +466,9 @@ static int mtk_image_verify_gen_header(const uint8_t *ptr, int print)
+ 		       le32_to_cpu(gfh->file_info.load_addr) +
+ 		       le32_to_cpu(gfh->file_info.jump_offset));
+ 
++	if (print)
++		printf("Architecture: %s\n", is_arm64_image ? "ARM64" : "ARM");
++
+ 	return 0;
+ }
+ 
+@@ -523,6 +534,9 @@ static int mtk_image_verify_nand_header(const uint8_t *ptr, int print)
+ 		       le32_to_cpu(gfh->file_info.load_addr) +
+ 		       le32_to_cpu(gfh->file_info.jump_offset));
+ 
++	if (print)
++		printf("Architecture: %s\n", is_arm64_image ? "ARM64" : "ARM");
++
+ 	return 0;
+ }
+ 
+@@ -581,6 +595,8 @@ static void put_ghf_common_header(struct gfh_common_header *gfh, int size,
+ static void put_ghf_header(struct gfh_header *gfh, int file_size,
+ 			   int dev_hdr_size, int load_addr, int flash_type)
+ {
++	uint32_t cfg_bits;
++
+ 	memset(gfh, 0, sizeof(struct gfh_header));
+ 
+ 	/* GFH_FILE_INFO header */
+@@ -608,11 +624,15 @@ static void put_ghf_header(struct gfh_header *gfh, int file_size,
+ 	/* GFH_BROM_CFG header */
+ 	put_ghf_common_header(&gfh->brom_cfg.gfh, sizeof(gfh->brom_cfg),
+ 			      GFH_TYPE_BROM_CFG, 3);
+-	gfh->brom_cfg.cfg_bits = cpu_to_le32(
+-		GFH_BROM_CFG_USBDL_AUTO_DETECT_DIS |
+-		GFH_BROM_CFG_USBDL_BY_KCOL0_TIMEOUT_EN |
+-		GFH_BROM_CFG_USBDL_BY_FLAG_TIMEOUT_EN);
++	cfg_bits = GFH_BROM_CFG_USBDL_AUTO_DETECT_DIS |
++		   GFH_BROM_CFG_USBDL_BY_KCOL0_TIMEOUT_EN |
++		   GFH_BROM_CFG_USBDL_BY_FLAG_TIMEOUT_EN;
+ 	gfh->brom_cfg.usbdl_by_kcol0_timeout_ms = cpu_to_le32(5000);
++	if (is_arm64_image) {
++		gfh->brom_cfg.jump_bl_arm64 = GFH_BROM_CFG_JUMP_BL_ARM64;
++		cfg_bits |= GFH_BROM_CFG_JUMP_BL_ARM64_EN;
++	}
++	gfh->brom_cfg.cfg_bits = cpu_to_le32(cfg_bits);
+ 
+ 	/* GFH_BL_SEC_KEY header */
+ 	put_ghf_common_header(&gfh->bl_sec_key.gfh, sizeof(gfh->bl_sec_key),
+diff --git a/tools/mtk_image.h b/tools/mtk_image.h
+index 4e78b3d0ff..7dda71ce88 100644
+--- a/tools/mtk_image.h
++++ b/tools/mtk_image.h
+@@ -136,7 +136,9 @@ struct gfh_brom_cfg {
+ 	struct gfh_common_header gfh;
+ 	uint32_t cfg_bits;
+ 	uint32_t usbdl_by_auto_detect_timeout_ms;
+-	uint8_t unused[0x48];
++	uint8_t unused[0x45];
++	uint8_t jump_bl_arm64;
++	uint8_t unused2[2];
+ 	uint32_t usbdl_by_kcol0_timeout_ms;
+ 	uint32_t usbdl_by_flag_timeout_ms;
+ 	uint32_t pad;
+@@ -146,6 +148,8 @@ struct gfh_brom_cfg {
+ #define GFH_BROM_CFG_USBDL_AUTO_DETECT_DIS		0x10
+ #define GFH_BROM_CFG_USBDL_BY_KCOL0_TIMEOUT_EN		0x80
+ #define GFH_BROM_CFG_USBDL_BY_FLAG_TIMEOUT_EN		0x100
++#define GFH_BROM_CFG_JUMP_BL_ARM64_EN			0x1000
++#define GFH_BROM_CFG_JUMP_BL_ARM64			0x64
+ 
+ struct gfh_bl_sec_key {
+ 	struct gfh_common_header gfh;
+-- 
+2.30.1
+
diff --git a/tools/mkimage/patches/081-mtk_image-add-an-option-to-set-device-header-offset.patch b/tools/mkimage/patches/081-mtk_image-add-an-option-to-set-device-header-offset.patch
new file mode 100644
index 0000000000..45f8f7c1c1
--- /dev/null
+++ b/tools/mkimage/patches/081-mtk_image-add-an-option-to-set-device-header-offset.patch
@@ -0,0 +1,226 @@
+From patchwork Tue Mar  9 07:52:31 2021
+Content-Type: text/plain; charset="utf-8"
+MIME-Version: 1.0
+Content-Transfer-Encoding: 7bit
+X-Patchwork-Submitter: Weijie Gao <weijie.gao@mediatek.com>
+X-Patchwork-Id: 1449568
+Return-Path: <u-boot-bounces@lists.denx.de>
+X-Original-To: incoming@patchwork.ozlabs.org
+Delivered-To: patchwork-incoming@bilbo.ozlabs.org
+Authentication-Results: ozlabs.org;
+ spf=pass (sender SPF authorized) smtp.mailfrom=lists.denx.de
+ (client-ip=2a01:238:438b:c500:173d:9f52:ddab:ee01; helo=phobos.denx.de;
+ envelope-from=u-boot-bounces@lists.denx.de; receiver=<UNKNOWN>)
+Authentication-Results: ozlabs.org;
+	dkim=pass (1024-bit key;
+ unprotected) header.d=mediatek.com header.i=@mediatek.com header.a=rsa-sha256
+ header.s=dk header.b=i1dK9gFR;
+	dkim-atps=neutral
+Received: from phobos.denx.de (phobos.denx.de
+ [IPv6:2a01:238:438b:c500:173d:9f52:ddab:ee01])
+	(using TLSv1.3 with cipher TLS_AES_256_GCM_SHA384 (256/256 bits)
+	 key-exchange X25519 server-signature RSA-PSS (4096 bits) server-digest
+ SHA256)
+	(No client certificate requested)
+	by ozlabs.org (Postfix) with ESMTPS id 4DvnX84rrHz9sW1
+	for <incoming@patchwork.ozlabs.org>; Tue,  9 Mar 2021 18:53:44 +1100 (AEDT)
+Received: from h2850616.stratoserver.net (localhost [IPv6:::1])
+	by phobos.denx.de (Postfix) with ESMTP id DF60F8219C;
+	Tue,  9 Mar 2021 08:53:29 +0100 (CET)
+Authentication-Results: phobos.denx.de;
+ dmarc=pass (p=none dis=none) header.from=mediatek.com
+Authentication-Results: phobos.denx.de;
+ spf=pass smtp.mailfrom=u-boot-bounces@lists.denx.de
+Authentication-Results: phobos.denx.de;
+	dkim=pass (1024-bit key;
+ unprotected) header.d=mediatek.com header.i=@mediatek.com
+ header.b="i1dK9gFR";
+	dkim-atps=neutral
+Received: by phobos.denx.de (Postfix, from userid 109)
+ id 5456882625; Tue,  9 Mar 2021 08:53:28 +0100 (CET)
+X-Spam-Checker-Version: SpamAssassin 3.4.2 (2018-09-13) on phobos.denx.de
+X-Spam-Level: 
+X-Spam-Status: No, score=0.5 required=5.0 tests=BAYES_00,DKIM_SIGNED,
+ DKIM_VALID,DKIM_VALID_AU,MIME_BASE64_TEXT,RDNS_NONE,SPF_HELO_NONE,
+ UNPARSEABLE_RELAY autolearn=no autolearn_force=no version=3.4.2
+Received: from mailgw02.mediatek.com (unknown [1.203.163.81])
+ by phobos.denx.de (Postfix) with ESMTP id 7526E80EF2
+ for <u-boot@lists.denx.de>; Tue,  9 Mar 2021 08:53:19 +0100 (CET)
+Authentication-Results: phobos.denx.de;
+ dmarc=pass (p=none dis=none) header.from=mediatek.com
+Authentication-Results: phobos.denx.de;
+ spf=pass smtp.mailfrom=weijie.gao@mediatek.com
+X-UUID: 3b5ccbd89ab948daa31ec738ee94e7ed-20210309
+DKIM-Signature: v=1; a=rsa-sha256; q=dns/txt; c=relaxed/relaxed;
+ d=mediatek.com;
+ s=dk;
+ h=Content-Transfer-Encoding:Content-Type:MIME-Version:Message-ID:Date:Subject:CC:To:From;
+ bh=mijplkmurYfYet7eQPGQD6GyyMtN6xMXZKHVAlpy0hM=;
+ b=i1dK9gFRfmkqD5vAud81Q3CdZlOQm3XK0H/NwbxYyncwalZqRZA1YBKTQhmPW0avcbwOQpGVlRmu1VAfALWgK80acX7bPIjWjtaJtK4/99vc+wIthmm1E5QMewyBAFkzGfx7A8ryh4HdcsG/esbnI0Mk2nletBHwRFAEVs3uUfU=;
+X-UUID: 3b5ccbd89ab948daa31ec738ee94e7ed-20210309
+Received: from mtkcas32.mediatek.inc [(172.27.4.253)] by mailgw02.mediatek.com
+ (envelope-from <weijie.gao@mediatek.com>)
+ (mailgw01.mediatek.com ESMTP with TLSv1.2 ECDHE-RSA-AES256-SHA384 256/256)
+ with ESMTP id 23424931; Tue, 09 Mar 2021 15:53:06 +0800
+Received: from MTKCAS32.mediatek.inc (172.27.4.184) by MTKMBS31N1.mediatek.inc
+ (172.27.4.69) with Microsoft SMTP Server (TLS) id 15.0.1497.2;
+ Tue, 9 Mar 2021 15:52:58 +0800
+Received: from mcddlt001.mediatek.inc (10.19.240.15) by MTKCAS32.mediatek.inc
+ (172.27.4.170) with Microsoft SMTP Server id 15.0.1497.2 via Frontend
+ Transport; Tue, 9 Mar 2021 15:52:58 +0800
+From: Weijie Gao <weijie.gao@mediatek.com>
+To: <u-boot@lists.denx.de>
+CC: GSS_MTK_Uboot_upstream <GSS_MTK_Uboot_upstream@mediatek.com>, Weijie Gao
+ <weijie.gao@mediatek.com>
+Subject: [PATCH] tools: mtk_image: add an option to set device header offset
+Date: Tue, 9 Mar 2021 15:52:31 +0800
+Message-ID: <1615276351-30641-1-git-send-email-weijie.gao@mediatek.com>
+X-Mailer: git-send-email 1.9.1
+MIME-Version: 1.0
+X-TM-SNTS-SMTP: 
+ B09EA906E69093D91FA73A3F764A0B89D3838DA91A4FA20DA0483EBE19962CA02000:8
+X-MTK: N
+X-BeenThere: u-boot@lists.denx.de
+X-Mailman-Version: 2.1.34
+Precedence: list
+List-Id: U-Boot discussion <u-boot.lists.denx.de>
+List-Unsubscribe: <https://lists.denx.de/options/u-boot>,
+ <mailto:u-boot-request@lists.denx.de?subject=unsubscribe>
+List-Archive: <https://lists.denx.de/pipermail/u-boot/>
+List-Post: <mailto:u-boot@lists.denx.de>
+List-Help: <mailto:u-boot-request@lists.denx.de?subject=help>
+List-Subscribe: <https://lists.denx.de/listinfo/u-boot>,
+ <mailto:u-boot-request@lists.denx.de?subject=subscribe>
+Errors-To: u-boot-bounces@lists.denx.de
+Sender: "U-Boot" <u-boot-bounces@lists.denx.de>
+X-Virus-Scanned: clamav-milter 0.102.4 at phobos.denx.de
+X-Virus-Status: Clean
+
+This patch adds an option which allows setting the device header offset.
+This is useful if this tool is used to generate ATF BL2 image of mt7622 for
+SD cards.
+
+Signed-off-by: Weijie Gao <weijie.gao@mediatek.com>
+---
+ tools/mtk_image.c | 50 ++++++++++++++++++++++++++++++++++++++++++++---
+ 1 file changed, 47 insertions(+), 3 deletions(-)
+
+diff --git a/tools/mtk_image.c b/tools/mtk_image.c
+index bde1e5da4b..418c5fd54b 100644
+--- a/tools/mtk_image.c
++++ b/tools/mtk_image.c
+@@ -243,8 +243,13 @@ static const struct brom_img_type {
+ 	}
+ };
+ 
++/* Indicates whether we're generating or verifying */
++static bool img_gen;
++static uint32_t img_size;
++
+ /* Image type selected by user */
+ static enum brlyt_img_type hdr_media;
++static uint32_t hdr_offset;
+ static int use_lk_hdr;
+ static bool is_arm64_image;
+ 
+@@ -275,6 +280,7 @@ static int mtk_brom_parse_imagename(const char *imagename)
+ 
+ 	/* User passed arguments from image name */
+ 	static const char *media = "";
++	static const char *hdr_offs = "";
+ 	static const char *nandinfo = "";
+ 	static const char *lk = "";
+ 	static const char *arm64_param = "";
+@@ -317,6 +323,9 @@ static int mtk_brom_parse_imagename(const char *imagename)
+ 			if (!strcmp(key, "media"))
+ 				media = val;
+ 
++			if (!strcmp(key, "hdroffset"))
++				hdr_offs = val;
++
+ 			if (!strcmp(key, "nandinfo"))
+ 				nandinfo = val;
+ 
+@@ -359,6 +368,10 @@ static int mtk_brom_parse_imagename(const char *imagename)
+ 		}
+ 	}
+ 
++	/* parse device header offset */
++	if (hdr_offs && hdr_offs[0])
++		hdr_offset = strtoul(hdr_offs, NULL, 0);
++
+ 	if (arm64_param && arm64_param[0] == '1')
+ 		is_arm64_image = true;
+ 
+@@ -422,6 +435,7 @@ static int mtk_image_vrec_header(struct image_tool_params *params,
+ static int mtk_image_verify_gen_header(const uint8_t *ptr, int print)
+ {
+ 	union gen_boot_header *gbh = (union gen_boot_header *)ptr;
++	uint32_t gfh_offset, total_size, devh_size;
+ 	struct brom_layout_header *bh;
+ 	struct gfh_header *gfh;
+ 	const char *bootmedia;
+@@ -453,7 +467,32 @@ static int mtk_image_verify_gen_header(const uint8_t *ptr, int print)
+ 	    le32_to_cpu(bh->type) != BRLYT_TYPE_SDMMC))
+ 		return -1;
+ 
+-	gfh = (struct gfh_header *)(ptr + le32_to_cpu(bh->header_size));
++	devh_size = sizeof(struct gen_device_header);
++
++	if (img_gen) {
++		gfh_offset = devh_size;
++	} else {
++		gfh_offset = le32_to_cpu(bh->header_size);
++
++		if (gfh_offset + sizeof(struct gfh_header) > img_size) {
++			/*
++			 * This may happen if the hdr_offset used to generate
++			 * this image is not zero.
++			 * Since device header size is not fixed, we can't
++			 * cover all possible cases.
++			 * Assuming the image is valid only if the real
++			 * device header size equals to devh_size.
++			 */
++			total_size = le32_to_cpu(bh->total_size);
++
++			if (total_size - gfh_offset > img_size - devh_size)
++				return -1;
++
++			gfh_offset = devh_size;
++		}
++	}
++
++	gfh = (struct gfh_header *)(ptr + gfh_offset);
+ 
+ 	if (strcmp(gfh->file_info.name, GFH_FILE_INFO_NAME))
+ 		return -1;
+@@ -549,6 +588,8 @@ static int mtk_image_verify_header(unsigned char *ptr, int image_size,
+ 	if (le32_to_cpu(lk->magic) == LK_PART_MAGIC)
+ 		return 0;
+ 
++	img_size = image_size;
++
+ 	if (!strcmp((char *)ptr, NAND_BOOT_NAME))
+ 		return mtk_image_verify_nand_header(ptr, 0);
+ 	else
+@@ -682,8 +723,8 @@ static void mtk_image_set_gen_header(void *ptr, off_t filesize,
+ 
+ 	/* BRLYT header */
+ 	put_brom_layout_header(&hdr->brlyt, hdr_media);
+-	hdr->brlyt.header_size = cpu_to_le32(sizeof(struct gen_device_header));
+-	hdr->brlyt.total_size = cpu_to_le32(filesize);
++	hdr->brlyt.header_size = cpu_to_le32(hdr_offset + sizeof(*hdr));
++	hdr->brlyt.total_size = cpu_to_le32(hdr_offset + filesize);
+ 	hdr->brlyt.header_size_2 = hdr->brlyt.header_size;
+ 	hdr->brlyt.total_size_2 = hdr->brlyt.total_size;
+ 
+@@ -747,6 +788,9 @@ static void mtk_image_set_header(void *ptr, struct stat *sbuf, int ifd,
+ 		return;
+ 	}
+ 
++	img_gen = true;
++	img_size = sbuf->st_size;
++
+ 	if (hdr_media == BRLYT_TYPE_NAND || hdr_media == BRLYT_TYPE_SNAND)
+ 		mtk_image_set_nand_header(ptr, sbuf->st_size, params->addr);
+ 	else
-- 
2.34.1

